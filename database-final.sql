-- MySQL dump 10.13  Distrib 8.0.33, for Linux (x86_64)
--
-- Host: localhost    Database: npe
-- ------------------------------------------------------
-- Server version	8.0.33

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `advertisement`
--

DROP TABLE IF EXISTS `advertisement`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `advertisement` (
  `id` bigint NOT NULL COMMENT 'ID',
  `url` varchar(512) NOT NULL COMMENT '点击广告跳转的地址',
  `image` varchar(128) NOT NULL COMMENT '广告图片的文件名',
  `time` datetime NOT NULL COMMENT '广告设置的时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='推广、广告';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `advertisement`
--

LOCK TABLES `advertisement` WRITE;
/*!40000 ALTER TABLE `advertisement` DISABLE KEYS */;
INSERT INTO `advertisement` VALUES (1661094816158584833,'https://www.bilibili.com/video/BV1kk4y1s7Yo/','90fda8ad-557b-4310-a422-cc03e0592130','2023-05-24 03:40:40'),(1661095068424998913,'https://www.bilibili.com/video/BV1jx4y1L7PQ/','de01f1fb-5c83-48ff-a66c-774e74ba7425','2023-05-24 03:41:41');
/*!40000 ALTER TABLE `advertisement` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `announcement`
--

DROP TABLE IF EXISTS `announcement`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `announcement` (
  `id` bigint NOT NULL COMMENT '公告的ID',
  `title` varchar(256) NOT NULL COMMENT '公告的标题',
  `text` text NOT NULL COMMENT '公告的正文',
  `time` datetime NOT NULL COMMENT '发布时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='公告';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `announcement`
--

LOCK TABLES `announcement` WRITE;
/*!40000 ALTER TABLE `announcement` DISABLE KEYS */;
INSERT INTO `announcement` VALUES (1660710238541631490,'NullPointerException社区运营公告','<h3>什么都没有啦！</h3>','2023-05-23 02:12:30'),(1660710539147399169,'关于有害内容与无关内容的处理方法','如果你在网站浏览过程中遇到了上述内容，\n你可以点击对应内容的举报按钮，\n填写举报信息进行举报。','2023-05-23 02:13:42');
/*!40000 ALTER TABLE `announcement` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `approval_answer`
--

DROP TABLE IF EXISTS `approval_answer`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `approval_answer` (
  `id` bigint NOT NULL COMMENT '点赞记录ID',
  `user_id` bigint NOT NULL COMMENT '用户ID',
  `answer_id` bigint NOT NULL COMMENT '回答的ID',
  `time` datetime NOT NULL COMMENT '点赞时间',
  PRIMARY KEY (`id`),
  KEY `approval_answer_question_answer_id_fk` (`answer_id`),
  KEY `approval_answer_user_info_id_fk` (`user_id`),
  CONSTRAINT `approval_answer_question_answer_id_fk` FOREIGN KEY (`answer_id`) REFERENCES `question_answer` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `approval_answer_user_info_id_fk` FOREIGN KEY (`user_id`) REFERENCES `user_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户对回答赞的记录';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `approval_answer`
--

LOCK TABLES `approval_answer` WRITE;
/*!40000 ALTER TABLE `approval_answer` DISABLE KEYS */;
INSERT INTO `approval_answer` VALUES (1660698999396528129,1660690671299731457,1660698651055386626,'2023-05-23 01:27:50'),(1661086066479771650,1004,1660706097249435662,'2023-05-24 03:05:54');
/*!40000 ALTER TABLE `approval_answer` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `approval_article`
--

DROP TABLE IF EXISTS `approval_article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `approval_article` (
  `id` bigint NOT NULL COMMENT '点赞记录ID',
  `user_id` bigint NOT NULL COMMENT '用户ID',
  `article_id` bigint NOT NULL COMMENT '文章ID',
  `time` datetime NOT NULL COMMENT '点赞时间',
  PRIMARY KEY (`id`),
  KEY `approval_article_user_info_id_fk` (`user_id`),
  KEY `approval_article_article_id_fk` (`article_id`),
  CONSTRAINT `approval_article_article_id_fk` FOREIGN KEY (`article_id`) REFERENCES `article` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `approval_article_user_info_id_fk` FOREIGN KEY (`user_id`) REFERENCES `user_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户对文章赞的记录';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `approval_article`
--

LOCK TABLES `approval_article` WRITE;
/*!40000 ALTER TABLE `approval_article` DISABLE KEYS */;
INSERT INTO `approval_article` VALUES (1,1,1004,'2023-05-23 12:33:22'),(2,2,1004,'2023-05-23 12:33:22'),(3,3,1004,'2023-05-23 12:33:22'),(4,4,1004,'2023-05-23 12:33:22'),(5,5,1015,'2023-05-23 12:33:22'),(6,1001,1015,'2023-05-23 12:33:22'),(7,1002,1015,'2023-05-23 12:33:22'),(8,1003,1015,'2023-05-23 12:33:22'),(9,1004,1015,'2023-05-23 12:33:22'),(10,1005,1018,'2023-05-23 12:33:22'),(11,7,1018,'2023-05-23 12:33:22'),(12,8,1018,'2023-05-23 12:33:22'),(13,4,1018,'2023-05-23 12:33:22'),(14,5,1018,'2023-05-23 12:33:22'),(15,6,1018,'2023-05-23 12:33:22'),(16,7,1012,'2023-05-23 12:33:22');
/*!40000 ALTER TABLE `approval_article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article`
--

DROP TABLE IF EXISTS `article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article` (
  `id` bigint NOT NULL COMMENT '文章ID',
  `title` varchar(256) NOT NULL COMMENT '文章标题',
  `text` longtext NOT NULL COMMENT '文章正文',
  `category` varchar(64) NOT NULL COMMENT '文章的分类',
  `publisher_id` bigint NOT NULL COMMENT '发布者用户ID',
  `publish_time` datetime NOT NULL COMMENT '发布时间',
  PRIMARY KEY (`id`),
  KEY `article_user_info_id_fk` (`publisher_id`),
  CONSTRAINT `article_user_info_id_fk` FOREIGN KEY (`publisher_id`) REFERENCES `user_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='文章';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article`
--

LOCK TABLES `article` WRITE;
/*!40000 ALTER TABLE `article` DISABLE KEYS */;
INSERT INTO `article` VALUES (1001,'24个写出漂亮代码的小技巧','「Java学习 + 面试指南」: javaguide.cn （一份涵盖大部分 Java 程序员所需要掌握的核心知识）\n这篇文章我会总结一些实用的有助于提高代码质量的建议，内容较多，建议收藏！\n\n# 提取通用处理逻辑\n注解、反射和动态代理是 Java 语言中的利器，使用得当的话，可以大大简化代码编写，并提高代码的可读性、可维护性和可扩展性。\n\n我们可以利用 注解 + 反射 和 注解+动态代理 来提取类、类属性或者类方法通用处理逻辑，进而避免重复的代码。虽然可能会带来一些性能损耗，但与其带来的好处相比还是非常值得的。\n\n通过 注解 + 反射 这种方式，可以在运行时动态地获取类的信息、属性和方法，并对它们进行通用处理。比如说在通过 Spring Boot 中通过注解验证接口输入的数据就是这个思想的运用，我们通过注解来标记需要验证的参数，然后通过反射获取属性的值，并进行相应的验证。\n```java\n@Data\n@Builder\n@AllArgsConstructor\n@NoArgsConstructor\npublic class PersonRequest {\n\n    @NotNull(message = \"classId 不能为空\")\n    private String classId;\n\n    @Size(max = 33)\n    @NotNull(message = \"name 不能为空\")\n    private String name;\n\n    @Pattern(regexp = \"(^Man$|^Woman$|^UGM$)\", message = \"sex 值不在可选范围\")\n    @NotNull(message = \"sex 不能为空\")\n    private String sex;\n\n    @Region\n    private String region;\n\n    @PhoneNumber(message = \"phoneNumber 格式不正确\")\n    @NotNull(message = \"phoneNumber 不能为空\")\n    private String phoneNumber;\n\n}\n```\n\n通过 注解 + 动态代理 这种方式，可以在运行时生成代理对象，从而实现通用处理逻辑。比如说 Spring 框架中，AOP 模块正是利用了这种思想，通过在目标类或方法上添加注解，动态生成代理类，并在代理类中加入相应的通用处理逻辑，比如事务管理、日志记录、缓存处理等。同时，Spring 也提供了两种代理实现方式，即基于 JDK 动态代理和基于 CGLIB 动态代理（JDK 动态代理底层基于反射，CGLIB 动态代理底层基于字节码生成），用户可以根据具体需求选择不同的实现方式。\n```java\n@LogRecord(content = \"修改了订单的配送地址：从“#oldAddress”, 修改到“#request.address”\",\n        bizNo=\"#request.deliveryOrderNo\")\npublic void modifyAddress(updateDeliveryRequest request){\n    // 查询出原来的地址是什么\n    LogRecordContext.putVariable(\"oldAddress\", DeliveryService.queryOldAddress(request.getDeliveryOrderNo()));\n    // 更新派送信息 电话，收件人、地址\n    doUpdate(request);\n}\n```\n\n# 避免炫技式单行代码\n代码没必要一味追求“短”，是否易于阅读和维护也非常重要。像炫技式的单行代码就非常难以理解、排查和修改起来都比较麻烦且耗时。\n\n反例：\n```java\nif (response.getData() != null && CollectionUtils.isNotEmpty(response.getData().getShoppingCartDTOList())) {\n      cartList = response.getData().getShoppingCartDTOList().stream().map(CartResponseBuilderV2::buildCartList).collect(Collectors.toList());\n}\n```\n正例：\n```java\nT data = response.getData();\nif (data != null && CollectionUtils.isNotEmpty(data.getShoppingCartDTOList())) {\n  cartList = StreamUtil.map(data.getShoppingCartDTOList(), CartResponseBuilderV2::buildCartList);\n}\n```\n\n# 基于接口编程提高扩展性\n基于接口而非实现编程是一种常用的编程范式，也是一种非常好的编程习惯，一定要牢记于心！\n\n基于接口编程可以让代码更加灵活、更易扩展和维护，因为接口可以为不同的实现提供相同的方法签名（方法的名称、参数类型和顺序以及返回值类型）和契约（接口中定义的方法的行为和约束，即方法应该完成的功能和要求），这使得实现类可以相互替换，而不必改变代码的其它部分。另外，基于接口编程还可以帮助我们避免过度依赖具体实现类，降低代码的耦合性，提高代码的可测试性和可重用性。\n\n就比如说在编写短信服务、邮箱服务、存储服务等常用第三方服务的代码时，我们可以先先定义一个接口，接口中抽象出具体的方法，然后实现类再去实现这个接口。\n```java\npublic interface SmsSender {\n    SmsResult send(String phone, String content);\n    SmsResult sendWithTemplate(String phone, String templateId, String[] params);\n}\n\n/*\n * 阿里云短信服务\n */\npublic class AliyunSmsSender implements SmsSender {\n  ...\n}\n\n/*\n * 腾讯云短信服务\n */\npublic class TencentSmsSender implements SmsSender {\n  ...\n}\n```\n拿短信服务这个例子来说，如果需要新增一个百度云短信服务，直接实现 SmsSender 即可。如果想要替换项目中使用的短信服务也比较简单，修改的代码非常少，甚至说可以直接通过修改配置无需改动代码就能轻松更改短信服务。\n\n操作数据库、缓存、中间件的代码单独抽取一个类\n尽量不要将操作数据库、缓存、中间件的代码和业务处理代码混合在一起，而是要单独抽取一个类或者封装一个接口，这样代码更清晰易懂，更容易维护，一些通用逻辑也方便统一维护。\n\n数据库：\n```java\npublic interface UserRepository extends JpaRepository<User, Long> {\n  ...\n}\n```\n缓存：\n```java\n@Repository\npublic class UserRedis {\n\n    @Autowired\n    private RedisTemplate<String, String> redisTemplate;\n\n    public User save(User user) {\n    }\n}\n```\n消息队列：\n```java\n// 取消订单消息生产者\npublic class CancelOrderProducer{\n ...\n}\n// 取消订单消息消费者\npublic class CancelOrderConsumer{\n ...\n}\n```\n\n# 不要把业务代码放在 Controller 中\n这个是老生常谈了，最基本的规范。一定不要把业务代码应该放在 Controller 中，业务代码就是要交给 Service 处理。\n\n业务代码放到 Service 的好处 ：\n\n避免 Controller 的代码过于臃肿，进而难以维护和扩展。\n抽象业务处理逻辑，方便复用比如给用户增加积分的操作可能会有其他的 Service 用到。\n避免一些小问题比如 Controller 层通过 @Value注入值会失败。\n更好的进行单元测试。如果将业务代码放在 Controller 中，会增加测试难度和不确定性。\n错误案例：\n```java\n@RestController\npublic class UserController {\n    @Autowired\n    private UserRepository userRepository;\n\n    @GetMapping(\"/users/{id}\")\n    public Result<UserVO> getUser(@RequestParam(name = \"userId\", required = true) Long userId) {\n        User user = repository.findById(id)\n                  .orElseThrow(() -> new UserNotFoundException(id));\n        UserVO userVO = new UserVO();\n        BeanUtils.copyProperties(user, userVO);//演示使用\n        // 可能还有其他业务操作\n        ...\n        return Result.success(userVO);\n    }\n    ...\n}\n```\n静态函数放入工具类\n静态函数/方法不属于某个特定的对象，而是属于这个类。调用静态函数无需创建对象，直接通过类名即可调用。\n\n静态函数最适合放在工具类中定义，比如文件操作、格式转换、网络请求等。\n```java\n/**\n * 文件工具类\n */\npublic class FileUtil extends PathUtil {\n\n    /**\n     * 文件是否为空<br>\n     * 目录：里面没有文件时为空 文件：文件大小为0时为空\n     *\n     * @param file 文件\n     * @return 是否为空，当提供非目录时，返回false\n     */\n    public static boolean isEmpty(File file) {\n        // 文件为空或者文件不存在直接返回 true\n        if (null == file || false == file.exists()) {\n            return true;\n        }\n        if (file.isDirectory()) {\n            // 文件是文件夹的情况\n            String[] subFiles = file.list();\n            return ArrayUtil.isEmpty(subFiles);\n        } else if (file.isFile()) {\n            // 文件不是文件夹的情况\n            return file.length() <= 0;\n        }\n\n        return false;\n    }\n}\n```\n\n# 善用现有的工具类库\nJava 的一大优势就是生态特别好， 包含了许多好用的工具类库和框架，几乎覆盖了所有的需求场景。很多事情我们完全不需要自己从头开始做，利用现有的稳定可靠的工具类库可以大大提高开发效率。\n\n比如 Excel 文档处理，你可以考虑下面这几个开源的工具类库：\n\neasyexcel :快速、简单避免 OOM 的 Java 处理 Excel 工具。\nexcel-streaming-reader：Excel 流式代码风格读取工具（只支持读取 XLSX 文件），基于 Apache POI 封装，同时保留标准 POI API 的语法。\nmyexcel：一个集导入、导出、加密 Excel 等多项功能的工具包。\n再比如 PDF 文档处理：\n\npdfbox :用于处理 PDF 文档的开放源码 Java 工具。该项目允许创建新的 PDF 文档、对现有文档进行操作以及从文档中提取内容。PDFBox 还包括几个命令行实用程序。PDFBox 是在 Apache 2.0 版许可下发布的。\nOpenPDF：OpenPDF 是一个免费的 Java 库，用于使用 LGPL 和 MPL 开源许可创建和编辑 PDF 文件。OpenPDF 基于 iText 的一个分支。\nitext7：iText 7 代表了想要利用利用好 PDF 的开发人员的更高级别的 sdk。iText 7 配备了更好的文档引擎、高级和低级编程功能以及创建、编辑和增强 PDF 文档的能力，几乎对每个工作流都有好处。\nFOP :Apache FOP 项目的主要的输出目标是 PDF。\n我的网站上总结了 Java 开发常用的一些工具类库，可以作为参考：https://javaguide.cn/open-source-project/tool-library.html 。\n\n# 善用设计模式\n实际开发项目的过程中，我们应该合理地使用现有的设计模式来优化我们的代码。不过，切忌为了使用设计模式而使用。\n\n新来了个同事，设计模式用的是真优雅呀！这篇文章中介绍了 9 种在源码中非常常见的设计模式：\n\n* 工厂模式（Factory Pattern） ：通过定义一个工厂方法来创建对象，从而将对象的创建和使用解耦，实现了“开闭原则”。\n* 建造者模式（Builder Pattern） ：通过链式调用和流式接口的方式，创建一个复杂对象，而不需要直接调用它的构造函数。\n* 单例模式（Singleton Pattern） ：确保一个类只有一个实例，并且提供一个全局的访问点，比如常见的 Spring Bean 单例模式。\n* 原型模式（Prototype Pattern） ：通过复制现有的对象来创建新的对象，从而避免了对象的创建成本和复杂度。\n* 适配器模式（Adapter Pattern） ：将一个类的接口转换成客户端所期望的接口，从而解决了接口不兼容的问题。\n* 桥接模式（Bridge Pattern） ：将抽象部分与实现部分分离开来，从而使它们可以独立变化。\n* 装饰器模式（Decorator Pattern） ：动态地给一个对象添加一些额外的职责，比如 Java 中的 IO 流处理。\n* 代理模式（Proxy Pattern） ：为其他对象提供一种代理以控制对这个对象的访问，比如常见的 Spring AOP 代理模式。\n* 观察者模式（Observer Pattern） ：定义了对象之间一种一对多的依赖关系，从而当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。\n\n# 策略模式替换条件逻辑\n策略模式是一种常见的优化条件逻辑的方法。当代码中有一个包含大量条件逻辑（即 if 语句）的方法时，你应该考虑使用策略模式对其进行优化，这样代码更加清晰，同时也更容易维护。\n\n假设我们有这样一段代码：\n```java\npublic class IfElseDemo {\n\n    public double calculateInsurance(double income) {\n        if (income <= 10000) {\n            return income*0.365;\n        } else if (income <= 30000) {\n            return (income-10000)*0.2+35600;\n        } else if (income <= 60000) {\n            return (income-30000)*0.1+76500;\n        } else {\n            return (income-60000)*0.02+105600;\n        }\n\n    }\n}\n```\n下面是使用策略+工厂模式重构后的代码：\n\n首先定义一个接口 InsuranceCalculator，其中包含一个方法 calculate(double income)，用于计算保险费用。\n```java\npublic interface InsuranceCalculator {\n    double calculate(double income);\n}\n//然后，分别创建四个类来实现这个接口，每个类代表一个保险费用计算方式。\n\npublic class FirstLevelCalculator implements InsuranceCalculator {\n    public double calculate(double income) {\n        return income * 0.365;\n    }\n}\n\npublic class SecondLevelCalculator implements InsuranceCalculator {\n    public double calculate(double income) {\n        return (income - 10000) * 0.2 + 35600;\n    }\n}\n\npublic class ThirdLevelCalculator implements InsuranceCalculator {\n    public double calculate(double income) {\n        return (income - 30000) * 0.1 + 76500;\n    }\n}\n\npublic class FourthLevelCalculator implements InsuranceCalculator {\n    public double calculate(double income) {\n        return (income - 60000) * 0.02 + 105600;\n    }\n}\n```\n最后，我们可以为每个策略类添加一个唯一的标识符，例如字符串类型的 name 属性。然后，在工厂类中创建一个 Map 来存储策略对象和它们的标识符之间的映射关系（也可以用 switch 来维护映射关系）。\n```java\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class InsuranceCalculatorFactory {\n    private static final Map<String, InsuranceCalculator> CALCULATOR_MAP = new HashMap<>();\n\n    static {\n        CALCULATOR_MAP.put(\"first\", new FirstLevelCalculator());\n        CALCULATOR_MAP.put(\"second\", new SecondLevelCalculator());\n        CALCULATOR_MAP.put(\"third\", new ThirdLevelCalculator());\n        CALCULATOR_MAP.put(\"fourth\", new FourthLevelCalculator());\n    }\n\n    public static InsuranceCalculator getCalculator(double income) {\n        if (income <= 10000) {\n            return CALCULATOR_MAP.get(\"first\");\n        } else if (income <= 30000) {\n            return CALCULATOR_MAP.get(\"second\");\n        } else if (income <= 60000) {\n            return CALCULATOR_MAP.get(\"third\");\n        } else {\n            return CALCULATOR_MAP.get(\"fourth\");\n        }\n    }\n}\n```\n这样，就可以通过 InsuranceCalculatorFactory 类手动获取相应的策略对象了。\n```\ndouble income = 40000;\n// 获取第三级保险费用计算器\nInsuranceCalculator calculator = InsuranceCalculatorFactory.getCalculator(income);\ndouble insurance = calculator.calculate(income);\nSystem.out.println(\"保险费用为：\" + insurance);\n```\n这种方式允许我们在运行时根据需要选择不同的策略，而无需在代码中硬编码条件语句。\n','Java',1001,'2023-05-15 13:15:37'),(1002,'本机搭建三节点 k8s 集群','# 本机搭建三节点 k8s 集群\n\n毕业设计题目是写一个基于微服务的高可用应用系统。微服务的部署使用 docker + k8s，所以前提是要有一个 k8s 集群。搭建过程中遇到了一些坑，把整个流程\n记录下来一是回顾搭建过程，二是希望能尽可能的帮助后来的 k8s beginners 少走些弯路。\n\n本文的侧重点在实际操作，k8s 组件基本概念相关的信息请参考 [k8s 官方文档](https://kubernetes.io/docs/concepts/) 或 [Kubernetes 指南 - by feiskyer](https://github.com/feiskyer/kubernetes-handbook)\n\n如果对于本文有什么建议、意见及疑问，欢迎提 issue，或直接发邮件交流(邮箱很容易能找到，不再提供)。\n\n\n## 环境依赖\n\n本文假设读者会使用 Linux 命令行。\n\nk8s 的镜像源在墙外，所以需要读者掌握科学上网的技能。这个部分不属于本文的描述范围，我使用的方案是 Shadowsocks + Privoxy，有需要可以跟我交流。\n\n```bash\n- Docker    : 1.13.1\n- kube*     : 1.10\n- flannel   : 0.10.0\n- virtualBox: 5.2.8\n- OS        : ubuntu-16.04.4-server-amd64.iso\n```\n\nvirtualBox 的版本不太重要，Docker 和 kube* 的版本最好使用 k8s 推荐的版本，否则可能会有问题，推荐的 Docker 版本可以在版本的 `release` 文档中查看。OS 的版本不同，后面的一些配置的方法会略有不同。\n\n## 搭建目标\n\n|主机名|主机 IP| flannel.1 |OS|集群角色|\n|---|---|---|---|---|\n|master|192.168.99.200|10.244.0.0|Ubuntu 16.04| master |\n|node1|192.168.99.201|10.244.1.0|Ubuntu 16.04|node|\n|node2|192.168.99.202|10.244.2.0|Ubuntu 16.04|node|\n\nflannel.1 是 每台机器上的一个 VNI，通过 `ifconfig` 命令可以查看该接口的信息。\n\n从任意一台机器 ping 另外两台机器 flanel.1 的 IP 能通就算集群搭建成功。\n\n```bash\n# from master\n$ ping 10.244.1.0\nPING 10.244.1.0 (10.244.1.0) 56(84) bytes of data.\n64 bytes from 10.244.1.0: icmp_seq=1 ttl=64 time=0.659 ms\n64 bytes from 10.244.1.0: icmp_seq=2 ttl=64 time=0.478 ms\n64 bytes from 10.244.1.0: icmp_seq=3 ttl=64 time=0.613 ms\n^C\n--- 10.244.1.0 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 1999ms\nrtt min/avg/max/mdev = 0.478/0.583/0.659/0.079 ms\n\n$ ping 10.244.2.0\nPING 10.244.2.0 (10.244.2.0) 56(84) bytes of data.\n64 bytes from 10.244.2.0: icmp_seq=1 ttl=64 time=0.459 ms\n64 bytes from 10.244.2.0: icmp_seq=2 ttl=64 time=0.504 ms\n64 bytes from 10.244.2.0: icmp_seq=3 ttl=64 time=0.553 ms\n^C\n--- 10.244.2.0 ping statistics ---\n3 packets transmitted, 3 received, 0% packet loss, time 2058ms\nrtt min/avg/max/mdev = 0.459/0.505/0.553/0.042 ms\n```\n\n## k8s 个组件之间的关系\n\n![k8s-arch](../res/k8s-arch.png)\n\n其实这个没必要多说，[Kubernetes Components](https://kubernetes.io/docs/concepts/overview/components/) 或 [Kubernetes 核心组件 - by feiskyer](https://kubernetes.feisky.xyz/zh/components/) 讲的已经非常好了，这里提到只是强调一下这部分的重要性。\n\n## k8s Pod 网络模型简介\n\n![k8s-net-model](../res/k8s-net-model.png)\n\n- 图片来源：[一次Flannel和Docker网络不通定位问题](http://www.cnblogs.com/ericnie/p/8028681.html)\n\n为了省事，我直接引用了别人画的模型图。对于本次搭建的集群模型简单描述如下：\n\n```bash\n\nPod1(10.244.1.10)   ----|\n                        cni0(10.244.1.1/24) ----- flannel.1(10.244.1.0/32) ----- flanneld ----- enp0s8 (192.168.99.201)\nPod2(10.244.1.11)   ----|                                                                           |\n                                                                                                    |\n                                                                                                    |\n                                                                                                    |\nPod3(10.244.2.10)   ----|                                                                           |\n                        cni0(10.244.2.1/24) ----- flannel.1(10.244.2.0/32) ----- flanneld ----- enp0s8 (192.168.99.202)\nPod4(10.244.2.11)   ----|\n\n```\n\n1. `cni0` 和 `flannel.1` 都是 VNI，由 flannel 组件创建，集群搭建完成后可以通过 `ifconfig` 进行查看。\n1. flannel 组件 在每台机器上运行了一个 `flanneld`，它是用来转发流量，解决主机间通信的问题。\n1. `enp0s8` 是 virtualBox 的 Host-Only 适配器。\n\n## 配置流程\n\n### 使用 virtualBox 创建三台虚拟机\n\nvirtualBox 安装比较简单，不再介绍，GUI 工具用起来也很方便，这部分只介绍我认为需要提示的部分。\n\n1. 内存推荐 2048M, CPU 推荐 2个\n1. 默认只有一个 NAT 适配器，添加一个 Host-Only Adapter。NAT 适配器是虚拟机用来访问互联网的，Host-Only 适配器是用来虚拟机之间通信的。\n1. 以 Normal Start 方式启动虚拟机安装完系统以后，因为是 server 版镜像，所以没有图形界面，直接使用用户名密码登录即可。\n1. 修改配置，`enp0s8` 使用静态 IP。配置请参考 [SSH between Mac OS X host and Virtual Box guest](https://gist.github.com/c-rainstorm/1bbd44b388acd35ca6eaf07d1fbd9bc7)。注意配置时将其中的网络接口名改成你自己的 Host-Only Adapter 对应的接口。\n1. 一台虚拟机创建完成以后可以使用 clone 方法复制出两台节点出来，注意 clone 时为新机器的网卡重新初始化 MAC 地址。\n1. 三台虚拟机的静态 IP 都配置好以后就可以使用 ssh 在本地主机的终端上操作三台虚机了。虚机使用 Headless Start 模式启动\n\n### 安装 Docker\n\n- **三台都装**\n\n当前 Ubuntu 的 docker 版本刚好合适，所以可以直接安装，但是有必要提前查看一下 docker 版本，以免装错。\n\n```bash\n# apt search docker.io\napt-get update\napt-get install -y docker.io\nsystemctl enable docker\nsystemctl start docker\n```\n\n[official Docker installation guides](https://docs.docker.com/engine/installation/)\n\n- docker 配置代理。镜像源在墙外，docker pull image 需要代理\n\n```bash\nmkdir -p /etc/systemd/system/docker.service.d\n\ncat <<EOF >/etc/systemd/system/docker.service.d/http-proxy.conf\n[Service]\nEnvironment=\"HTTP_PROXY=https://192.168.99.1:8118/\"\nEnvironment=\"HTTPS_PROXY=https://192.168.99.1:8118/\"\nEnvironment=\"NO_PROXY=localhost,127.0.0.1,localaddress,.localdomain.com\"\nEOF\n\nsystemctl daemon-reload\nsystemctl restart docker\n```\n\n- 测试配置\n\n```bash\ndocker info | grep Proxy  # 有输出说明配置成功\n\ndocker pull gcr.io/google-containers/busybox:1.27 # pull 成功代表工作正常。\n```\n\n- [Google 镜像库](https://console.cloud.google.com/gcr/images/google-containers/GLOBAL?project=google-containers)\n\n### 安装 kube* 组件\n\n- **三台都装**\n\n```bash\napt-get update && apt-get install -y apt-transport-https\ncurl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | apt-key add -\ncat <<EOF >/etc/apt/sources.list.d/kubernetes.list\ndeb http://apt.kubernetes.io/ kubernetes-xenial main\nEOF\napt-get update\napt-get install -y kubelet kubeadm kubectl\nsystemctl enable kubelet\nsystemctl start kubelet\n```\n\n- Master 节点配置 cgroup driver\n\n```bash\ndocker info | grep -i cgroup  # 一般是 cgroupfs\ncat /etc/systemd/system/kubelet.service.d/10-kubeadm.conf  # --cgroup-driver 对应值默认是 systemd\n\n#两个值不一致的话使用以下命令修改\nsed -i \"s/cgroup-driver=systemd/cgroup-driver=cgroupfs/g\" /etc/systemd/system/kubelet.service.d/10-kubeadm.conf\n\n#重启 kubelet\nsystemctl daemon-reload\nsystemctl restart kubelet\n```\n\n- curl 访问的是墙外的网站，无法访问的话可以配置系统代理。\n\n`http://192.168.99.1:8118/` 是我本地使用的 HTTP 代理，Privoxy 监听 8118 端口，按照实际情况修改该地址。\n\n```bash\n# 全局代理，不推荐\ncat <<EOF >>/etc/environment\nhttp_proxy=\"http://192.168.99.1:8118/\"\nhttps_proxy=\"http://192.168.99.1:8118/\"\nno_proxy=\"master, node1, node2, 192.168.99.1\"\nEOF\nsource /etc/environment\n\n#当前 shell,推荐\nexport http_proxy=\"http://192.168.99.1:8118/\"\nexport https_proxy=\"http://192.168.99.1:8118/\"\nexport no_proxy=\"master, node1, node2, 192.168.99.1\"\n```\n\n- `apt` 使用代理\n\n```bash\ncat <<EOF >>/etc/apt/apt.conf\nAcquire::http::Proxy \"http://192.168.99.1:8118/\";\nAcquire::https::Proxy \"https://192.168.99.1:8118/\";\nEOF\n```\n\n### 搭建集群\n\n#### 禁用交换区\n\nk8s 文档明确要求的。\n\n- **三台都禁用**\n\n```bash\nswapoff -a\n```\n\n#### 初始化 master 节点\n\n- **初始化过程会访问墙外网站，如果 init 不能顺利执行，请配置全局代理**\n\n```bash\nkubeadm init --apiserver-advertise-address=192.168.99.200 --pod-network-cidr=10.244.0.0/16\n```\n\n1. `--apiserver-advertise-address=192.168.99.200` 绑定 apiserver 到 master 节点的 Host-Only 适配器的地址，默认是绑到 NAT 的地址上，这样其他机器是永远也访问不到的。\n1. `--pod-network-cidr=10.244.0.0/16` 指定 pod 网络地址空间，我们使用 flannel 组件必须使用这个空间。\n1. kubeadm 的完整参考手册 [kubeadm reference guide](https://kubernetes.io/docs/reference/setup-tools/kubeadm/kubeadm/)\n1. 推荐保存最后输出的 join 命令到文件(以免忘记或找不到了)，方便添加节点到集群。如果忘了也找不到输出了，网上有方法生成哈希值，请自行查找。\n\n- 配置 kubectl 访问集群\n\n```bash\n# root user\nexport KUBECONFIG=/etc/kubernetes/admin.conf\n\n# non-root user\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n\n# 从本地主机操作，需要在本地安装 kubectl 客户端\nmkdir -p ~/.kube\n\nscp <username>@192.168.99.200:/home/<username>/.kube/config ~/.kube/config # 从 master 复制配置文件到本地\n```\n\n- 测试配置\n\n```bash\nkubectl cluster-info #有正常输出即可\n```\n\n#### 安装 flannel 网络\n\n- flannel 默认的监听接口是 NAT 适配器的接口，我们需要的是 Host-Only 适配器的接口，所以需要修改 kube-flannel.yml 文件\n\n```bash\nwget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml\n\n给 /opt/bin/flanneld 命令添加 --iface=\"enp0s8\" 参数 # enp0s8 是 Host-Only 适配器对应的接口\n\nkubectl apply -f kube-flannel.yml\n```\n\n- 测试配置\n\n```bash\nkubectl get pods --all-namespaces -o wide # 稍等一会，下载镜像需要一定时间，最后应该显示 flannel pods 是 Running 状态， kube-dns 也是 Running 状态\n```\n\n- 消除 master 隔离。默认 master 上不调度 pods，要允许另外的 pods 在 master 上运行请执行该命令\n\n```bash\nkubectl taint nodes --all node-role.kubernetes.io/master-\n```\n\n#### 添加节点到集群\n\n- 在节点上执行 `kubeadm init` 最后输出的 join 命令\n\n```bash\nkubeadm join --token <token> <master-ip>:<master-port> --discovery-token-ca-cert-hash sha256:<hash>\n```\n\n## 最后\n\nfeiskyer 为该搭建过程写了[自动化脚本](https://github.com/feiskyer/ops)，有兴趣可以尝试一下。\n\n## 参考\n\n1. [k8s 官方文档](https://kubernetes.io/docs/concepts/)\n1. [Kubernetes 指南 - by feiskyer](https://github.com/feiskyer/kubernetes-handbook)\n1. [一次Flannel和Docker网络不通定位问题](http://www.cnblogs.com/ericnie/p/8028681.html)\n1. [coreos/flannel - README](https://github.com/coreos/flannel/blob/master/README.md)\n1. [Installing kubeadm](https://kubernetes.io/docs/setup/independent/install-kubeadm/)\n1. [Docker Ubuntu Behind Proxy](https://stackoverflow.com/questions/26550360/docker-ubuntu-behind-proxy?utm_medium=organic&utm_source=google_rich_qa&utm_campaign=google_rich_qa)\n1. [Using kubeadm to Create a Cluster](https://kubernetes.io/docs/setup/independent/create-cluster-kubeadm/)\n','k8s',1002,'2023-05-14 12:18:26'),(1003,'Mysql 清空数据库','最近项目中需要一个清空数据库数据的操作。在网上一直没能找到让我很满意的方法，所以自己动手写了一个。\n\n- 方法特点： 简单易用，只需要执行一条 `SQL`，而不需要其他命令\n\n该方法基于 `TRUNCATE TABLE` 命令。\n1. 定义例程： `PROCEDURE clear_database`\n1. 执行清空命令： `call clear_database();`\n\n```sql\n-- 销毁之前的定义\nDROP PROCEDURE IF EXISTS clear_database;\n\n-- 清空数据库的存储例程， 客户端直接使用 `call clear_database();` 即可。\nDELIMITER $\nCREATE PROCEDURE clear_database()\n  BEGIN\n    -- 用来临时存放表名\n    DECLARE tname VARCHAR(50);\n\n    -- 结果集遍历结束标志\n    DECLARE done INT DEFAULT FALSE;\n\n    -- 定义游标\n    DECLARE cur CURSOR FOR\n      -- 查询当前数据库中的所有表的表名\n      -- 可以对该 sql 进行修改，去掉需要保留的表。\n      SELECT TABLE_NAME\n      FROM INFORMATION_SCHEMA.TABLES\n      WHERE TABLE_SCHEMA = (SELECT database());\n\n    -- 当游标到达结果集尾的时候设置 done 为 true\n    DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;\n\n\n    SET @tt = \'TRUNCATE TABLE \';\n\n    -- 关闭外键检测\n    SET FOREIGN_KEY_CHECKS = 0;\n\n    OPEN cur;\n    read_loop: LOOP\n      -- 读取一条记录到 tname\n      FETCH cur INTO tname;\n\n      -- 拼接实际执行的语句\n      SET @sqlexe = concat(@tt, tname);\n\n      -- 如果到达了结果集的尾部，跳出循环\n      IF done\n      THEN\n        LEAVE read_loop;\n      END IF;\n\n      -- 定义 PREPARE\n      PREPARE TRUNCATE_TABLE FROM @sqlexe;\n\n      -- 执行清空语句\n      EXECUTE TRUNCATE_TABLE;\n    END LOOP;\n    CLOSE cur;\n\n    -- 销毁 PREPARE\n    DEALLOCATE PREPARE TRUNCATE_TABLE;\n\n    -- 重新开启外键检测\n    SET FOREIGN_KEY_CHECKS = 1;\n  END $\n\nDELIMITER ;\n```\n\n- 该定义无需修改即可用于其他数据库。\n- 若有特殊需要可以定制其中的 `SELECT` 语句，只选出想要清空的表即可。\n\n\n## 参考\n\n- [MySQL 5.7 Reference Manual](https://dev.mysql.com/doc/refman/5.7/en/)\n','MySQL',1003,'2023-05-15 03:20:03'),(1004,'Unicode 学习笔记','# Unicode 学习笔记\n\n## Unicode encoding model\n\n> The four levels of the Unicode Character Encoding Model can be summarized as:\n> - ACR: Abstract Character Repertoire<br>\n        the set of characters to be encoded, for example, some alphabet or symbol set\n> - CCS: Coded Character Set<br>\n        a mapping from an abstract character repertoire to a set of nonnegative integers\n> - CEF: Character Encoding Form<br>\n        a mapping from a set of nonnegative integers that are elements of a CCS to a set of sequences of particular code units of some specified width, such as 32-bit integers\n> - CES: Character Encoding Scheme<br>\n        a reversible transformation from a set of sequences of code units (from one or more CEFs to a serialized sequence of bytes)\n\n> In addition to the four individual levels, there are two other useful concepts:\n> - CM: Character Map<br>\n        a mapping from sequences of members of an abstract character repertoire to serialized sequences of bytes bridging all four levels in a single operation\n> - TES: Transfer Encoding Syntax <br>\n        a reversible transform of encoded data, which may or may not contain textual data\n            \n> [Unicode Character Encoding Model -- unicode.org][Unicode Character Encoding Model -- unicode.org]\n\n- 四个层次\n    1. 抽象字符层(ACR)。比如我们平时使用的文字就是抽象字符。\n    1. 码化字符集(CCS)。所有抽象字符映射为一系列非负数（Code point）。\n    1. 字符编码方式(CEF)。将上一层的整数转为代码单元（code unit）的集合。\n    1. 字符编码模式(CES)。由一系列代码单元（code unit）组成的模式。例如 UTF-8、UTF-16 等等\n\n## 基本概念\n\n1. [Code point（0x0 - 0x10FFFF）][Code point]\n    - 表示法 `U+1FFFF`. （`U+` + 一个十六进制数）\n    - 一个代码点，是一个数字，代表一个字符。\n    - 同一个代码点在不同的编码格式中占用的空间大小有可能不同。比如，UTF-32 中所有代码点都是 4 个字节， UTF-8 中 代码点是可变长的 1-4 字节\n1. code unit\n\n    > Code unit: The minimal bit combination that can represent a unit of encoded text for processing or interchange.\n    - 在一个 CES 中，能表示一个字符的最小位组合数。UTF-8 为 8 bits，UTF-16 为 16 bits，UTF-32 为 32 bits。\n1. [UTF-32(UCS-4)][UTF-32]\n    - 固定 4 个字节（32 bits）长度， 不管是 [BMP][BMP]，还是 [SMP][SMP]，不足 4 字节使用前导 0 代替。\n1. UCS-2\n    - 固定 2 字节（16 bits）。只能表示 [BMP][BMP]\n1. [UTF-16][UTF-16]\n    - 前身为 UCS-2， 但其不能表示 [SMP][SMP]，为弥补该缺陷产生了 [UTF-16][UTF-16]。\n    - 2 或 4 字节（16 or 32 bits）。\n    - 构成：\n        1. `U+0000..U+D7FF && U+E000..U+FFFF` // 用来表示部分 [BMP][BMP] 字符\n        1. `U+D800..U+DFFF` // [surrogate pairs][Surrogates] 用来表示 [SMP][SMP]\n            - 2 个 2 字节\n            - `high surrogate`， 第一个 2 字节，范围为 `0xD800..0xDBFF.`\n            - `low surrogate`，第二个 2 字节，范围为 `U+DC00..U+DFFF`\n            - 计算方式（栗子： 0x10437）：\n                1. 减去 0x10000。 result = 0x00437, 二进制表示：0000 0000 0100 0011 0111。\n                1. 将结果分为高 10 bits 0x0001 和低 10 bits 0x0037\n                1. `high surrogate` = 0x0001 + 0xD800 = 0xD801\n                1. `low surrogate` = 0x0037 + 0xDC00 = 0xDC37\n                1. 所以 0x10437 的 UTF+16 表示 为 `0xD801DC37` \n            - ![](../res/surrogate-pairs-example.png)      \n    - 存储方式\n        - 因为是多字节存储的所以会有两种方式\n        - UTF-16BE // 大端法（默认）\n        - UTF-16LE // 小端法\n1. [UTF-8][UTF-8]\n\n    - 模式\n    ![](../res/utf-8.png)\n    - 例子\n    ![](../res/utf-8-example.png)\n\n1. [Byte order mark(BOM)][BOM]\n\n> The byte order mark (BOM) is a Unicode character, U+FEFF BYTE ORDER MARK (BOM), whose appearance as a magic number at the start of a text stream can signal several things to a program consuming the text:\n> - What byte order, or endianness, the text stream is stored in;\n> - The fact that the text stream is Unicode, to a high level of confidence;\n> - Which of several Unicode encodings that text stream is encoded as.\n> - -- from [Byte order mark(BOM)][BOM]\n\n- 尽量不用\n\n## 参考\n\n1. [Unicode Character Encoding Model -- unicode.org][Unicode Character Encoding Model -- unicode.org]\n1. [Code point][Code point]\n1. [代码点(Code Point)和代码单元(Code Unit)][代码点(Code Point)和代码单元(Code Unit)]\n1. [Plane][Plane]\n1. [Basic Multilingual Plane][BMP]\n1. [Supplementary Multilingual Plane][SMP]\n1. [UTF-32][UTF-32]\n1. [UTF-16][UTF-16]\n1. [What is a “surrogate pair” in Java? -- stackoverflow][What is a “surrogate pair” in Java? -- stackoverflow]\n1. [Surrogates][Surrogates]\n1. [UTF-8][UTF-8]\n1. [Byte order mark(BOM)][BOM]\n\n\n[Code point]:https://en.wikipedia.org/wiki/Code_point\n[Plane]:https://en.wikipedia.org/wiki/Plane_%28Unicode%29\n[UTF-8]:https://en.wikipedia.org/wiki/UTF-8\n[UTF-16]:https://en.wikipedia.org/wiki/UTF-16\n[UTF-32]:https://en.wikipedia.org/wiki/UTF-32\n[BMP]:https://en.wikipedia.org/wiki/Plane_(Unicode)#Basic_Multilingual_Plane\n[SMP]:https://en.wikipedia.org/wiki/Plane_(Unicode)#Supplementary_Multilingual_Plane\n[Surrogates]:https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\n[Unicode Character Encoding Model -- unicode.org]:http://unicode.org/reports/tr17/\n[代码点(Code Point)和代码单元(Code Unit)]:http://www.cnblogs.com/zhangzl419/archive/2013/05/21/3090601.html\n[What is a “surrogate pair” in Java? -- stackoverflow]:http://stackoverflow.com/questions/5903008/what-is-a-surrogate-pair-in-java\n[BOM]:https://en.wikipedia.org/wiki/Byte_order_mark\n','Unicode',1004,'2023-04-24 03:20:34'),(1005,'常见排序算法实现(Java)','# 常见排序算法实现(Java)\n\n![](../res/sorts.png)\n\n```java\npackage com.github.crainstorm.sort;\n\n\nimport java.util.Arrays;\nimport java.util.Random;\n\n/**\n * Created by chen on 4/14/17.\n */\npublic class Sort {\n    private static final int SIZE = 50;\n    private static int[] array = new int[SIZE];\n\n    public static void init() {\n        Random random = new Random();\n        for (int i = 0; i < SIZE; ++i) {\n            array[i] = random.nextInt(100);\n        }\n    }\n\n    private static void swap(int index1, int index2) {\n        int temp = array[index1];\n        array[index1] = array[index2];\n        array[index2] = temp;\n    }\n\n    /**\n     * 冒泡排序\n     * <p>\n     * 下标小于 i 的元素都是已排好序的，内层 for 循环使小元素一步一步交换到前面\n     * <p>\n     * <p>\n     * 时间复杂度：O(n^2)\n     * 空间复杂度：O(1)\n     *\n     * @param array\n     */\n    public static void bubbleSort(int[] array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"array can\'t be null\");\n        }\n        int len = array.length;\n        for (int i = 0; i < len; ++i) {\n            for (int j = len - 1; j > i; --j) {\n                if (array[j - 1] > array[j]) {\n                   swap(j-1,j);\n                }\n            }\n        }\n    }\n\n    /**\n     * 选择排序\n     * <p>\n     * 下标小于 i 的元素都是已排好序的，\n     * 内层 for 循环寻找 [i,len) 之间最小的元素，\n     * 然后将其与 下标为 i 的元素交换位置\n     * <p>\n     * 时间复杂度：O(n^2)\n     * 空间复杂度：O(1)\n     *\n     * @param array\n     */\n    public static void selectSort(int[] array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"array can\'t be null\");\n        }\n        int len = array.length;\n        for (int i = 0; i < len; ++i) {\n            int index = i;\n            for (int j = i + 1; j < len; ++j) {\n                if (array[index] > array[j]) {\n                    index = j;\n                }\n            }\n            if (index != i) {\n                swap(index, i);\n            }\n        }\n    }\n\n    /**\n     * 插入排序\n     * <p>\n     * 下标小于 i 的元素都是已排好序的，\n     * 内层 while 循环寻找元素 i 适合插入的位置，并将大于 array[i] 的元素后移\n     * <p>\n     * 时间复杂度：O(n^2)\n     * 空间复杂度：O(1)\n     *\n     * @param array\n     */\n    public static void insertSort(int[] array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"array can\'t be null\");\n        }\n        int len = array.length;\n        for (int i = 1; i < len; ++i) {\n            int j = i - 1;\n            int temp = array[i];\n            while (j > -1 && temp < array[j]) {\n                array[j + 1] = array[j];\n                --j;\n            }\n            array[j + 1] = temp;\n        }\n    }\n\n    /**\n     *\n     * 快排\n     *\n     * 选取最左侧的元素作为枢轴\n     *\n     * 时间复杂度：O(nlogn)\n     * 空间复杂度：O(logn)\n     *\n     * @param array\n     */\n    public static void quickSort(int[] array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"array can\'t be null\");\n        }\n\n        quickSort(array, 0, array.length - 1);\n    }\n\n    private static void quickSort(int[] array, int left, int right) {\n        if (left < right) {\n            int mid = partition(array, left, right);\n            quickSort(array, left, mid - 1);\n            quickSort(array, mid + 1, right);\n        }\n    }\n\n    /**\n     * 进行分区，返回枢轴所在下标。枢轴的左侧元素均比枢轴小，右侧元素均比枢轴大。\n     *\n     * @param array\n     * @param left\n     * @param right\n     * @return\n     */\n    private static int partition(int[] array, int left, int right) {\n        int leftIndex = left;    // 左游标\n        int rightIndex = right;  // 右游标\n        int pivot;               // 枢轴下标\n\n        int midVal = array[leftIndex];\n        leftIndex++;\n        while (true) {\n            while (leftIndex < rightIndex && midVal >= array[leftIndex]) {\n                ++leftIndex;\n            }\n            while (leftIndex < rightIndex && midVal <= array[rightIndex]) {\n                --rightIndex;\n            }\n\n            if (leftIndex < rightIndex) {\n                swap(leftIndex, rightIndex);\n            } else {\n                if (midVal > array[leftIndex]) {\n                    swap(left, leftIndex);\n                    pivot = leftIndex;\n                } else {\n                    swap(left, leftIndex - 1);\n                    pivot = leftIndex - 1;\n                }\n                break;\n            }\n        }\n        return pivot;\n    }\n\n\n\n    /**\n     * 归并排序\n     * <p>\n     * 使用递归的方式实现，比较简洁，已理解。\n     * <p>\n     * 时间复杂度：O(nlogn)\n     * 空间复杂度：O(n)\n     *\n     * @param array\n     */\n    public static void mergeSort(int[] array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"array can\'t be null\");\n        }\n        int[] temp = new int[SIZE];\n        mergeSort(array, temp, 0, array.length - 1);\n    }\n\n    private static void mergeSort(int[] array, int[] temp, int begin, int end) {\n        if (begin < end) {\n            int mid = (begin + end) / 2;\n//            System.out.print(\"begin: \" + begin + \" end: \" + end);\n//            System.out.println(\"     [\" + begin +\", \" + mid + \"], [\" + (mid+1) +\",\" + end + \"]\");\n            mergeSort(array, temp, begin, mid);\n            mergeSort(array, temp, mid + 1, end);\n            merge(array, temp, begin, mid, end);\n        }\n    }\n\n    /**\n     *\n     * 合并两个已排好序的数列，两个数列所在范围是 [begin, mid], [mid+1, end]\n     *\n     * @param array\n     * @param temp\n     * @param begin\n     * @param mid\n     * @param end\n     */\n    private static void merge(int[] array, int[] temp, int begin, int mid, int end) {\n        int i = begin;\n        int j = mid + 1;\n        int k = begin;\n        while (i <= mid && j <= end) {\n            if (array[i] <= array[j]) {\n                temp[k++] = array[i++];\n            } else {\n                temp[k++] = array[j++];\n            }\n        }\n        while (j <= end) {\n            temp[k++] = array[j++];\n        }\n        while (i <= mid) {\n            temp[k++] = array[i++];\n        }\n        for (i = begin; i <= end; ++i) {\n            array[i] = temp[i];\n        }\n//        System.out.println(Arrays.toString(array));\n    }\n\n    /**\n     * 堆排序\n     * <p>\n     * 基本思路：\n     * 1. 构造最大堆\n     * 2. 将 array[0] 与 array[length-1] 交换，并将新的 array[0] 下沉恢复 [0,length-1) 的最大堆...一直到 恢复 [0,1) 的最大堆\n     *\n     * @param array\n     */\n    public static void heapSort(int[] array) {\n        if (array == null) {\n            throw new IllegalArgumentException(\"array can\'t be null\");\n        }\n        // 构造最大堆\n        // [array.length/2 , array.length-1] 的元素都是叶子节点，不需要下沉\n        for (int i = array.length / 2 - 1, end = array.length - 1; i >= 0; --i) {\n            down(array, i, end);\n        }\n\n        // 堆排序\n        for (int end = array.length - 1; end > 0; ) {\n            swap(0, end--);\n            down(array, 0, end);\n        }\n    }\n\n    /**\n     *\n     * 将数组中下标为 root 的元素进行下沉，终结下标为 end(包含 end)\n     *\n     * @param array\n     * @param root\n     * @param end\n     */\n    private static void down(int[] array, int root, int end) {\n        int leaf = 2 * root + 1;\n        while (leaf <= end) {\n            if (leaf + 1 <= end && array[leaf] < array[leaf + 1]) {\n                leaf++;\n            }\n            if (array[root] > array[leaf]) {\n                break;\n            }\n            swap(root, leaf);\n            root = leaf;\n            leaf = 2 * root + 1;\n        }\n    }\n\n\n    public static void main(String[] args) {\n//        System.out.println(-1 / 2);\n        init();\n        System.out.println(Arrays.toString(array));\n//        bubbleSort(array);\n//        selectSort(array);\n//        insertSort(array);\n        quickSort(array);\n//        mergeSort(array);\n//        heapSort(array);\n        System.out.println(Arrays.toString(array));\n    }\n}\n\n```\n\n## 参考\n\n1. [各种排序算法总结](http://www.jianshu.com/p/f5baf7f27a7e)\n','排序算法',1005,'2023-05-12 23:21:06'),(1006,'LeetCode 148. Sort List','# LeetCode 148. Sort List\n\n\n今天做美图的笔试题，要求是用快排给单链表排序。虽然这不是最优的排序方式，但既然要求了还是写一写。\n\n---\n\n算法思路：\n\n单链表排序与数组排序思路是一样的，只是两个游标的移动方式不同。\n\n单链表排序的两个游标向同一方向移动，p、q 代指两个游标， p 左侧的都是比枢轴小的，p 到 q 是比枢轴大的，q 右侧的是还未排序的\n\n\n```java\n    private static void quickSort(Node head, Node tail) {\n        if (head != tail && head.next != tail) {\n            // 至少含有两个元素才排序\n            Node pivot = partition(head, tail);\n            quickSort(head, pivot);\n            quickSort(pivot.next, tail);\n        }\n    }\n\n\n    private static Node partition(Node head, Node tail) {\n        Node cur = head.next; // 游标 q\n        Node mid = head.next; // 游标 p\n        Node midPrev = head;\n        Node pivot = null;\n        int pivotVal = head.val;\n\n        do {\n            while (mid.next != tail && mid.val <= pivotVal) {\n                // 找到下一个比枢轴大的元素\n                midPrev = mid;\n                mid = mid.next;\n            }\n            if (cur == head.next) {\n                // q 游标第一次移动前的初始化，保证 q 在 p 右侧\n                cur = mid;\n            }\n            while (cur.next != tail && cur.val > pivotVal) {\n                // 找到下一个比枢轴小的元素\n                cur = cur.next;\n            }\n            if (cur.next != tail && mid.next != tail) {\n                // 如果两个游标都未到结尾\n                swap(cur, mid);\n            } else {\n                if (cur.next == tail && cur.val < pivotVal) {\n                    // 如果 q 游标到结尾了并且该节点的值小于枢轴\n                    swap(mid, cur);\n                }\n\n                // 将枢轴交换到中间，保证左侧都小于枢轴，右侧都大于枢轴\n                if (mid.val < pivotVal) {\n                    swap(mid, head);\n                    pivot = mid;\n                } else {\n                    swap(midPrev, head);\n                    pivot = midPrev;\n                }\n            }\n            cur = cur.next;\n            midPrev = mid;\n            mid = mid.next;\n        } while (cur != tail && mid != tail);\n\n        return pivot;\n    }\n\n    static void swap(Node node1, Node node2) {\n        int temp = node1.val;\n        node1.val = node2.val;\n        node2.val = temp;\n    }\n\nclass Node {\n    public int val;\n    public Node next;\n\n    public Node(int data) {\n        this.val = data;\n    }\n}\n```\n\n\n## 参考\n\n1. [单链表的快速排序 ](http://blog.csdn.net/wumuzi520/article/details/8078322)\n','算法',1006,'2023-04-20 11:21:31'),(1007,'阿里一面总结','# 阿里一面总结\n\n一面大概 1 个小时（思考怎么回答 + 说废话的时间稍微长一点 -_-）,面试官是阿里技术部的。\n\n面试评价：\n1. 技术不错，如果后面的面试通过的话会有我的同事联系你；\n1. 几点不足：\n    1. 回答问题时不要有多余的字符，现在大概一个小时了，一般来说是不需要这么长时间的。\n    1. 回答时不要拓展太多，不然如果深入问的话问不出来东西，会有些影响。\n    1. 问到的问题不清楚的话不要猜，直接说明即可，不然会把面试引到错误的方向\n\n\n面试没有自我介绍，直入正题谈项目。以下是面试过程中问到的问题（尽量回忆吧，因为有点激动有些问题可能会漏掉）\n\n面试题基本都是基础，不涉及 GC ，不涉及分布式等。\n\n---\n\n1. 谈谈你印象最深的一个项目。\n1. JSP 和 Servlet 有什么区别？\n1. 既然 JSP 会转换成 Servlet， 那为什么要多这一步？直接用 Servlet 不行吗？\n    - JSP 由 HTML 代码和 JSP 标签构成，可以方便地编写动态网页,Servlet 完全是 JAVA 程序代码构成擅长于流程控制和事务处理.因此在实际应用中采用 Servlet 来控制业务流程,而采用 JSP 来生成动态网页.\n1. 每一个 request 对应的 Servlet 是直接 new 出来还是只是用同一个？\n    - 如果 request 请求的 Servlet 相同的话不用再 new，如果不同的话需要 new 一个新的。\n1. Session 相关的问题问了几个有点乱不太能想起来，这个问题是由之前的回答里面提到 Session 引出来的。\n1. Java 集合框架的源码有没有看过？\n1. `ArrayList` 和 `linkedList` 底层是怎么实现的？各自的特点是什么？\n1. `HashMap` 有没有看过？他是怎么实现的？\n1. `HashMap` 是不是线程安全的？\n1. 如果我想要用线程安全的 `HashMap` 应该怎么做？\n    1. 使用 Wrapper，进行一下封装。\n    1. 使用 `Sychronized` 关键字锁定 `HashMap` 对象。\n1. `voliate` 有没有用过？他的原理是什么？\n1. 把 `bean` 交给 Spring 管理跟之前直接 `new` 的方式相比有什么好处？\n    -  因为把对象生成放在了XML里定义，所以当我们需要换一个实现子类将会变成很简单（一般这样的对象都是现实于某种接口的），只要修改XML就可以了，这样我们甚至可以实现对象的热插拨（有点象USB接口和SCIS硬盘了）。\n    - 不需要了解实现类的创建方法。普通的 new 的方式需要你清楚的了解实现类的构造，如果在 new 的时候该实现类又又依赖了其他实现类，那需要学习的类就相对比较多了。`bean` 交给 Spring 管理就不需要考虑这些东西，只需要直接获取即可。\n1. 编写完配置文件以后我们就可以直接使用 `bean` 了， Spring 是如何做到的？\n    - 首先扫描配置文件，将 `bean` 放入 IOC 容器中，当使用的时候直接从 IOC 中取就可以了。\n1. 配置文件扫描 Spring 是如何做到的？\n    1. 使用专门处理 XML 的库。\n1. 你知道 Spring 处理 XML 用的是什么库吗？\n    - `org.xml.sax`\n1. 你用过处理 XML 的库吗？\n    - 处理 XML 的库我目前知道的有两种，一种是 java 语言自带的库，另一种是 `JDOM`，我在之前的一个系统中使用过 `JDOM` 来处理连接数据库的配置文件。\n1. Spring 是如何获取对象的？\n    - 如果是单例模式的话，这个对象是在 Spring 配置文件扫描以后就直接建立好的，存放在 Map 中，用的时候直接从 Map 中获取。\n    - 如果不是单例模式，反射调用构造器来 new 一个对象；\n1. 处了简历上提到的框架之外有没有用过其他的框架？他们之间有什么不同？\n1. 使用 Mybatis 与直接使用 JDBC 的方式相比有什么好处？\n    1. 最直观的感受就是代码量减少了很多。使用 JDBC 的话需要检查参数，注入参数，从记录转成 Java 对象，使用 Mybatis 的话这些都不用做了，就写一个接口然后在配置文件中写 SQL 即可。\n    1. 第二点就是 JDBC 中的事务需要手动处理，而使用 Mybatis 的话他会自动就帮你做了。\n1. 你知道 Mybatis 的事务是由什么框架实现的吗？\n    1. Mybatis封装了 `JDBC`，一般情况下事务是由 `JDBC` 来做的。\n1. 项目中有没有使用连接池，连接池的原理是什么？\n1. 什么样的数据库设计是符合要求的（从范式的角度）？\n    - 理论上说达到第三范式是符合要求的但是一般生产环境下为了数据查询方便，数据会有一定的冗余，也就是说一般达到第二范式即可。\n    1. 第一范式：字段不可分\n    1. 第二范式：非主属性必须完全函数依赖于码，即如果码的子集能唯一确定一个非主属性的话，那该表就不符合第二范式。\n    1. 第三范式：消除了第二范式中的传递函数依赖\n1. 给你一个 SQL, 你的同事说这个 SQL 的效率有点低，你会怎么优化？\n    1. 首先考虑 SQL 本身是否能够优化，如果是多张表直接连接的话那是肯定能够优化的，我们可以把每张表的符合要求的数据通过 `where` 子句查询出来，然后进行连接。\n    1. 如果是单张表的话 SQL 方面我暂时想不到什么优化的方法，如果要提高效率的话只能通过向表中添加索引的方式来优化。\n1. 为什么添加索引能优化查询？\n1. 既然索引能优化查询，那我多添加几个索引可不可以？为什么？\n1. 如果多个字段设为一个索引 a，b，c，查询的时候只使用 a，b 来查询这样可以吗？\n    - 对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .\n1. 连接池中的连接是长连接还是短连接？为什么？\n1. 连接池中的连接是基于什么协议的连接？为什么？\n1. 怎样建立 TCP 连接，怎样断开 TCP 连接？\n1. 为什么要三次握手，为什么要四次挥手？\n    - 如过是两次握手，那么现在有一种情况，客户端向服务器发送了一个 syn 包，但因为网络的原因阻塞在了某一个网络节点，经过一段时间客户端没有收到 syn ack 的包，他肯定是会重传的，之后的过程比较顺利连接成功，数据传输完成并断开后，客户端向服务器端发送的第一个 syn 包到达了服务器，然后服务器发送一个 syn ack 的包，因为这个时候客户端是没有等待这个包的，即使收到了也不会作回应，这是两次握手，那这两次握手后服务器端的资源是释放还是不释放？这是一个问题。\n    - 四次挥手是因为 TCP 是全双工的，两端能同时向对方发送数据，如果不足四次的话无法确定双方都没有数据发送了。\n1. 最近在看什么书？有没有学一些新技术？\n\n## 参考\n\n1. [《深入理解mybatis原理》MyBatis事务管理机制](http://blog.csdn.net/luanlouis/article/details/37992171)\n1. [解释一下关系数据库的第一第二第三范式？](https://www.zhihu.com/question/24696366)\n1. [MySQL 联合索引详解](http://blog.csdn.net/lmh12506/article/details/8879916)\n1. [为什么“三次握手，四次挥手”？](http://www.cnblogs.com/SeaSky0606/p/4741982.html)\n','面试',1007,'2023-05-10 10:22:00'),(1008,'阿里二面准备(Java 研发)','# 阿里二面准备(Java 研发)\n\n感觉有机会进行二面（原谅我没来由的自信，～～），准备一下。参考了牛客网上 30 多个面经帖，这是目前我能找到的几乎所有的问题。私以为如果能全部掌握，基本就能收割 offer 了。时间有限的话，针对自己的情况优先选最有可能被问到的问题来准备。\n\n有少部分内容我直接忽略了，可以参考 `interview/` 目录下之前做的总结。\n\n**注意：因为我并没有系统的学习多线程编程，所以并发相关的问题我只是大概了解一下，目前并不深入讨论(面试时直接说明即可)**\n\n## 数据结构\n\n1. HashMap的原理，内部数据结构？\n    - 底层使用哈希表（数组 + 链表），当链表过长会将链表转成 红黑树以实现 O(logn) 时间复杂度内查找\n1. 讲一下 HashMap 中 put 方法过程？\n    1. 对 Key 求 Hash 值，然后再计算 下标。\n    1. 如果没有碰撞，直接放入桶中，\n    1. 如果碰撞了，以链表的方式链接到后面，\n    1. 如果链表长度超过阀值（TREEIFY_THRESHOLD == 8），就把链表转成红黑树。\n    1. 如果节点已经存在就替换旧值\n    1. 如果桶满了（容量 * 加载因子），就需要 resize。\n1. HashMap 中 hash 函数怎么是是实现的？ 还有哪些 hash 的实现方式？\n    1. 高 16bit 不变，低 16bit 和高 16bit 做了一个异或\n    1. （n - 1） & hash --> 得到下标\n    1. 还有哪些 Hash 实现方式：可以参考之前的博客 [Effective Java 学习笔记 -- hashCode()](../reading-notes/Effective-Java.md)\n1. HashMap 怎样解决冲突，讲一下扩容过程，假如一个值在原数组中，现在移动了新数组，位置肯定改变了，那是什么定位到在这个值新数组中的位置，\n    - 将新节点加到链表后，\n    - 容量扩充为原来的两倍，然后对每个节点重新计算哈希值。\n    - 这个值只可能在两个地方，一个是原下标的位置，另一种是在下标为 <原下标+原容量> 的位置。\n1. 抛开 HashMap，hash 冲突有那些解决办法？\n    - 开放定址，链地址法\n1. 针对 HashMap 中某个 Entry 链太长，查找的时间复杂度可能达到 O(n)，怎么优化？\n    - 将链表转为红黑树， JDK1.8 已经实现了。\n1. 数组和 ArrayList 的区别；\n    1. 数组可以包含基本类型和对象类型，ArrayList 只能包含对象类型\n    1. 数组大小固定，ArrayList 大小可以动态变化\n    1. ArrayList 提供了更多的特性（`addAll`、`removeAll`）。\n1. Arraylist 如何实现排序\n    - `Collections.sort(List<T> list)`;\n    - `sort(List<T> list, Comparator<? super T> c)`;\n1. HashMap\n    1. 数组 + 链表方式存储\n    1. 默认容量： 16(2^n 为宜,若定义的初始容量不是 2^n，容量会定义为大于该初始容量的最小 2^n)\n        - 例如：初始容量为 13，则真正的容量是 16.\n    1. put:\n        1. 索引计算 : ((key.hashCode() ^ (key.hashCode() >>> 16)) & (table.length - 1))\n        1. 在链表中查找，并记录链表长度，若链表长度达到了 TREEIFY_THRESHOLD(8)，则将该链转成红黑树。\n        1. 若在链表中找到了，则替换旧值，若未找到则继续\n        1. 当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列\n            - (元素的下标要么不变，要么变为【原下标+原容量】)。\n        1. 将新元素加到链表尾部\n        1. 线程不安全\n1. HashTable\n    1. 数组 + 链表方式存储\n    1. 默认容量： 11(质数 为宜)\n    1. put:\n        1. 索引计算 : （key.hashCode() & 0x7FFFFFFF）% table.length\n        1. 若在链表中找到了，则替换旧值，若未找到则继续\n        1. 当总元素个数超过容量*加载因子时，扩容为原来 2 倍并重新散列。\n        1. 将新元素加到链表头部\n    1. 对修改 Hashtable 内部共享数据的方法添加了 synchronized，保证线程安全。\n1. HashMap ，HashTable 区别\n    1. 默认容量不同。\n    2. 索引计算方式不同。\n    3. HashMap 特有的将过长链表转换为红黑树。\n    4. 新元素的位置不同。\n    5. 线程安全性\n1. HashMap、ConcurrentHashMap 区别。\n    1. 索引计算消除了最高位的影响\n    1. 默认容量： 16(若定义了初始容量(c)，容量会定义为大于(c + (c >>> 1) +1) 的最小 2^n)\n        - 例如：初始容量为 13，则真正的容量是 32.\n    1. 线程安全，并发性能较好\n        - 并发性能好的原因是 ConcurrentHashMap 并不是定义 synchronized 方法，而是在链表头上同步，不同的链表之间是互不影响的。\n1. ConcurrentHashMap 原理\n    1. 最大特点是引入了 CAS（借助 Unsafe 来实现【native code】）\n        1. CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。\n        1. Unsafe 借助 CPU 指令 cmpxchg 来实现\n        1. 使用实例：\n            1. 对 sizeCtl 的控制都是用 CAS 来实现的\n            >1. sizeCtl ：默认为0，用来控制 table 的初始化和扩容操作。\n            >    - -1 代表table正在初始化\n            >    - N 表示有 -N-1 个线程正在进行扩容操作\n            >    - 如果table未初始化，表示table需要初始化的大小。\n            >    - 如果table初始化完成，表示table的容量，默认是table大小的0.75倍，居然用这个公式算0.75（n - (n >>> 2)）。\n        1. CAS 会出现的问题：ABA\n            - 对变量增加一个版本号，每次修改，版本号加 1，比较的时候比较版本号。\n1. TreeMap 和 TreeSet 区别和实现原理\n    - `TreeSet` 底层是 `TreeMap`，`TreeMap` 是基于红黑树来实现的。\n1. 如果想实现一个线程安全的队列，可以怎么实现？\n1. 知道 LRU 吗，20分钟基于 HashMap 实现一个 LRU 算法，面试官给个地址，进去写代码，面试官远程看\n    - [如何设计实现一个LRU Cache？](http://yikun.github.io/2015/04/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU-Cache%EF%BC%9F/)\n1. 二叉树的遍历方式，前序、中序、后序和层序\n    - 可以再写一篇了。。\n1. 常见的排序算法时间复杂度（排序算法实现也要重点掌握）\n    - [常见排序算法实现(Java)](../reading-notes/常见排序算法实现.md)\n1. 红黑树的特点及相比平衡二叉树的优点（先介绍各自特点）？\n    - 红黑树\n        1. 每个节点要么是红色，要么是黑色。\n        1. 根节点永远是黑色的。\n        1. 所有的叶节点都是空节点（即 null），并且是黑色的。\n        1. 每个红色节点的两个子节点都是黑色。（从每个叶子到根的路径上不会有两个连续的红色节点）\n        1. 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点。\n    - 平衡二叉树\n        1. 任何节点的两个儿子子树的高度最大差别为一\n    - 红黑树并不追求“完全平衡”——它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。\n1. B+树的了解\n    - 多分支结构有效降低了树的高度\n    - B 树的各种操作能使 B 树保持较低的高度，从而达到有效避免磁盘过于频繁的查找存取操作，从而有效提高查找效率\n1. Trie-Tree 原理及其应用；\n    - 字典树\n    - 特点\n        1. 根节点不包含字符，除根节点外的每一个子节点都包含一个字符。\n        1. 从根节点到某一个节点，路径上经过的字符连接起来，为该节点对应的字符串。\n        1. 每个节点的所有子节点包含的字符互不相同。\n    - 核心思想是空间换时间\n    - 应用\n        1. 字符串检索\n        1. 词频统计\n\n## 算法题（剑指 Offer 上原题不少）\n\n1. 怎么查询一个单向链表的倒数第五个节点\n1. 判断链表是否成环\n1. 两条相交的单向链表，如何求他们的第一个公共节点\n1. 在无序数组中找最大的K个数?\n1. 给定n个数，寻找第k小的数，同时给出时间复杂度\n1. 找一个数组中的第三大数\n1. 找出数组中第一个出现2次的数，\n1. 求 1-N 中数字 1 的个数。\n1. 判断一个数是不是丑数；\n1. 求第 K 个丑数；\n1. 10w行数据，每行一个单词，统计出现次数出现最多的前100个。\n1. 一个文本文件，给你一个单词，判断单词是否出现。\n1. 一进去要求敲代码二叉排序树的插入、删除及查找\n1. 某海量用户网站，用户拥有积分，积分可能会在使用过程中随时更新。现在要为该网站设计一种算法，在每次用户登录时显示其当前积分排名。用户最大规模为2 亿；积分为非负整数，且小于 100 万；\n1. 判断一棵二叉树是否是 BST。\n1. 一副扑克 54 张牌，现在分成 3 份，每份 18 张，问大小王出现在同一份中的概率是多少；\n1. 50个白球50个红球，两个盒子，怎么放让人随机在一个盒子里抽到红球概率最高。。。这个就是一个盒子放一个红球，另一个盒子放99个球。\n1. logN 查找一个有序数组移动后类似 4 5 6 7 1 2 3里面的一个数\n1. 0 ~ n 连续 n + 1 数，现在有一个长度为 n 的数组存放了上面 n + 1 个数的其中 n 个，找出哪一个数没有被放进数组\n1. 将M个平均长度为N的有序队列组合成一个有序队列\n1. 10亿条短信，找出前一万条重复率高的\n1. 对一万条数据排序，你认为最好的方式是什么\n1. 假如有100万个玩家，需要对这100W个玩家的积分中前100名的积分，按照顺序显示在网站中，要求是实时更新的。积分可能由做的任务和获得的金钱决定。问如何对着100万个玩家前100名的积分进行实时更新？\n    - 除了前100名，后100W-100名玩家的积分，让变化的积分跟第100名比较，如果比第100名高，那就替换的原则。\n\n## Java 基础\n\n1. Java 的优势\n    - 语法简单\n    - 跨平台\n    - 当开发规模膨胀到一定程度，Java在规范、协作和性能调优上还是占有很大优势,在大型应用，尤其是企业应用上，Java的地位仍然难以撼动\n1. boolean 占几个字节\n    1. 如果 boolean 变量在栈上，那么它占用一个栈单元（32-bits）\n    1. 如果在堆上，那么就跟 JVM 的实现有关了\n    1. 在 Oracle 的 JVM 实现，boolean[] 中每个元素占用一个字节（8-bits）\n1. Java 访问修饰符权限的区别；\n    - `public` 所有类都可访问\n    - `protected` 只允许包内、子类访问。\n    - `默认` 只允许包内访问\n    - `private` 只允许类内访问\n1. String 是否可以继承， “+” 怎样实现?\n    - `String` 是 `final` 类，不可继承。\n    - `+` 是通过 `StringBuilder`（或 `StringBuffer`） 类，和 `append` 方法实现\n1. String，StringBuffer，StringBuilder，区别，项目中那里用到了 StringBuffer 或者 StringBuilder\n    - `String` 不可变\n    - `StringBuffer`，可变，线程安全\n    - `Stringbuilder`，可变，线程不安全\n1. String为啥不可变，在内存中的具体形态？\n    - `String` 使用 `final char value[]` 来存放字符序列。\n1. Comparable 接口和 Comparator 接口实现比较\n    - Comparable 是直接在\"被比较\"的类内部来实现的\n    - Comparator则是在被比较的类外部实现的\n1. Arrays 静态类如何实现排序的？\n    - 双轴快排\n    1. 首先检查数组长度，如果比阀值（286）小，直接使用双轴快排\n    1. 否则先检查数组中数据的连续性，标记连续升序，反转连续降序，如果连续性好，使用 TimSort 算法（可以很好的利用数列中的原始顺序）\n    1. 否则使用双轴快排 + 成对插入排序\n1. Java 中异常机制。\n    - Java 中所有异常都是 `Throwable` 的子类，他的直接子类有两个，一个是 `Error`, 一个是 `Exception`。\n        - `Error` 一般表示 JVM 出现了严重问题，比如说栈溢出或 OOM,\n        - `Exception` 中异常分为两类，\n            - 一类是 `RuntimeException` 表示运行期间出现的错误，比较常见的是空指针异常和数组下标越界，出现这种异常一般是程序出现了逻辑错误，也就是代码有 Bug。\n            - 另一类是编译时异常（除了 `RuntimeException` 以外的异常），常见的一般有 `IOException`等， 出现这种错误程序编译会不通过。\n    - 还有一种分类方式是 `checked exception` 和 `uncheck exception`。`unchecked exception` 包括 `Error` 和 `RuntimeExcetion`，`checked exception` 指之前所说的编译时异常。\n1. Java 中异常怎么处理，什么时候抛出，什么时候捕获；\n    - 一般原则是提早抛出，延迟捕获\n    - 出现异常时，若当前无法处理则抛，否则捕获异常，尝试恢复。\n1. 说一说对 java io 的理解\n    - 按照使用的 IO 模型，大致可以分为三类:\n        - BIO：JDK1.4 之前的阻塞 IO\n        - NIO：JDK1.4 及以后的版本,非阻塞 IO\n        - AIO：JDK1.7 之后，又叫 NIO.2,异步 IO\n        - IO 总的来说分为两个阶段，第一阶段是等待数据到达内核缓冲区，第二阶段是将数据从内核缓冲区复制到用户缓冲区。\n            - 阻塞 IO 是两个阶段都保持阻塞状态。\n            - 非阻塞 IO 第一个阶段不阻塞，但是需要轮询来查看第一阶段是否完成，完成以后进行第二阶段，第二阶段也是需要阻塞的。\n            - IO 复用使用 select/poll，阻塞在这两个系统调用上，而不是真正的 IO 操作上，这种方式的优势是可以同时监听多个文件描述符。检查文件描述符是否就绪的工作是由 select/poll 系统调用来负责的。Java 的 NIO 组合使用了 IO 复用 + 非阻塞 IO 两种 IO 模型。不过 Linux 版的 JDK 底层使用的系统调用是 epoll，它使用的模型类似与信号驱动式 IO 模型，当 IO 就绪时会受到消息不需要自己去做轮询工作所以，效率相比 select/poll 会好上很多。但是 epoll 的缺点是可移植性较差，是 Linux 平台专有的系统调用，select/poll 就比较通用了。\n            - 信号驱动式 IO 在第一阶段完成后发送信号，该阶段不阻塞，不轮询，然后阻塞进行第二阶段。\n            - 异步 IO 在两个阶段都完成以后才发送信号，数据是直接可用的。\n    - 按照 IO 的对象，可以分为 4 类。分别是：\n        1. 基于字节操作的 I/O 接口：InputStream 和 OutputStream\n        1. 基于字符操作的 I/O 接口：Writer 和 Reader\n        1. 基于磁盘操作的 I/O 接口：File\n        1. 基于网络操作的 I/O 接口：Socket\n1. 知不知道 NIO\n    - 三个特点：\n        1. Channels and Buffers // 通过 Channels 访问 Buffers， 一个Channel 代表一个文件描述符\n        1. Non-blocking IO      // 非阻塞 IO\n        1. Selectors            // 单线程，监控 nultiple Channels\n1. Java 锁机制\n1. 重入锁、对象锁、类锁的关系\n1. 哪些方法实现线程安全？    \n    - synchronized，volatile，然后重点说了下 volatile 在某些情况下可以实现线程安全，然后就把面试官注意力往 volatile 上引，因为volatile 这个专门看了一下，果然，面试官马上问了 volatile。\n1. Java 中的同步机制，synchronized 关键字，锁（重入锁）机制，其他解决同步的方 volatile 关键字 ThreadLocal 类的实现原理要懂。\n1. Synchronized 和 lock 区别\n1. 锁的优化策略\n    - 读写分离\n    - 分段加锁\n    - 减少锁持有的时间\n    - 多个线程尽量以相同的顺序去获取资源\n1. Java线程阻塞调用 wait 函数和 sleep 区别和联系，还有函数 yield，notify 等的作用。\n    - `sleep` 时线程的方法（让出 CPU），`wait` 是对象的方法。\n1. 谈谈的 Java 反射的理解，怎么通过反射访问某各类的私有属性\n    - 通过反射，我们可以获取类的运行时内部结构。\n    - 反射 API 中有个方法 `getDeclaredFields()`\n1. 动态代理的原理\n    - 动态代理基于反射实现，调用者通过代理对象来访问方法的时候，代理对象可以做相应的处理，然后通过反射调用被代理对象的方法。\n1. 项目中都是用的框架，用过 Servlet 吗？ Servlet 是单例吗？多线程下 Servlet 怎么保证数据安全的？Servlet 的生命周期？\n    - 一般是单例，我们用的都是 Servlet 的 service，其中一般不包含实例变量，只有共享代码，所以一般是安全的，如果有实例变量的话可以使用 synchronized 关键字进行加锁。当 Servlet 实现 SingleThreadModel 接口后，Tomcat 会为该 Servlet建一个对象池，这是享元模式。\n    - 生命周期\n        1. `init` 一般在 web 容器初始化，或第一次调用 servlet 时。\n        1. `service` 提供服务\n        1. `destroy` 终结\n        1. 回收\n1. Thread 状态有哪些\n    - ![](../res/java-thread-state.png)\n1. Java实现线程的方式；哪种好；为什么好\n1. 单例模式的生命周期\n    - 一般来说单例模式创建的对象是由类的 static 变量引用着的，JVM 如果采用可达性分析算法来回收的话，该对象是永远不可能被回收的（从创建以后）。\n1. 继承和多态的区别；\n1. Java8 的新特性。\n\n## Java 高级\n\n1. GC 算法，除了常见的复制算法，标记整理，标记清除算法，还有哪些？\n    - 增量算法。主要思想是垃圾收集线程与用户线程交替执行。也可以说一边执行垃圾回收一遍执行用户代码。但是这种方法会造成系统吞吐量下降。\n    - 分代收集。这种方法没有使用新算法，只是根据对象的特点将堆分为年轻代和老年代，年轻代使用复制算法，老年代使用标记整理算法。\n1. 垃圾收集器\n    - ![gc collectors](../res/gc-collectors.jpg)\n\n    -   |收集器|收集算法|收集区域|线程|停顿|特点|\n        |:---:|:---:|:---:|:---:|:---:|:---:|\n        |serial|复制算法|新生代|单线程|收集时必须停顿其他所有工作线程|简单高效|\n        |serial old|标记整理|老年代|单线程|收集时必须停顿其他所有工作线程||\n        |PerNew|复制算法|新生代|多线程|serial 的多线程版本|Server 模式下首选|\n        |parallel Scavenge|复制算法|新生代|多线程|收集时必须停顿其他所有工作线程|注重吞吐量，适合后台计算多|\n        |parallel old|标记整理|老年代|多线程|收集时必须停顿其他所有工作线程|同 parallel Scavenge|\n\n    - 收集器搭配推荐\n        1. parallel Scavenge + parallel old  //注重吞吐量的应用\n        1. CMS + PerNew //注重停顿时间的应用，强交互环境\n        1. G1           // 未来替代 CMS + PerNew\n    1. CMS（concurrent mark sweep）并发收集、低停顿\n        - ![](../res/jvm-cms-model.png)\n        1. 初始标记（CMS initial mark）：仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，需要“Stop The World”。\n        1. 并发标记（CMS concurrent mark）：进行GC Roots Tracing的过程，在整个过程中耗时最长。\n        1. 重新标记（CMS remark）：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。此阶段也需要“Stop The World”。\n        1. 并发清除（CMS concurrent sweep）\n    1. G1\n        - 将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，而都是一部分Region（不需要连续）的集合。\n        - 整体使用标记整理，局部使用复制算法。\n        - ![](../res/jvm-g1-model.png)\n        1. 初始标记（Initial Marking） 仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程，但耗时很短。\n        1. 并发标记（Concurrent Marking） 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。\n        1. 最终标记（Final Marking） 为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中，这阶段需要停顿线程，但是可并行执行。\n        1. 筛选回收（Live Data Counting and Evacuation） 首先对各个Region中的回收价值和成本进行排序，根据用户所期望的GC 停顿是时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。\n    1. G1 vs CMS\n        1. 我们选择哪个收集器是由我们垃圾回收的目标来决定的，主要考虑以下几点：\n            1. 吞吐量\n            1. 停顿时间\n            1. 堆容量\n        1. G1 vs CMS\n            - G1 基本不用配置，低停顿，用于大容量的堆。但是他牺牲了应用程序的吞吐量和部分堆空间。\n            - CMS 配置比较复杂，合理的低停顿，用于中等或更小的堆。\n            - 所以当你觉得配置 CMS 太难了，或你的堆在 2 G 以上，或你想要显式的指定停顿时间那么你可以使用 G1。否则使用 CMS\n1. Java 内存模型\n    - [深入理解 Java 虚拟机](../reading-notes/深入理解Java虚拟机.md)\n1. 问 JVM 内存分代机制（会问分为那几个代，各个代特点），分代回收的优点（这个问了很多次）。\n    - 分为年轻代和老年代，年轻代中的对象生命周期短，基本是朝生夕死，所以需要频繁的回收；老年代中的对象一般都能熬过多次 GC 所以他们不需要频繁回收。分代收集利用了这种特点，年轻代使用复制算法，老年代使用标记整理算法，所以总的来说分代收集的效率相对还是不错的。\n1. Java 虚拟机类加载机制，双亲委派模型\n    - [深入理解 Java 虚拟机](../reading-notes/深入理解Java虚拟机.md)\n1. minor GC 和 Full GC 的触发时机\n    - minor GC: 当 eden 区满以后会触发。\n    - Full GC：\n        1. JVM 的一些特性比如分配担保，大对象直接进入老年代，长期存活的对象进入老年代等等都会不断增加老年代的使用率，当老年代空间不足以支持下一次 Minor GC 时会触发一次 Full GC\n        1. 当用户代码调用 System.gc 时，系统系统建议执行 Full GC，但是否进行是由 JVM 来决定的。\n1. JVM 中什么样的对象是可以回收的，对象从新年代到老年代的转移过程，JVM 哪些地方会溢出（除了程序计数器都有）\n    1. GC roots 不可达的对象是可以回收的。\n        - 栈中的引用的对象\n        - 方法区常量引用的对象\n        - 方法区静态域引用的对象\n        - JNI 引用的对象\n    1. 转移过程\n        - 当对象熬过一定次数的 GC 后，会被转移到老年代\n        - 当 Eden + From surviver 中存活对象过多，To surviver 区存放不下的时候，剩余的对象会进入老年代\n1. Java虚拟机的一些参数配置\n    - [深入理解 Java 虚拟机](../reading-notes/深入理解Java虚拟机.md)\n1. 什么情况会栈溢出\n    - 如果线程请求的栈容量超过栈允许的最大容量的话，Java 虚拟机将抛出一个 StackOverflow 异常\n1. JDK1.8 中 JVM 做了那些改变\n    - 主要是撤销了永久代，引入元空间（本地内存）\n1. 常用 JVM 调优工具有哪些（Jstatus，JStack，Jmap等），有没有调有经验.\n1. 知道 OOM 吗，举一个 OOM 的例子\n    - 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；\n    - 启动参数内存值设定的过小；\n1. 介绍一下 Java 的强软弱虚四种引用，问什么时候使用软引用\n    - 一般 `new` 出来的对象都是强引用，GC 不会回收强引用的对象\n    - 软引用：软引用的对象不那么重要，当内存不足时可以被回收。非常适合于创建缓存。\n    - 弱引用：只是引用一个对象，若一个对象的所有引用都是弱引用的话，下次 GC 会回收该对象。一般用在集合类中，特别是哈希表。\n    - 虚引用：一般用于对实现比较精细的内存使用控制。对于移动设备来说比较有意义\n1. RPC 原理；\n    - [你应该知道的 RPC 原理](http://blog.jobbole.com/92290/)\n\n## 三大框架\n\n1. Spring 主要思想是什么，回答 IOC 和AOP，怎么自己实现 AOP ？\n    - IOC 的好处：[阿里一面总结 12 题](阿里一面总结.md)\n    - 使用基于反射的动态代理\n1. SpringAOP 用的哪一种代理\n    - JDK 动态代理，这种是一般意义上的动态代理；用一个代理类来间接调用目标类的方法。目标类如果实现了接口那就用这种方式代理。\n    - cglib 动态代理。通过框架转换字节码生成目标类的子类，并覆盖其中的方法实现增强，因为采用的是继承，所以不能对 final 类进行代理。目标类没有实现任何接口，就使用这种方法\n1. spring bean 初始化过程\n    - 读取 XML 资源，并解析，最终注册到 Bean Factory 中\n1. spring bean 对象的生命周期\n    - 当一个 bean 被实例化时，它需要执行一些初始化(init-method)使它转换成可用状态。同样，当 bean 不再需要，并且从容器中移除时，需要做一些清除工作(destroy-method)\n1. 讲讲 Spring 中 ApplicationContext 初始化过程。\n    - ApplicationContext 的初始化重点是在 `refresh` 方法，其中最关键的几步是：\n        1. 创建 bean Factory\n        1. 初始化消息源\n        1. 初始化应用事件传播器\n        1. 初始化单例 bean\n1. SpringMVC 处理请求的流程\n    - ![](../res/springmvc-flow.png)\n    1. 收到用户请求\n    1. dispatcher Servlet 将请求转发到相应的 Controller\n    1. 通过 View Resolver 进行视图解析\n    1. 返回给用户\n1. SpringMVC 的设计模式\n1. Spring 的 annotation 如何实现\n1. Spring拦截器怎么使用，Controller是单例吗\n    1. 基于 XML 配置文件\n    1. 基于注解\n    1. 基于 Spring 定义的 MethodInterceptor 接口\n    - Controller 是单例的，跟 Servlet 一样。\n\n## 数据库 \n\n1. SQL 优化方案\n\n    根据我目前的知识水平，大概分为两类：\n\n    1. 多表连接时不直接连接表，而是先用 `where` 筛选出符合条件的记录然后进行连接。一般情况下，筛选一次会除去相当多的无效记录，这会极大的提高效率。\n    1. 判断当前的 SQL 是否合理的使用了索引。如果设置的索引没有使用的话，会导致全表扫描。效率上会差很多。没有利用索引的情况一般有以下几种：\n        - 以“%”开头的LIKE语句，模糊匹配\n        - OR 语句前后没有同时使用索引\n        - 数据类型出现隐式转化（如varchar不加单引号的话可能会自动转换为int型）\n        - where 子句中对字段进行表达式操作\n        - 在where子句中对字段进行函数操作\n1. 索引有哪些？分别有什么特点？\n    - 从底层数据结构来划分的话，主要有两种：一种是基于 B+ 树的索引，一种是基于哈希表的索引。基于哈希表的索引在等值查询上有绝对的优势，但其他方面就不是很好了。B+ 树是一种多分支的树结构，相比二叉树来说高度降低了很多，能够有效的减少磁盘 IO，所以我们平时使用的都是基于 B+ 树的索引\n1. 索引为什么用 B 树不用二叉树，有什么好处？\n    - 基于 B 树的索引实现，降低了树的高度，减少了磁盘 IO 的次数。\n1. 数据库索引优点和缺点\n    - 优点：有效加速查询；\n    - 缺点：操作数据时需要对索引进行更新，效率上稍微差一点；索引需要占用一定的空间。\n1. 数据库事务的四个隔离级别，MySql 在哪一个级别\n    - ![](../res/isolation-level.png)\n    - MySQL 默认隔离级别为 `Repeatable read`     \n1. 数据库，两次相同的 select 操作，期间没有发生增，删，改操作，返回的结果是否相同；\n    - 如果是多线程 select 数据，那么数据很大可能不相同（select 操作中有排序操作除外）\n    - 如果是单线程的，那么一定相同。\n1. 怎么设计数据库表（从范式角度，可以加一些设计惯例）\n    - 理论上说达到第三范式是符合要求的但是一般生产环境下为了数据查询方便，数据会有一定的冗余，也就是说一般达到第二范式即可。\n    1. 第一范式：字段不可分\n    1. 第二范式：非主属性必须完全函数依赖于主属性\n    1. 第三范式：消除了第二范式中的传递函数依赖\n1. MySQL 存储引擎有哪些，INNODB 和 MYISAM 的区别\n    - ![](../res/mysql-storage-engines-feature-summary.png)\n    - MySQL 支持 8 种存储引擎，其中最主要的有两个：InnoDB、MyISAM。\n        - MyISAM 支持表级锁。适用于选择密集型和插入密集型的表\n        - InnoDB 是 5.7.16-log MySQL Community Server 默认的存储引擎，支持事务，行级锁，外键，聚集索引。适用于更新密集的表，容灾性也较好。\n1. 实践中如何优化 MySQL\n    - SQL语句及索引的优化\n    - 数据库表结构的优化\n    - 系统配置的优化\n    - 硬件的优化\n1. 慢查询\n    - MySQL 慢查询就是在日志中记录运行比较慢的 SQL 语句，这个功能需要开启才能用。\n1. int(8) 和 int(10) 的区别是什么\n    - 与 `zerofill` 结合使用才有意义，默认是 int(10)，也就是说定义字段时加上 `zerofill`，如果插入的值不足 10 位的话，select 的时候会加上前导 0 补足 10 位，如果插入的值大于等于 10 位则直接显示原值。所以这个地方 8 和 10 的区别就在于是补足 8 位还是 10 位。\n\n## 操作系统\n\n1. 进程和线程的区别\n    1. 进程是拥有资源的基本单位，线程是 CPU 调度的基本单位\n    1. 进程拥有独立的地址空间，同一个进程的线程共享该进程的地址空间\n    1. 进程上下文切换相对线程上下文切换会消耗更多的资源\n    1. 一个进程必须至少拥有一个线程\n    1. 一个线程死掉就等于整个进程死掉，所以多进程的程序相对于多线程的程序来说会更健壮\n    1. 通信方式不同，线程通过进程内的资源进行通信，进程的通信有多种方式，包括管道、共享内存、消息等等。\n1. 进程间通信\n    1. 管道（Pipe）及有名管道（named pipe）：管道可用于具有亲缘关系进程间的通信，有名管道克服了管道没有名字的限制，因此，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；\n    1. 信号（Signal）：信号是比较复杂的通信方式，用于通知接受进程有某种事件发生，除了用于进程间通信外，进程还可以发送信号给进程本身；\n    1. 报文（Message）队列（消息队列）：消息队列是消息的链接表。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点。\n    1. 共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。\n    1. 信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。\n    1. 套接口（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。\n1. 在共享内存中如何使用 mutex\n1. select 和 epoll\n1. 操作系统由哪几部分组成，进程结构\n1. 多进程和多线程的区别\n1. 什么时候使用多线程，什么时候使用多进程\n1. Java 多线程与操作系统线程的关系\n1. 一般线程和守护线程的区别\n1. 多线程与多线程的实现方式\n1. 死锁的条件，死锁避免。\n    1. 互斥条件\n    1. 占有和等待条件\n    1. 不剥夺条件\n    1. 循环等待\n1. linux中如何查看进程等命令\n1. 不同进程打开了同一个文件，那么这两个进程得到的文件描述符（fd）相同吗\n    - 不一定，因为打开文件有三个表，inode 表，系统文件描述符表，进程文件描述符表。不同进程的文件描述符的范围是一样的，有可能刚好相同，也有可能不相同\n1. 两个线程如何同时监听一个端口。\n    - SO_REUSEPORT 参数。\n\n## 计算机网络\n\n1. HTTP 状态码有哪些，一一解释含义\n    1. 1xx 消息\n        - 100 服务器仅接收到部分请求，但是一旦服务器并没有拒绝该请求，客户端应该继续发送其余的请求。\n    1. 2xx 成功\n        - 200 OK  请求成功（其后是对GET和POST请求的应答文档。）\n    1. 3xx 重定向\n        - 304 Not Modified 未修改的文档。客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。\n    1. 4xx: 客户端错误\n        - 400 Bad Request  服务器未能理解请求。\n        - 404 Not Found 服务器无法找到被请求的页面。\n    1. 5xx: 服务器错误\n        - 500 Internal Server Error  请求未完成。服务器遇到不可预知的情况。\n1. HTTP 请求头有哪些，介绍平时见过的，怎么利用这些信息来进行前后端调试\n    1. `Host`, 请求的域名\n    1. `User-Agent`，用户的浏览器版本信息\n    1. `Accept`，响应的内容类型\n    1. `Accept-Language`, 接受的语言\n    1. `Accept-Encoding`, 可接受的编码方式\n    1. `Cookie`，本地的 Cookie 信息\n    1. `if-Modified-Since`, 本地有缓存，如果在那之后没有做修改，则可以直接使用本地缓存。\n1. TCP 和 UDP 的区别\n    - ![](../res/diff-tcp-udp.png)\n1. TCP 如何保证可靠性\n    1. 累计确认\n    1. 超时重传\n    1. 超时间隔加倍\n    1. 快速重传\n1. 拥塞控制与流量控制的区别\n    - 流量控制是由接收方来控制的，拥塞控制由当前的网络环境来控制。\n1. OSI七层模型，每层对应的协议有哪些，每层有何含义\n    - ![](../res/tcp-ip-model.png)\n1. 网络浏览器访问一个网址发生了什么过程\n    1. 在地址栏输入 URL，并回车\n    1. 浏览器查询域名的 IP。一般会有以下几个地方：\n        1. 浏览器缓存\n        1. 操作系统缓存\n        1. 路由器缓存\n        1. 本地 DNS 服务器\n        1. 如果本地 DNS 服务器上没有的话，它会递归的从根 DNS 服务器、顶级 DNS 服务器、权威 DNS 服务器请求，然后把获取到的 IP 返回给浏览器（DNS 协议基于 UDP）。\n    1. 浏览器向 web 服务器发送 HTTP 请求\n        1. HTTP 协议基于 TCP，建立连接需要经过三次握手，并且该连接是长连接，即 `keep-alive`\n        1. IP 数据包在网络传输中还需要经过域间选路和域内选路。\n        1. 若长时间接收不到应答，TCP 会进行重传和拥塞控制。\n        1. BLABLABLA...\n    1. web 服务器处理请求\n    1. web 服务器回传一个 HTTP 相应\n    1. 浏览器接收到以后解析 HTML并显示\n    1. 浏览器请求嵌入在 HTML 中的对象\n    1. 最终浏览器呈现一个图文并茂的页面\n1. Cookie 和 Session 的区别\n    1. Session 是存储在服务器端的，Cookie 是存储在客户端的 //TODO\n1. HTTP1.0 和 1.1 的区别\n    - 最主要的区别是 1.1 支持持久连接。Connection 请求头的值为 Keep-Alive 时，客户端通知服务器返回本次请求结果后保持连接；Connection 请求头的值为 close 时，客户端通知服务器返回本次请求结果后关闭连接。\n    - 1.1 支持断点续传。`RANGE:bytes=XXX` 表示要求服务器从文件 XXX 字节处开始传送\n    - 还有一些其他的改进，有兴趣可以自行查阅相关资料\n1. HTTP 和 HTTPS 的主要区别\n    - 安全。HTTP 直接与 TCP  通信，而 HTTPS 是先与 SSL（加密） 通信，然后再由 SSL 和 TCP 通信\n1. 滑动窗口算法\n    - 又称回退 N 步（go-back-N）,发送方的窗口滑动是由接收方是否已成功收到数据包来决定的。即接收方的窗口向前滑动后发送方的窗口才会向前滑动。//TODO\n1. 域名解析详细过程\n1. IP 地址分为几类，每类都代表什么，私网是哪些\n    - A：前 1 byte 为网络标识，剩下的是主机标识\n    - B：前 2 bytes 为网络标识\n    - C：前 3 bytes 为网络标识\n    - D：为多播地址，最高位为 1110\n    - E：特殊 IP。例如 0.0.0.0，127.0.0.1,255.255.255.255 等等\n    - 私网\n        - 10.0.0.0/8\n        - 172.16.0.0/12\n        - 192.168.0.0/16\n1. IP 头组成；\n1. 计算机网络中的同步和异步\n1. 发现百度上不去，怎么办\n    1. 查看 DNS 解析是否正确。若有错误，删除本地 DNS 缓存\n    1. 若 DNS 没有问题，使用 traceroute 检测路径，若路径不通则说明网路阻塞，暂时就别上网了\n    1. traceroute 没有问题，ping 也能通一般就是服务器端出问题了。\n\n## 分布式/集群等高级主题\n\n1. Session 集群同步问题。\n    - 首先 Session 集群的话会有两种方式存放 Session。\n        - 一种是将同一个用户每次都负载均衡到同一个请求处理服务器，这样不需要考虑 Session 同步的问题\n        - 一种是每台 Session 服务器都保存所有的 Session 信息，当一台 Session 服务器中的  Session 有更新了就将更新同步到其他所有的 Session 服务器上\n    - Session 的持久性类型\n        1. 内存\n        1. 数据库\n        1. 文件系统\n1. 负载均衡原理\n    - 负载均衡有硬件和软件两种，一般用的都是基于软件的负载均衡。软件负载均衡一般分为四层和七层：\n        - 四层的工作在 TCP/IP 协议栈上通过修改数据包的 IP 和 端口号 来转发，效率相对七层的来说会更高一点，一般在前端服务器中使用。LVS 就是用这种方式实现的。\n        - 七层的工作在应用层，可以做到更智能的负载均衡。一般部署在前台服务器和应用服务器之间。Apache 和 Nginx 都是七层的。\n1. 负载均衡算法\n    1. 随机：负载均衡方法随机的把负载分配到各个可用的服务器上。\n    1. 轮询：按顺序将新的连接请求分配给下一个服务器\n    1. 加权轮询：每台服务器接受到的连接数按权重分配，一般是用在应用服务器的处理能力大小不同的情况下。\n    1. 最少连接：把新连接分配给当前连接最少的服务器\n    1. BLABAL...\n1. 分布式数据库\n    - 分布式数据库提供了原来集中式数据库不具备的高可用性和拓展能力\n    - 分布式数据库的架构一般有以下几个\n        1. 厂商提供的集群产品\n        1. 数据分片。将原来集中式数据库中的数据进行切分，分别存放在不同的服务器中。\n            - 优点： 集群扩展能力很强，几乎可以做到线性扩展，而且整个集群的可用性也 很高，部分节点故障，不会影响其他节点提供服务\n            - 缺点：如果需要跨不同的节点做 join，或者统计类型的操作，将会变得非常困难\n        1. 读写分离。使用数据库的复制技术，每台服务器上都有完整的数据副本。读和写分布在不同的处理节点上。比较适合读操作较多的应用\n            - 优点：可以通过增加提供读操作的服务器数量来线性增加读操作的性能\n            - 缺点：每个节点都必须保存完整的数据，在数据量很大时集群的拓展能力还受限于单个节点的存储能力。不适合写操作较多的应用\n    - 一般来说缓存 + DB 的读写分离架构用的是比较多的。缓存层使用 key-value 的形式来承载大量的读操作，DB 承载数据持久化。一般过程如下（基于 memcached）：用户的读请求会首先访问缓存，如果缓存命中，则返回；如果没有命中则将数据加载到缓存中再返回。对于插入、修改、删除操作，一般使用延缓加载的策略，也就是直到下次读取时才更新缓存。（删除和修改操作会将缓存中的数据标记为已失效）\n\n## 技术开放题\n\n1. 如何设计一个高并发的系统\n    - 数据库的优化，包括合理的事务隔离级别、SQL语句优化、索引的优化\n    - 使用缓存，尽量减少数据库 IO\n    - 分布式数据库、分布式缓存\n    - 服务器的负载均衡\n1. 现在一个网页响应速度明显变慢了，假如我把这个任务交给你，你怎么处理这个问题\n1. 负载均衡的大题，数千万的负载部署到机器上，要求对问题进行抽象，建模，提出解决方案。\n1. 美团面试官来到一个城市面试应聘者，面试有三天，每天面试官上午可以面试三场，下午可以面试四场，怎么设计面试系统，面试者可以选择面试日期，面试时间和面试官。\n1. 有一些爬虫IP不断的访问美团网站，现在美团设定一个IP5分钟之内访问美团网站超过100次，就判定为爬虫IP，怎么设计这个程序？如果100改成10000，怎么设计？\n1. 假设在某一时刻由几万个并发请求同时产生，请设计一个方案来处理这种情况。\n1. 问我简历上学校 oj 平台这个项目怎么实现1000人并发?并发的性能瓶颈在哪?\n    - 因为还没完成，现处于开发阶段，只跟面试官说了下自己的构想，nginx+tomcat集群，性能瓶颈可能出现在网络io和java gc上，然后说了下jvm gc的优化，如何实现session共享。最后我问了下面试官这样设计可以吗，他说这样设计不行可能有问题，没有告诉我问题出现在哪里。\n\n## 题目参考\n\n1. [阿里、百度、腾讯、华为面经（均已拿到offer）](https://www.nowcoder.com/discuss/11495)\n1. [【面经】阿里+百度+CVTE面经合集（offer均已收到）](https://www.nowcoder.com/discuss/5941)\n1. [18届开学到现在找实习面经（已拿到腾讯，第四范式offer）](https://www.nowcoder.com/discuss/23232)\n1. [某度三面，给面试官里里外外摸了一个半小时！](https://www.nowcoder.com/discuss/11074?type=0&order=3&pos=1486&page=1)\n1. [腾讯二面三面、百度二面三面面经](https://www.nowcoder.com/discuss/12083?type=0&order=3&pos=542&page=1)\n1. [渣渣养成记（中兴+腾讯+CVTE+乐视+京东+七牛云）](https://www.nowcoder.com/discuss/12173?type=0&order=3&pos=463&page=1)\n1. [滴滴，美团点评，腾讯一面面经](https://www.nowcoder.com/discuss/11584?type=0&order=3&pos=1013&page=1)\n1. [2016秋招网易、百度、腾讯面经](https://www.nowcoder.com/discuss/11485?type=0&order=3&pos=1106&page=1)\n1. [一周来的面试面经](https://www.nowcoder.com/discuss/9330)\n1. [回馈牛客 - 2017 校招不完全记录](https://www.nowcoder.com/discuss/19724?type=2&order=3&pos=15&page=1)\n1. [阿里四面面经 + 已成功拿到offer](https://www.nowcoder.com/discuss/8343?type=0&order=3&pos=3950&page=1)\n1. [校招季一路走来面经分享](https://www.nowcoder.com/discuss/12393?type=0&order=3&pos=254&page=1)\n1. [网易+阿里内推面经](https://www.nowcoder.com/discuss/11971?type=0&order=3&pos=643&page=1)\n1. [校招季一路走来面经分享](https://www.nowcoder.com/discuss/12393?type=2&order=0&pos=13&page=1)\n1. [拿到阿里、百度、美团、华为offter后的一些想法](https://www.nowcoder.com/discuss/14443?type=2&order=3&pos=144&page=2)\n1. [京东Java研发（1面+2面）](https://www.nowcoder.com/discuss/11185?type=0&order=3&pos=1380&page=1)\n1. [武汉京东一面面经](https://www.nowcoder.com/discuss/11040?type=0&order=3&pos=1517&page=1)\n1. [JD(北京)复试](https://www.nowcoder.com/discuss/9700?type=0&order=3&pos=2730&page=1)\n1. [谈谈我那的京东面试，伤心](https://www.nowcoder.com/discuss/9673?type=0&order=3&pos=2755&page=1)\n1. [京东一面经验分享](https://www.nowcoder.com/discuss/9497?type=0&order=3&pos=2909&page=1)\n1. [京东校招一面](https://www.nowcoder.com/discuss/9311?type=0&order=3&pos=3081&page=1)\n1. [京东一面面经](https://www.nowcoder.com/discuss/9270?type=0&order=3&pos=3115&page=1)\n1. [2017校招总结](https://www.nowcoder.com/discuss/13823?type=2&order=3&pos=163&page=1)\n1. [网易杭研，Java工程师，面经，已拿offer](https://www.nowcoder.com/discuss/8340?type=0&order=3&pos=3953&page=1)\n1. [【面经】一面+二面+HR面【网易内推】【java开发工程师】](https://www.nowcoder.com/discuss/7601?type=0&order=3&pos=4599&page=1)\n1. [网易互联网Java内推面试经验-19号](https://www.nowcoder.com/discuss/7565?type=0&order=3&pos=4629&page=1)\n1. [完美JAVA一面](https://www.nowcoder.com/discuss/12249?type=0&order=3&pos=389&page=1)\n1. [去哪儿校招现场面面经](https://www.nowcoder.com/discuss/9296?type=0&order=3&pos=3092&page=1)\n1. [西安，美团面经 java](https://www.nowcoder.com/discuss/11319?type=0&order=3&pos=1254&page=1)\n1. [美团补招](https://www.nowcoder.com/discuss/19994?type=2&order=3&pos=11&page=1)\n1. [年级倒数TOP20%的求职经验](https://www.nowcoder.com/discuss/18855?type=2&order=3&pos=44&page=1)\n\n## 解答参考\n\n1. [Java HashMap工作原理及实现 ](http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/)\n1. [红黑树和AVL树的比较 ](http://blog.csdn.net/hustyangju/article/details/27214251)\n1. [从B树、B+树、B*树谈到R 树 ](http://blog.csdn.net/v_july_v/article/details/6530142)\n1. [Trie树（Prefix Tree）介绍 ](http://blog.csdn.net/lisonglisonglisong/article/details/45584721)\n1. [如何设计实现一个LRU Cache？](http://yikun.github.io/2015/04/03/%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AALRU-Cache%EF%BC%9F/)\n1. [大家谈18岁的Java——周志明：多语言协作至今仍是一个被严重忽视的优势](http://www.infoq.com/cn/news/2013/06/zhiming-on-java-18)\n1. [Don\'t Expect a primitive Boolean value to occupy only 1 bit](http://www.programmr.com/blogs/two-things-every-java-developer-should-know-about-booleans)\n1. [Controlling Access to Members of a Class](http://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html)\n1. [String(Java Platform SE 8)](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html)\n1. [Comparable接口和Comparator接口的区别与使用](http://www.jianshu.com/p/c1adc26caf3b)\n1. [双轴快速排序源码阅读笔记](http://www.jianshu.com/p/6d26d525bb96)\n1. [Quicksorting - 3-way and Dual Pivot](http://rerun.me/2013/06/13/quicksorting-3-way-and-dual-pivot/)\n1. [[原理]通俗编程——白话JAVA异常机制](http://www.jianshu.com/p/44651f3ade67)\n1. [Exception Handling in Java](http://www.journaldev.com/1696/exception-handling-in-java)\n1. [Java进阶（二）当我们说线程安全时，到底在说什么 ](http://www.jasongj.com/java/thread_safe/)\n1. [乐观锁与悲观锁的区别](http://www.cnblogs.com/Bob-FD/p/3352216.html)\n1. [深入浅出ConcurrentHashMap1.8](http://www.jianshu.com/p/c0642afe03e0)\n1. [JAVA CAS原理深度分析](http://zl198751.iteye.com/blog/1848575)\n1. [【死磕Java并发】-----深入分析synchronized的实现原理 ](http://blog.csdn.net/chenssy/article/details/54883355)\n1. [Java深度历险（七）——Java反射与动态代理](http://www.infoq.com/cn/articles/cf-java-reflection-dynamic-proxy)\n1. [Servlet 生命周期](http://www.runoob.com/servlet/servlet-life-cycle.html)\n1. [JVM 垃圾回收器工作原理及使用实例介绍](https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/)\n1. [GC 算法(实现篇) - GC参考手册 ](http://blog.csdn.net/renfufei/article/details/54885190)\n1. [Major GC和Full GC的区别是什么？触发条件呢？](https://www.zhihu.com/question/41922036)\n1. [GC详解及Minor GC和Full GC触发条件总结 ](https://my.oschina.net/yongqingfan/blog/832630)\n1. [With Java 1.8, when to use G1 vs CMS?](https://groups.google.com/a/jclarity.com/forum/#!topic/friends/0Ennhw9n0Hg)\n1. [深入理解G1垃圾收集器](http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/)\n1. [G1，CMS及PARALLEL GC的比较](http://it.deepinmind.com/gc/2014/05/01/g1-vs-cms-vs-parallel-gc.html)\n1. [jvm内存分配及gc过程详解](http://www.ppzedu.com/archives/242.html)\n1. [面试题：“你能不能谈谈，java GC是在什么时候，对什么东西，做了什么事情？”](http://jeromecen1021.blog.163.com/blog/static/18851527120117274624888/)\n1. [Java永久代去哪儿了](http://www.infoq.com/cn/articles/Java-PERMGEN-Removed)\n1. [Java深度历险（四）——Java垃圾回收机制与引用类型](http://www.infoq.com/cn/articles/cf-java-garbage-references)\n1. [你应该知道的 RPC 原理](http://blog.jobbole.com/92290/)\n1. [数据库SQL优化大总结之 百万级数据库优化方案](http://www.cnblogs.com/yunfeifei/p/3850440.html)\n1. [MySQL有哪些索引类型 ?](https://segmentfault.com/q/1010000003832312)\n1. [数据库事务隔离级别](http://singo107.iteye.com/blog/1175084)\n1. [什么是慢查询？](http://www.jianshu.com/p/7529a0fbf088)\n1. [mysql int(3)与int(11)的区别](http://blog.sina.com.cn/s/blog_610997850100wjrm.html)\n1. [Chapter 16 Alternative Storage Engines](https://dev.mysql.com/doc/refman/5.7/en/storage-engines.html)\n1. [HTTP 状态消息](http://www.w3school.com.cn/tags/html_ref_httpmessages.asp)\n1. [List of HTTP header fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields#Request_fields)\n1. [TCP和UDP之间的区别 ](http://feinibuke.blog.51cto.com/1724260/340272)\n1. [What really happens when you navigate to a URL](http://igoro.com/archive/what-really-happens-when-you-navigate-to-a-url/)\n1. [在浏览器地址栏输入一个URL后回车，背后会进行哪些技术步骤？](https://www.zhihu.com/question/34873227)\n1. [session与cookie的区别与联系](http://www.jianshu.com/p/4ce62bcbfb82)\n1. [面试时如何优雅的谈论HTTP／1.0／1.1／2.0](http://www.jianshu.com/p/52d86558ca57)\n1. [Spring AOP的一点总结](http://www.jianshu.com/p/4fe5a75b9202)\n1. [Spring IOC核心源码学习 ](http://yikun.github.io/2015/05/29/Spring-IOC%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/)\n1. [Bean 的生命周期](http://wiki.jikexueyuan.com/project/spring/bean-life-cycle.html)\n1. [【Spring】IOC核心源码学习（二）：容器初始化过程](http://singleant.iteye.com/blog/1177358)\n1. [【Spring】Spring MVC原理及配置详解 ](http://blog.csdn.net/jianyuerensheng/article/details/51258942)\n1. [springMVC学习笔记(一)-----springMVC原理](http://www.cnblogs.com/selene/p/4658554.html)\n1. [Spring 框架的设计理念与设计模式分析](https://www.ibm.com/developerworks/cn/java/j-lo-spring-principle/)\n1. [Spring 使用笔记之(二) - AOP和Interceptor(拦截器)](http://www.hifreud.com/2015/01/28/04-spring-AOP/#%E6%8B%A6%E6%88%AA%E5%99%A8interceptor%E7%9A%84%E4%B8%89%E7%A7%8D%E5%AE%9E%E7%8E%B0)\n1. [深入理解各JEE服务器Web层集群原理](http://www.infoq.com/cn/minibooks/jee-webserver-cluster)\n1. [服务器集群负载均衡原理？](https://www.zhihu.com/question/22610352)\n1. [负载均衡的基本算法](http://www.cnblogs.com/shanyou/archive/2012/11/09/2763272.html)\n1. [可扩展的分布式数据库架构](http://blogread.cn/it/article/1945?f=wx)\n1. [分布式缓存系统Memcached实践](http://www.jianshu.com/p/e5b11670c3bb)\n1. [深入分析 Java I/O 的工作机制](https://www.ibm.com/developerworks/cn/java/j-lo-javaio/)\n1. [怎样理解阻塞非阻塞与同步异步的区别？](https://www.zhihu.com/question/19732473)\n1. [Java I/O 模型的演进](http://www.importnew.com/21383.html)\n1. [java I/O 模型简述](http://haoran-10.iteye.com/blog/2311266)\n1. [Java NIO Tutorial](http://tutorials.jenkov.com/java-nio/index.html)\n1. [深刻理解Linux进程间通信（IPC）](https://www.ibm.com/developerworks/cn/linux/l-ipc/)\n1. [进程间通信机制（管道、信号、共享内存/信号量/消息队列）、线程间通信机制（互斥锁、条件变量、posix匿名信号量）](http://blog.csdn.net/jnu_simba/article/details/11746217)\n','面试',1007,'2023-05-11 13:20:02'),(1009,'岗位要求总结及待学习技术汇总','## 岗位要求\n\n### （腾讯）软件开发 - 后台开发方向\n\n- 岗位描述\n\n> 从事腾讯产品服务后台的架构设计、开发、优化及运营工作；使用最优秀的架构设计及算法实现，在网络接入、业务运行逻辑、用户数据存储、业务数据挖掘等方向，为海量互联网用户提供稳定、安全、高效和可靠的专业后台支撑体系。\n\n- 岗位要求\n\n> 编程基本功扎实，掌握C/C++/JAVA等开发语言、常用算法和数据结构；\n\n> 熟悉TCP/UDP网络协议及相关编程、进程间通讯编程；\n\n> 了解Python、Shell、Perl等脚本语言；\n了解MYSQL及SQL语言、编程，了解NoSQL, key-value存储原理；\n\n> 全面、扎实的软件知识结构，掌握操作系统、软件工程、设计模式、数据结构、数据库系统、网络安全等专业知识；\n\n> 了解分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统等知识。\n\n\n### （阿里）研发工程师JAVA Software Engineer - Java\n\n- 岗位描述\n> 如果你对基础技术感兴趣，你可以参与基础软件的设计、开发和维护，如分布式文件系统、缓存系统、Key/Value存储系统、数据库、Linux操作系统和Java优化等；\n\n> 如果你热衷于高性能分布式技术，你可以参与高性能分布式服务端程序的系统设计，为阿里巴巴的产品提供强有力的后台支持，在海量的网络访问和数据处理中，设计并设施最强大的解决方案；\n\n- 岗位要求\n\n> 或许，你熟悉Unix/Linux/Win32环境下编程，并有相关开发经验，熟练使用调试工具，并熟悉Perl，Python，shell等脚本语言；\n\n> 或许，你熟悉网络编程和多线程编程，对TCP/IP，HTTP等网络协议有很深的理解，并了解XML和HTML语言；\n\n> 或许，你热衷于数据库技术，能够熟练编写SQL脚本，有MySql或Oracle应用开发经验；\n\n> 也有可能，你在学校的时候作为骨干参与学生网站的建设和开发；\n\n### （网易）高级Java开发工程师（云音乐）-音乐事业部002\n\n- 岗位描述\n\n> 负责互联网产品后端服务器架构设计，要求系统具有可扩展性， 能够支持大量并发用户；\n\n> 根据产品需求完成服务器架构和模块设计、编码、测试以及文档编写等工作；\n\n> 优化系统性能， 保证服务器质量和性能。\n\n- 岗位要求\n\n> 理解java运行时工作原理，熟悉jvm性能调优，能够充分利用java特性支持框架与程序库的设计开发;\n\n> 熟悉多线程编程，熟练使用java并发包下的各项常用基础设施;\n\n> 熟悉常用网络协议，如TCP/IP, HTTP; 熟悉网络编程，能够熟练使用java nio开发高并发、高吞吐量的服务;\n\n> 能够熟练使用linux，能够利用常用的工具对程序进行跟踪诊断;\n\n> 有分布式系统开发经验，对消息服务、负载均衡、高可用机制等有深入理解;\n\n### （携程）开发工程师\n\n- 岗位描述\n\n> 分析、设计、开发和测试中国最大旅游电子商务网站的前台功能和后台框架；\n\n> 对大规模、高并发的在线系统进行性能诊断、性能调优和代码优化\n\n- 岗位要求\n\n> 熟悉基本数据结构和基本算法实现，对代码优化感兴趣，理解代码背后的运行机制；\n\n> 熟练使用至少一种开发语言（c、c++、C#、Java、python等）；\n\n> 了解数据库编程的基本知识和常用SQL的开发和性能调优，了解SQLServer或MySql数据库更优；\n\n> 了解多线程编程，大数据相关技术，对开源项目有浓厚兴趣；\n\n> 优秀的分析问题和解决问题的能力，勇于解决难题；\n\n> 期待你具备Linux开发经验或JavaWeb开发经验；\n\n### （美团点评）【实习生】后台开发工程师\n\n- 岗位描述\n\n> 后端模块、数据平台、基础服务和云计算功能的开发工作；\n\n> 需求定义，确定设计方案并负责最终实现。\n\n- 岗位要求\n\n> 至少学习并实践过一门以上的开发语言（比如：Java、C、C++、Python、Ruby等）；\n\n> 读过Thinking in Java，Effective Java等Java名著；\n\n> 熟悉基础数据结构，如链表，二叉树等；\n\n> 对新技术有强烈的求知精神，能深入代码研究，能通过英文论文等第一手资料了解业界新技术；\n\n### （今日头条）后台研发工程师\n\n- 岗位描述\n\n> 负责架构设计和开发，为亿级用户提供优质顺畅的信息服务和极致体验；\n\n> 参与设计系统技术方案，核心代码开发和系统调优；\n\n> 参与制定代码规范、测试规范，建立起开发质量控制方法；\n\n> 协助团队攻克各种高并发、数据隔离、系统解耦等方面的技术难关；\n\n- 岗位要求\n\n> 热爱计算机科学和互联网技术，精通至少一门编程语言，包括但不仅限于：Java，C/C++，PHP， Python，Go；\n\n> 掌握扎实的计算机基础知识，深入理解数据结构、算法和操作系统知识；\n\n> 有优秀的逻辑分析能力，能够对业务逻辑进行合理的抽象和拆分；\n\n### 总结\n\n1. 熟练掌握一门语言 （Java + JVM(GC)）\n1. 网络协议（TCP/UDP），网络编程。\n1. 多线程，java 并发包\n1. 数据库，MySQL，SQL 优化\n1. 操作系统，熟练使用 Linux；熟练使用调试工具，并熟悉Perl，Python，shell等脚本语言；\n1. 分布式系统设计与开发、负载均衡技术，系统容灾设计，高可用系统\n\n## web developer roadmap\n- ![](../res/web-developer-roadmap-intro.png)\n- ![](../res/web-developer-roadmap-backend.png)\n- ![](../res/web-developer-roadmap-devops.png)\n- ![](../res/java-developer-skills.jpg)\n\n## 参考\n\n1. [（腾讯）软件开发 - 后台开发方向](http://join.qq.com/post.php?zwl=75)\n1. [（阿里）研发工程师JAVA Software Engineer - Java](https://campus.alibaba.com/traineePositions.htm?refno=11757)\n1. [（网易）高级Java开发工程师（云音乐）-音乐事业部002](http://hr.163.com/position/detail.do?id=4955)\n1. [（携程）开发工程师](http://techshow.ctrip.com/campus/campus-sfe.php?job_type=job_1)\n1. [（美团点评）【实习生】后台开发工程师](http://campus.meituan.com/#/jobDetail/8373/)\n1. [（今日头条）后台研发工程师](https://job.toutiao.com/job/detail/5792)\n1. [Roadmap to becoming a web developer in 2017](https://github.com/kamranahmedse/developer-roadmap)\n1. [Java工程师技能表](http://mp.weixin.qq.com/s?__biz=MjM5NzA1MTcyMA==&mid=2651163038&idx=1&sn=28d919cea7c915f093d4333858037df2&chksm=bd2ec5b98a594cafd6c203db80f444c168e64dc5757dbd179ad2ca3062618c4d38a6fbd6142e&mpshare=1&scene=22&srcid=0323pMGmrZreC5DehdEfUAsO#rd)\n','求职',1007,'2023-05-12 03:22:58'),(1010,'面试题目分类及举例','## 自我介绍\n\n- 自我介绍，名字，学校，研究方向，做的哪些项目，目前在做哪些项目\n\n## 数据结构\n\n- 排序算法及时空复杂度\n- 红黑树，红黑树用在哪。\n    - TreeMap，1.8的HashMap\n- B+ 树（数据库索引）\n\n- 参考资料\n    - 《算法》\n    - 《数据结构与算法分析》\n\n## Java 基础\n\n- voliate 关键字\n- JDK1.8 的改进\n- 对 Java 的集合框架有什么样的了解, 用过哪些集合类, 各自的效率以及适用场景\n- HashMap 具体的实现（原理）\n- ArrayList 怎么转换成 list\n- ArrayList 与 LinkedList 的区别。\n    - 紧接着问我 ArrayList 可以根据下表查找，LinkedList 可以吗？\n    - ArrayList 初始容量，如果满了会怎么办？ 怎么扩容？是新建一个2倍空间的数组然后把值复制进去么？\n- JVM 的同步锁\n- 继承和多态的内存模型\n\n- 参考资料\n    - 源码\n    - oracle 官方文档\n    - 姜志明老师课件\n    - [jenkov](http://tutorials.jenkov.com/)\n\n## Java 进阶\n\n- Java 类加载机制\n- JVM 如何确立每个类在 JVM 的唯一性\n- 对 JVM 的垃圾回收的认识\n- 新生代老年代的概念与晋升，以及新生代与老年代的垃圾回收，CMS垃圾收集器\n- JVM 调优\n- JVM 内存模型\n\n- 参考资料\n    - 《深入理解 Java 虚拟机》\n\n## 数据库\n\n- SQL 语句编写\n    - group by 、order by 和聚集函数 的用法\n- SQL查询优化\n- 数据库索引的实现，B+ 树的特点与优势，叶子结点链表，缓存命中率提高\n\n- 参考资料\n    - w3school\n    - 《数据库系统概念》\n\n## 操作系统\n\n- 说一下 linux 下命令，如果替换文本中某个字符串用什么命令\n- 进程与线程的区别\n- 进程间通信的方式\n- 线程实现同步的方式\n- IPC 进程间的通信\n\n- 参考资料\n    - 《现代操作系统》\n    - 《操作系统概念》\n    - 《Linux/Unix 系统编程手册》\n\n## 计算机网络\n\n- OSI七层模型有哪些，每一层的作用\n- TCP建立连接过程（三次握手）\n- TCP连接断开过程（四次挥手）\n- TCP洪水攻击\n\n- 参考资料\n    - 《计算机网络 自顶向下方法》\n\n## 其他\n\n- 举出一个例子说明你的自学能力\n- 有做过什么开源项目或者对开源项目有什么贡献吗\n- 有什么想问的？在哪个部门？目前做的业务？以及目前所用到的一些技术？\n- 以后想从事哪个方向啊？\n- 你想去哪个部门？\n\n- 对服务器端开发的理解？\n- 影响单台服务器的并发量的因素有哪些？如何优化？\n    - 操作系统角度\n    - 计算机网络角度\n    - 数据库角度\n    - 上下文切换：CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。上下文切换会影响多线程的执行速度，因此并发线程数并不是越多越好，需要合理控制并发线程数。减少上下文切换的方法有：\n    - 无锁并发编程：多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，比如参考ConcurrentHashMap的实现思想，将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。\n    - CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需加锁。\n    - 使用最少线程。避免创建不需要的线程。\n    - 协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。\n    - 资源限制方面。硬件因素有服务器的带宽，磁盘读写速度和CPU的处理速度。软件资源限制有数据库的链接数和socket链接数等。\n\n## 题目来源\n\n- [牛客网](https://www.nowcoder.com/)\n','求职',1008,'2023-05-12 01:22:58'),(1011,'谈谈 Java 类加载机制','\n最近在学习 Tomcat 架构，其中很重要的一个模块是类加载器，因为以前学习的不够深入，所以趁这个机会好好把类加载机制搞明白。\n\n\n## Overview\n\n![](../res/Class-loader.png)\n\n类加载器主要分为两类，一类是 JDK 默认提供的，一类是用户自定义的。\nJDK 默认提供三种类加载器\n\n1. `Bootstrap ClassLoader`，启动类加载器，每次执行 `java` 命令时都会使用该加载器为虚拟机加载核心类。该加载器是由 `native code` 实现，而不是 Java 代码，加载类的路径为 `<JAVA_HOME>/jre/lib`。特别的 `<JAVA_HOME>/jre/lib/rt.jar` 中包含了 `sun.misc.Launcher` 类， 而 `sun.misc.Launcher$ExtClassLoader` 和 `sun.misc.Launcher$AppClassLoader` 都是 `sun.misc.Launcher` 的内部类，所以拓展类加载器和系统类加载器都是由启动类加载器加载的。\n1. `Extension ClassLoader`, 拓展类加载器，用于加载拓展库中的类。拓展库路径为 `<JAVA_HOME>/jre/lib/ext/`。实现类为 `sun.misc.Launcher$ExtClassLoader`\n1. `System ClassLoader`, 系统类加载器。用于加载 CLASSPATH 中的类。实现类为 `sun.misc.Launcher$AppClassLoader`\n\n用户自定义的类加载器\n\n1. `Custom ClassLoader`, 一般都是 `java.lang.ClassLoder` 的子类\n\n正统的类加载机制是基于双亲委派的，也就是当调用类加载器加载类时，首先将加载任务委派给双亲，若双亲无法加载成功时，自己才进行类加载。\n\n在实例化一个新的类加载器时，我们可以为其指定一个 `parent`，即双亲，若未显式指定，则 `System ClassLoader` 就作为默认双亲。\n\n具体的说，类加载任务是由 `ClassLoader` 的 `loadClass()` 方法来执行的，他会按照以下顺序加载类：\n\n1. 通过 `findLoadedClass()` 看该类是否已经被加载。该方法为 native code 实现，若已加载则返回。\n1. 若未加载则委派给双亲，`parent.loadClass()`，若成功则返回\n1. 若未成功，则调用 `findClass()` 方法加载类。`java.lang.ClassLoader` 中该方法只是简单的抛出一个 `ClassNotFoundException` 所以，自定义的 ClassLoader 都需要 Override `findClass()` 方法\n\n## API for class loading\n\n### `java.lang.ClassLoader`\n\n- `ClassLoader` 是一个抽象类。\n- 待加载的类必须用 `The Java™ Language Specification` 定义的全类名，全类名的定义请查阅 [The Form of a Binary](https://docs.oracle.com/javase/specs/jls/se8/html/jls-13.html#jls-13.1)。\n- 给定一个全类名，类加载器应该去定位该类所在的位置。通用的策略是将全类名转换为类文件路径，然后通过类文件路径在文件系统中定位。\n- 每一个加载到内存的类都由一个 Class 对象来表示，每一个 Class 对象都有一个指向加载该类的类加载器的引用。但是数组的 Class 对象是由 Java 运行时环境创建的，通过 `Class.getClassLoader()` 方法返回的是数组元素的类加载器，若数组元素是基本类型，则返回 `null`，若类是由 `Bootstrap ClassLoader` 加载的话也是返回 `null`\n    ```java\n    public class Main {\n        public static void main(String[] args) {\n            // Object 类在 <java_home>/jre/lib/rt.jar 中，\n            // 由 Bootstrap ClassLoader 加载，由于该类加载器是由 native code 编写\n            // 所以输出为 null\n            Object[] objects = new Object[5];\n            System.out.println();\n            System.out.println(objects.getClass().getClassLoader());\n\n            // ZipFileAttributes 类在 <java_home>/jre/lib/ext/zipfs.jar 中，\n            // 由 Extension ClassLoader 加载，\n            // 输出为  sun.misc.Launcher$ExtClassLoader@4b67cf4d\n            ZipFileAttributes[] attributes = new ZipFileAttributes[5];\n            System.out.println();\n            System.out.println(attributes.getClass().getClassLoader());\n\n            // Main 类是自定义的类，\n            // 默认由 System ClassLoader 加载，\n            // 输出为 sun.misc.Launcher$AppClassLoader@18b4aac2\n            Main[] array = new Main[5];\n            array[0] = new Main();\n            System.out.println();\n            System.out.println(array.getClass().getClassLoader());\n        }\n    }\n    ```\n- `ClassLoader` 默认支持并行加载，但是其子类必须调用 `ClassLoader.registerAsParallelCapable()` 来启用并行加载\n- 一般来说,JVM 从本地文件系统加载类的行为是与平台有关的。\n- `defineClass()` 方法可以将字节流转换成一个 `Class` 对象。然后调用 `Class.newInstance()` 来创建类的实例\n\n### `java.security.SecureClassLoader`\n\n增加了一层权限验证，因为关注点不在安全，所以暂不讨论。\n\n### `java.net.URLClassLoader`\n\n该类加载器用来加载 URL 指定的 JAR 文件或目录中的类和资源，以 `/` 结尾的 URL 认为是目录，否则认为是 JAR 文件。\n\n```java\n// 尝试通过 URLClassLoader 来加载桌面下的 Test 类。\npublic class Main {\n    public static void main(String[] args) {\n        try {\n            URL[] urls = new URL[1];\n            URLStreamHandler streamHandler = null;\n            File classPath = new File(\"/home/chen/Desktop/\");\n            String repository = (new URL(\"file\", null,\n                    classPath.getCanonicalPath() + File.separator))\n                    .toString();\n            urls[0] = new URL(null, repository, streamHandler);\n\n            ClassLoader loader = new URLClassLoader(urls);\n\n            Class testClass = loader.loadClass(\"Test\");\n\n            // output:  java.net.URLClassLoader@7f31245a\n            System.out.println(testClass.getClassLoader());\n        } catch (MalformedURLException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } catch (ClassNotFoundException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n## Tomcat 8.5.15 class loading Mechanism\n\n![](../res/tomcat-classloader.png)\n\nTomcat 使用正统的类加载机制(双亲委派),但部分地方做了改动。\n\n- `Bootstrap classLoader` 和 `Extension classLoader` 的作用不变\n- `System classLoader` 正常情况下加载的是 `CLASSPATH` 下的类，但是 Tomcat 的启动脚本并未使用该变量，而是从以下仓库下加载类：\n\n    1. `$CATALINA_HOME/bin/bootstrap.jar` 包含了 Tomcat 的启动类。在该启动类中创建了 `Common classLoader`、`Catalina classLoader`、`shared classLoader`。因为 `$CATALINA_BASE/conf/catalina.properties` 中只对 `common.loader` 属性做了定义，`server.loader` 和 `shared.loader` 属性为空，所以默认情况下，这三个 classLoader 都是 `CommonLoader`。具体的代码逻辑可以查阅 `org.apache.catalina.startup.Bootstrap` 类的 `initClassLoaders()` 方法和 `createClassLoader()` 方法。\n    1. `$CATALINA_BASE/bin/tomcat-juli.jar` 包含了 Tomcat 日志模块所需要的实现类\n    1. `$CATALINA_HOME/bin/commons-daemon.jar`\n- `Common classLoader` 是位于 Tomcat 应用服务器顶层的公用类加载器。由其加载的类可以由 Tomcat 自身类和所有应用程序使用。扫描路径由 `$CATALINA_BASE/conf/catalina.properties` 文件中的 `common.loader` 属性定义。默认是 `$CATALINA_HOME/lib`.\n- `catalina classLoader` 用于加载服务器内部可见类，这些类应用程序不能访问。\n- `shared classLoader` 用于加载应用程序共享类，这些类服务器不会依赖。\n- `Webapp classLoader` 。每个应用程序都会有一个独一无二的 `webapp classloader`，他用来加载本应用程序 `/WEB-INF/classes` 和 `/WEB-INF/lib` 下的类。\n\n特别的：\n\n`Webapp classLoader` 的默认行为会与正常的双亲委派模式不同：\n\n1. 从 `Bootstrap classloader` 加载\n1. 若没有，从 `/WEB-INF/classes` 加载\n1. 若没有，从 `/WEB-INF/lib/*.jar` 加载\n1. 若没有，则依次从 `System`、`Common`、`shared` 加载（该步骤使用双亲委派）\n\n当然了，我们也可以通过配置来使 `Webapp classLoader` 严格按照双亲委派模式加载类：\n\n1. 通过在工程的 `META-INF/context.xml`（和 `WEB-INF/classes` 在同一目录下） 配置文件中添加 `<Loader delegate=\"true\"/>`\n1. 因为 `Webapp classLoader` 的实现类是 `org.apache.catalina.loader.WebappLoader`，他有一个属性叫 `delegate`， 用来控制类加载器的加载行为，默认为 `false`，我们可以使用 `set` 方法，将其设为 `true` 来启用严格双亲委派加载模式。\n\n严格双亲委派模式加载步骤：\n\n1. 从 `Bootstrap classloader` 加载\n1. 若没有，则依次从 `System`、`Common`、`shared` 加载\n1. 若没有，从 `/WEB-INF/classes` 加载\n1. 若没有，从 `/WEB-INF/lib/*.jar` 加载\n\n## Reference\n\n1. [The Java Class Loading Mechanism](https://docs.oracle.com/javase/tutorial/ext/basics/load.html)\n1. [Java Classloader](https://en.wikipedia.org/wiki/Java_Classloader)\n1. [Class Loader HOW-TO - Apache Tomcat 8](https://tomcat.apache.org/tomcat-8.5-doc/class-loader-howto.html)\n1. [《Tomcat 架构解析》]()\n1. [《深入理解 Java 虚拟机》]()\n','Java',1009,'2023-05-13 22:22:58'),(1012,'Spring bean 的生命周期','## 概述\n\n![Spring bean 生命周期](http://image.rainstorm.vip/blog/spring/spring-bean-lifecycle.png)\n\n1. 注入属性\n2. `Aware` 的 setter 方法注入资源\n3. `BeanPostProcessor` 进行初始化前后的处理（`BeanPostProcessor`实现类不能处理 `BeanPostProcessor`实现类）\n4. `@PostConstruct`\n5. `@PreDestroy`\n\n## 测试类\n\n在 [boot-init](https://github.com/c-rainstorm/boot-init) 项目中, `BeanLifeCycleAllInOne`,`AfterBeanInitial`\n\n```java\n@Slf4j\n@Component\npublic class BeanLifeCycleAllInOne implements BeanNameAware, ApplicationContextAware, BeanFactoryAware, EnvironmentAware, ResourceLoaderAware {\n\n    @Override\n    public void setBeanName(String name) {\n        log.info(\"BeanNameAware.setBeanName -- {}\", name);\n    }\n\n    @Override\n    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {\n        log.info(\"ApplicationContextAware.setApplicationContext\");\n    }\n\n\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException {\n        log.info(\"BeanFactoryAware.setBeanFactory\");\n    }\n\n    @Override\n    public void setEnvironment(Environment environment) {\n        log.info(\"EnvironmentAware.setEnvironment\");\n    }\n\n\n    @Override\n    public void setResourceLoader(ResourceLoader resourceLoader) {\n        log.info(\"ResourceLoaderAware.setResourceLoader\");\n    }\n\n    @PostConstruct\n    public void postConstruct() {\n        log.info(\"BeanLifeCycleAllInOne.postConstruct\");\n    }\n\n    @PreDestroy\n    public void preDestroy() {\n        log.info(\"BeanLifeCycleAllInOne.preDestroy\");\n    }\n}\n```\n\n```java\n@Slf4j\n@Component\npublic class AfterBeanInitial implements BeanPostProcessor {\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {\n        if (BeanLifeCycleAllInOne.class.getSimpleName().equalsIgnoreCase(beanName)) {\n            log.info(\"AfterBeanInitial.postProcessBeforeInitialization -- {}\", beanName);\n        }\n        return bean;\n    }\n\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {\n        if (BeanLifeCycleAllInOne.class.getSimpleName().equalsIgnoreCase(beanName)) {\n            log.info(\"AfterBeanInitial.postProcessAfterInitialization -- {}\", beanName);\n        }\n        return bean;\n    }\n}\n\n```\n\n## 测试输出\n\n```log\n2019-09-01 11:05:36.426  INFO 53094 --- [           main] m.r.b.l.bean.BeanLifeCycleAllInOne       : BeanNameAware.setBeanName -- beanLifeCycleAllInOne\n2019-09-01 11:05:36.426  INFO 53094 --- [           main] m.r.b.l.bean.BeanLifeCycleAllInOne       : BeanFactoryAware.setBeanFactory\n2019-09-01 11:05:36.426  INFO 53094 --- [           main] m.r.b.l.bean.BeanLifeCycleAllInOne       : EnvironmentAware.setEnvironment\n2019-09-01 11:05:36.426  INFO 53094 --- [           main] m.r.b.l.bean.BeanLifeCycleAllInOne       : ResourceLoaderAware.setResourceLoader\n2019-09-01 11:05:36.426  INFO 53094 --- [           main] m.r.b.l.bean.BeanLifeCycleAllInOne       : ApplicationContextAware.setApplicationContext\n2019-09-01 11:05:36.426  INFO 53094 --- [           main] m.r.b.lifecycle.bean.AfterBeanInitial    : AfterBeanInitial.postProcessBeforeInitialization -- beanLifeCycleAllInOne\n2019-09-01 11:05:36.426  INFO 53094 --- [           main] m.r.b.l.bean.BeanLifeCycleAllInOne       : BeanLifeCycleAllInOne.postConstruct\n2019-09-01 11:05:36.427  INFO 53094 --- [           main] m.r.b.lifecycle.bean.AfterBeanInitial    : AfterBeanInitial.postProcessAfterInitialization -- beanLifeCycleAllInOne\n\n...\n\n2019-09-01 11:06:57.845  INFO 53094 --- [      Thread-16] m.r.b.l.bean.BeanLifeCycleAllInOne       : BeanLifeCycleAllInOne.preDestroy\n```\n\n## 参考\n\n1. [ Java 程序员必备的一些流程图 -  芋道源码](https://mp.weixin.qq.com/s/8D4OXsU7CoSHF68LtaF2YA)\n1. [Interface Aware](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/Aware.html)\n','Spring',1009,'2023-05-13 23:44:58'),(1013,'Effective Java 学习笔记','## 第三章 对所有方法都通用的方法\n\n### `equals()`\n\n当类为值类（以类中保存的值来区别两个实例）时（枚举例外），需要重写 `equals()` 和 `hashCode()` 方法。\n\n重写 `equals()` 需要遵守的约定：\n\n1. 非空。`x != null`\n1. 自反。`x.equals(x) == true`\n1. 对称。`if(x.equals(y)) y.equals(x)`\n1. 传递。`if(x.equals(y) && y.equals(z)) x.equals(z)`\n1. 一致。 只要对象不变，每次调用必须能返回相同的结果。\n\nTips：\n- 增加值组件时使用符合而不是继承。\n```java\npublic class Point {\n    private final int x;\n    private final int y;\n\n    public Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || !(o instanceof Point)) {\n            return false;\n        }\n\n        Point point = (Point) o;\n        return x == point.x && y == point.y;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = x;\n        result = 31 * result + y;\n        return result;\n    }\n}\n\npublic class ColorPoint {\n    private final Point point;\n    private final Color color;\n\n    public ColorPoint(Point point, Color color) {\n        this.point = point;\n        this.color = color;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || !(o instanceof ColorPoint)) {\n            return false;\n        }\n\n        ColorPoint that = (ColorPoint) o;\n        if (point != null ? !point.equals(that.point) : that.point != null) {\n            return false;\n        }\n        return color != null ? color.equals(that.color) : that.color == null;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = point != null ? point.hashCode() : 0;\n        result = 31 * result + (color != null ? color.hashCode() : 0);\n        return result;\n    }\n}\n```\n- 对于 `float` 和 `double` 类型的值进行特殊处理 `Float.compare(f1, f2)`\n- 域的比较顺序有可能会影响性能，所以应先比较最有可能不同的域及开销最低的域。\n- 总是要覆盖 `hashCode()` 方法。\n\n### `hashCode()`\n\n约定：\n\n1. 在应用程序执行过程中，只要 `equals()` 方法未更改，同一个对象调用 `hashCode()` 返回结果应该一致。\n1. `if(x.equals(y)) x.hashCode() == y.hashCode();`\n\n实现约定:\n\n1. 将一个非 0 常量赋给 `result`。\n1. 计算关键域的 hashCode\n    - `boolean` --> `field ? 1 : 0;`\n    - `Byte | char | short | int` --> `(int)field`\n    - `long` --> `(int)(field ^ (field >>> 32))`\n    - `float` --> `Float.floatToIntBits(field)`\n    - `double` --> `Double.doubleToLongBits(field)` --> (long --> int)\n    - 对象引用 --> 直接调用 `hashCode()`\n    - 数组 --> `Arrays.hashCode()`;\n1. `result = 31 * result + hashCode;`\n1. 检验相等实例是否有相同 hashCode。\n\n```java\npublic class PhoneNumber {\n    private final short areaCode;\n    private final short prefix;\n    private final short lineNumber;\n\n    public PhoneNumber(short areaCode, short prefix, short lineNumber) {\n        rangeCheck(areaCode, 999, \"area code\");\n        rangeCheck(prefix, 999, \"prefix\");\n        rangeCheck(lineNumber, 9999, \"lineNumber\");\n        this.areaCode = areaCode;\n        this.prefix = prefix;\n        this.lineNumber = lineNumber;\n    }\n\n    private void rangeCheck(int arg, int max, String name) {\n        if(arg < 0 || arg > max){\n            new IllegalArgumentException(name + \": \" + arg);\n        }\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || !(o instanceof PhoneNumber)) {\n            return false;\n        }\n\n        PhoneNumber that = (PhoneNumber) o;\n        return lineNumber == that.lineNumber\n                && areaCode == that.areaCode\n                && prefix == that.prefix;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = (int) areaCode;\n        result = 31 * result + (int) prefix;\n        result = 31 * result + (int) lineNumber;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"PhoneNumber{\" +\n                \"areaCode=\" + areaCode +\n                \", prefix=\" + prefix +\n                \", lineNumber=\" + lineNumber +\n                \'}\';\n    }\n}\n```\n\nTips:\n\n1. 删除冗余域。\n1. 计算 hashCode 开销较大时，可以将其缓存到类内部。创建时计算或首次调用 `hashCode()` 时计算。\n\n## 第六章 枚举和注解\n\n1. 使用 `enum` 代替 int 常量\n1. 用实例域代替序数。\n    - 将特定枚举常量关联到特定的 int 值。\n1. 使用 `EnumSet` 代替位域\n    - 位域：使用或运算将多个常量合并到一个集合中。`text.applyStyles(STYLE_BOLD | STYLE_ITALIC)`\n    - `text.applyStyles(EnumSet.of(Style.BOLD, Style.ITALIC))`\n1. 使用 `EnumMap` 代替序数索引\n    - `Map<Herb.Type, Set<Herb>> herbsByType = new EnumMap<Herb.Type, Set<Herb>>(Herb.Type.class);`\n    - 多维：`EnumMap<..., EnumMap<...>>`\n\n## 第七章 方法\n\n1. 检查参数有效性\n    - `public` 方法使用异常\n    - `private` 方法使用断言\n1. 必要时进行保护性拷贝\n    - getXXX()\n    - setXXX()\n    - constructor\n1. 谨慎设计方法签名\n    - 命名方式要统一\n    - 参数不宜超过 3 个。可以通过创建对象来传递多个参数\n    - 参数类型优先使用接口\n1. 慎用重载\n    - 重载方法是在编译期确定的（静态绑定）\n1. 慎用可变参数\n1. 返回 0 长度的数组或集合，而不是 `null`\n1. 为所有导出的 API 元素编写文档注释\n    - [how to write doc comments](http://www.oracle.com/technetwork/articles/java/index-137868.html)\n\n\n## 第八章 通用程序设计\n\n1. 将局部变量的作用域最小化\n    - 第一次使用时声明。\n    - `for-each > for > while`\n1. 对含有一组元素的数据结构，实现 `Iterable` 接口\n1. 使用最合适的类型来存储数据\n1. 使用 `StringBuilder` 来连接字符串\n1. 通过接口引用对象（面向接口编程）\n','Java',4,'2023-05-13 23:46:58'),(1014,'JavaPoet','`JavaPoet` 是一个用于生成 `.Java` 源文件的Java API。在执行注释处理或与元数据文件（如数据库模式、协议格式）交互等操作时，源文件生成非常有用。通过生成代码，您无需编写样板文件，同时还可以为元数据保留唯一的真实源。\n\n- [JavaPoet](#javapoet)\n  - [Example](#example)\n    - [Code & Control Flow](#code--control-flow)\n    - [$L for Literals](#l-for-literals)\n    - [$S for Strings](#s-for-strings)\n    - [$T for Types](#t-for-types)\n      - [Import static](#import-static)\n    - [$N for Names](#n-for-names)\n    - [Code block format strings](#code-block-format-strings)\n      - [Relative Arguments](#relative-arguments)\n      - [Positional Arguments](#positional-arguments)\n      - [Named Arguments](#named-arguments)\n    - [Methods](#methods)\n    - [Constructors](#constructors)\n    - [Parameters](#parameters)\n    - [Fields](#fields)\n    - [Interfaces](#interfaces)\n    - [Enums](#enums)\n    - [Anonymous Inner Classes](#anonymous-inner-classes)\n    - [Annotations](#annotations)\n    - [Javadoc](#javadoc)\n  - [Download](#download)\n  - [License](#license)\n  - [JavaWriter](#javawriter)\n\n## Example\n\n这里有一个（无聊的）`helloworld` 类：\n\n```java\npackage com.example.helloworld;\n\npublic final class HelloWorld {\n  public static void main(String[] args) {\n    System.out.println(\"Hello, JavaPoet!\");\n  }\n}\n```\n\n这是用JavaPoet生成它的（激动人心的）代码：\n\n```java\nMethodSpec main = MethodSpec.methodBuilder(\"main\")\n    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n    .returns(void.class)\n    .addParameter(String[].class, \"args\")\n    .addStatement(\"$T.out.println($S)\", System.class, \"Hello, JavaPoet!\")\n    .build();\n\nTypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n    .addMethod(main)\n    .build();\n\nJavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n    .build();\n\njavaFile.writeTo(System.out);\n```\n\n为了声明main方法，我们创建了一个使用修饰符配置的 `MethodSpec` `main`，返回类型，参数和代码声明。我们将 main 方法添加到 `HelloWorld` 类中，然后添加到 `HelloWorld.java` 文件中。\n\n在例子中，我们将文件写入 `System.out`，但我们也可以将其作为字符串获取（`JavaFile.toString`）或将其写入文件系统（`JavaFile.writeTo`）。\n\n[Javadoc][javadoc] 列出了完整的 JavaPoet API，我们将在下面进行探讨。\n\n### Code & Control Flow\n\nJavaPoet 的大多数 API 使用普通的老式不可变 Java对象。还有构建器，方法链和可变参使 API 便于使用。JavaPoet 提供了用于类和接口（`TypeSpec`）的模型，字段（`FieldSpec`），方法和构造函数（`MethodSpec`），参数（`ParameterSpec`）和\n注释（`AnnotationSpec`）。\n\n方法体未被建模，JavaPoet 使用字符串作为代码块：\n\n```java\nMethodSpec main = MethodSpec.methodBuilder(\"main\")\n    .addCode(\"\"\n        + \"int total = 0;\\n\"\n        + \"for (int i = 0; i < 10; i++) {\\n\"\n        + \"  total += i;\\n\"\n        + \"}\\n\")\n    .build();\n```\n\n生成：\n\n```java\nvoid main() {\n  int total = 0;\n  for (int i = 0; i < 10; i++) {\n    total += i;\n  }\n}\n```\n\n手动分号，换行和缩进非常繁琐，因此 JavaPoet 提供了API使它更容易。有一个 `addStatement`，它处理分号和换行符，并且 `beginControlFlow` + `endControlFlow（）` 一起用于花括+换行符+缩进：\n\n```java\nMethodSpec main = MethodSpec.methodBuilder(\"main\")\n    .addStatement(\"int total = 0\")\n    .beginControlFlow(\"for (int i = 0; i < 10; i++)\")\n    .addStatement(\"total += i\")\n    .endControlFlow()\n    .build();\n```\n\n这个例子很蹩脚，因为生成的代码是恒定的！假设不只是将0加到10，我们要使操作和范围可配置。这是一个生成方法的方法：\n\n```java\nprivate MethodSpec computeRange(String name, int from, int to, String op) {\n  return MethodSpec.methodBuilder(name)\n      .returns(int.class)\n      .addStatement(\"int result = 1\")\n      .beginControlFlow(\"for (int i = \" + from + \"; i < \" + to + \"; i++)\")\n      .addStatement(\"result = result \" + op + \" i\")\n      .endControlFlow()\n      .addStatement(\"return result\")\n      .build();\n}\n```\n\n下面就是我们调用这个时得到的 `computeRange(\"multiply10to20\", 10, 20, \"*\")`:\n\n```java\nint multiply10to20() {\n  int result = 1;\n  for (int i = 10; i < 20; i++) {\n    result = result * i;\n  }\n  return result;\n}\n```\n\n方法生成方法！而且由于JavaPoet生成源代码而不是字节码，所以您可以通读它以确保它是正确的。\n\n某些控制流语句，例如 `if/else`，可能具有无限的控制流可能性。您可以使用 `nextControlFlow（）` 处理这些选项：\n\n```java\nMethodSpec main = MethodSpec.methodBuilder(\"main\")\n    .addStatement(\"long now = $T.currentTimeMillis()\", System.class)\n    .beginControlFlow(\"if ($T.currentTimeMillis() < now)\", System.class)\n    .addStatement(\"$T.out.println($S)\", System.class, \"Time travelling, woo hoo!\")\n    .nextControlFlow(\"else if ($T.currentTimeMillis() == now)\", System.class)\n    .addStatement(\"$T.out.println($S)\", System.class, \"Time stood still!\")\n    .nextControlFlow(\"else\")\n    .addStatement(\"$T.out.println($S)\", System.class, \"Ok, time still moving forward\")\n    .endControlFlow()\n    .build();\n```\n\n生成\n\n```java\nvoid main() {\n  long now = System.currentTimeMillis();\n  if (System.currentTimeMillis() < now)  {\n    System.out.println(\"Time travelling, woo hoo!\");\n  } else if (System.currentTimeMillis() == now) {\n    System.out.println(\"Time stood still!\");\n  } else {\n    System.out.println(\"Ok, time still moving forward\");\n  }\n}\n```\n\n使用 `try/catch` 捕获异常也是 `nextControlFlow` 的用例：\n\n```java\nMethodSpec main = MethodSpec.methodBuilder(\"main\")\n    .beginControlFlow(\"try\")\n    .addStatement(\"throw new Exception($S)\", \"Failed\")\n    .nextControlFlow(\"catch ($T e)\", Exception.class)\n    .addStatement(\"throw new $T(e)\", RuntimeException.class)\n    .endControlFlow()\n    .build();\n```\n\n生成\n\n```java\nvoid main() {\n  try {\n    throw new Exception(\"Failed\");\n  } catch (Exception e) {\n    throw new RuntimeException(e);\n  }\n}\n```\n\n### $L for Literals\n\n调用 `beginControlFlow` 和 `addStatement` 时的字符串连接令人分心。为了解决这个问题，JavaPoet 提供了一种语法，其灵感来自但不兼容 [`String.format`][formatter]。它接受 **`$L`** 以在输出中以实际值替换。这个就像 `Formatter` 的 `％s` 一样工作：\n\n```java\nprivate MethodSpec computeRange(String name, int from, int to, String op) {\n  return MethodSpec.methodBuilder(name)\n      .returns(int.class)\n      .addStatement(\"int result = 0\")\n      .beginControlFlow(\"for (int i = $L; i < $L; i++)\", from, to)\n      .addStatement(\"result = result $L i\", op)\n      .endControlFlow()\n      .addStatement(\"return result\")\n      .build();\n}\n```\n\n字面量直接转换到输出代码，没有转义。字面量的参数可能是字符串，基本类型和一些 JavaPoet 类型，如下所述。\n\n### $S for Strings\n\n当生成包含字符串的代码时，我们可以使用 **`$S`**。这是一个生成3种方法的程序，每种方法\n返回其自己的名称：\n\n```java\npublic static void main(String[] args) throws Exception {\n  TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n      .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n      .addMethod(whatsMyName(\"slimShady\"))\n      .addMethod(whatsMyName(\"eminem\"))\n      .addMethod(whatsMyName(\"marshallMathers\"))\n      .build();\n\n  JavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n      .build();\n\n  javaFile.writeTo(System.out);\n}\n\nprivate static MethodSpec whatsMyName(String name) {\n  return MethodSpec.methodBuilder(name)\n      .returns(String.class)\n      .addStatement(\"return $S\", name)\n      .build();\n}\n```\n\n这个例子中，`$S` 为我们保留了双引号。\n\n```java\npublic final class HelloWorld {\n  String slimShady() {\n    return \"slimShady\";\n  }\n\n  String eminem() {\n    return \"eminem\";\n  }\n\n  String marshallMathers() {\n    return \"marshallMathers\";\n  }\n}\n```\n\n### $T for Types\n\nJava 程序员喜欢我们的类型：它们使我们的代码更易于理解。它具有对类型的丰富内置支持，包括对 `import` 语句的生成。使用 **`$T`** 代表类型：\n\n```java\nMethodSpec today = MethodSpec.methodBuilder(\"today\")\n    .returns(Date.class)\n    .addStatement(\"return new $T()\", Date.class)\n    .build();\n\nTypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n    .addMethod(today)\n    .build();\n\nJavaFile javaFile = JavaFile.builder(\"com.example.helloworld\", helloWorld)\n    .build();\n\njavaFile.writeTo(System.out);\n```\n\nThat generates the following `.java` file, complete with the necessary `import`:\n\n```java\npackage com.example.helloworld;\n\nimport java.util.Date;\n\npublic final class HelloWorld {\n  Date today() {\n    return new Date();\n  }\n}\n```\n\n我们通过 `Date.class` 来引用一个在生成代码时可以使用的类。下面是一个类似的示例，但是此示例引用了一个不存在的类（尚未）：\n\n```java\nClassName hoverboard = ClassName.get(\"com.mattel\", \"Hoverboard\");\n\nMethodSpec today = MethodSpec.methodBuilder(\"tomorrow\")\n    .returns(hoverboard)\n    .addStatement(\"return new $T()\", hoverboard)\n    .build();\n```\n\n该尚不存在的类也将被导入：\n\n```java\npackage com.example.helloworld;\n\nimport com.mattel.Hoverboard;\n\npublic final class HelloWorld {\n  Hoverboard tomorrow() {\n    return new Hoverboard();\n  }\n}\n```\n\nClassName 类型非常重要，使用 JavaPoet 时经常需要它，它可以标识任何声明的类。声明的类型只是 Java 丰富的类型系统的开始：我们还具有数组，参数化类型，通配符类型和类型变量。 JavaPoet 具有用于构建以下每个类的类：\n\n```java\nClassName hoverboard = ClassName.get(\"com.mattel\", \"Hoverboard\");\nClassName list = ClassName.get(\"java.util\", \"List\");\nClassName arrayList = ClassName.get(\"java.util\", \"ArrayList\");\nTypeName listOfHoverboards = ParameterizedTypeName.get(list, hoverboard);\n\nMethodSpec beyond = MethodSpec.methodBuilder(\"beyond\")\n    .returns(listOfHoverboards)\n    .addStatement(\"$T result = new $T<>()\", listOfHoverboards, arrayList)\n    .addStatement(\"result.add(new $T())\", hoverboard)\n    .addStatement(\"result.add(new $T())\", hoverboard)\n    .addStatement(\"result.add(new $T())\", hoverboard)\n    .addStatement(\"return result\")\n    .build();\n```\n\nJavaPoet 将分解每种类型，并在可能的情况下导入其组件。\n\n```java\npackage com.example.helloworld;\n\nimport com.mattel.Hoverboard;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic final class HelloWorld {\n  List<Hoverboard> beyond() {\n    List<Hoverboard> result = new ArrayList<>();\n    result.add(new Hoverboard());\n    result.add(new Hoverboard());\n    result.add(new Hoverboard());\n    return result;\n  }\n}\n```\n\n#### Import static\n\nJavaPoet 支持`import static`。它通过显式收集类型成员名称来实现。让我们用一些静态糖增强前面的示例：\n\n```java\nClassName namedBoards = ClassName.get(\"com.mattel\", \"Hoverboard\", \"Boards\");\n\nMethodSpec beyond = MethodSpec.methodBuilder(\"beyond\")\n    .returns(listOfHoverboards)\n    .addStatement(\"$T result = new $T<>()\", listOfHoverboards, arrayList)\n    .addStatement(\"result.add($T.createNimbus(2000))\", hoverboard)\n    .addStatement(\"result.add($T.createNimbus(\\\"2001\\\"))\", hoverboard)\n    .addStatement(\"result.add($T.createNimbus($T.THUNDERBOLT))\", hoverboard, namedBoards)\n    .addStatement(\"$T.sort(result)\", Collections.class)\n    .addStatement(\"return result.isEmpty() ? $T.emptyList() : result\", Collections.class)\n    .build();\n\nTypeSpec hello = TypeSpec.classBuilder(\"HelloWorld\")\n    .addMethod(beyond)\n    .build();\n\nJavaFile.builder(\"com.example.helloworld\", hello)\n    .addStaticImport(hoverboard, \"createNimbus\")\n    .addStaticImport(namedBoards, \"*\")\n    .addStaticImport(Collections.class, \"*\")\n    .build();\n```\n\nJavaPoet 首先将您的 `import static` 块添加到文件中，并根据需要导入所有其他类型。\n\n```java\npackage com.example.helloworld;\n\nimport static com.mattel.Hoverboard.Boards.*;\nimport static com.mattel.Hoverboard.createNimbus;\nimport static java.util.Collections.*;\n\nimport com.mattel.Hoverboard;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass HelloWorld {\n  List<Hoverboard> beyond() {\n    List<Hoverboard> result = new ArrayList<>();\n    result.add(createNimbus(2000));\n    result.add(createNimbus(\"2001\"));\n    result.add(createNimbus(THUNDERBOLT));\n    sort(result);\n    return result.isEmpty() ? emptyList() : result;\n  }\n}\n```\n\n### $N for Names\n\n生成的代码通常是自引用的。使用 **`$N`** 来引用同一个类中另一个生成的方法。\n\n```java\npublic String byteToHex(int b) {\n  char[] result = new char[2];\n  result[0] = hexDigit((b >>> 4) & 0xf);\n  result[1] = hexDigit(b & 0xf);\n  return new String(result);\n}\n\npublic char hexDigit(int i) {\n  return (char) (i < 10 ? i + \'0\' : i - 10 + \'a\');\n}\n```\n\n当生成上面的代码时，我们使用 `$N` 将 `hexDigit()` 方法作为参数传递给 `byteToHex()` 方法：\n\n```java\nMethodSpec hexDigit = MethodSpec.methodBuilder(\"hexDigit\")\n    .addParameter(int.class, \"i\")\n    .returns(char.class)\n    .addStatement(\"return (char) (i < 10 ? i + \'0\' : i - 10 + \'a\')\")\n    .build();\n\nMethodSpec byteToHex = MethodSpec.methodBuilder(\"byteToHex\")\n    .addParameter(int.class, \"b\")\n    .returns(String.class)\n    .addStatement(\"char[] result = new char[2]\")\n    .addStatement(\"result[0] = $N((b >>> 4) & 0xf)\", hexDigit)\n    .addStatement(\"result[1] = $N(b & 0xf)\", hexDigit)\n    .addStatement(\"return new String(result)\")\n    .build();\n```\n\n### Code block format strings\n\n代码块可以通过几种方式为其占位符指定值。同一个代码块上的每个操作只能使用相同的样式。\n\n#### Relative Arguments\n\n将格式字符串中每个占位符的参数值传递给 `CodeBlock.add()`。在每个示例中，我们生成代码 `I ate 3 tacos`。\n\n```java\nCodeBlock.builder().add(\"I ate $L $L\", 3, \"tacos\")\n```\n\n#### Positional Arguments\n\n在格式字符串中的占位符前放置一个整数索引（从1开始），以指定要使用的参数。\n\n```java\nCodeBlock.builder().add(\"I ate $2L $1L\", \"tacos\", 3)\n```\n\n#### Named Arguments\n\n使用语法 `$argumentName:X`，其中 `X` 是格式字符，并使用包含格式字符串中所有参数键的映射调用`CodeBlock.addNamed()`。参数名称使用 “a-z”，“A-Z”，“0-9” 和 “_” 中的字符，并且必须以小写字母开头。\n\n```java\nMap<String, Object> map = new LinkedHashMap<>();\nmap.put(\"food\", \"tacos\");\nmap.put(\"count\", 3);\nCodeBlock.builder().addNamed(\"I ate $count:L $food:L\", map)\n```\n\n### Methods\n\n以上所有方法都有一个代码体。使用 `Modifiers.ABSTRACT` 来获得没有任何方法体的方法。仅当是抽象或接口时，这才合法。\n\n```java\nMethodSpec flux = MethodSpec.methodBuilder(\"flux\")\n    .addModifiers(Modifier.ABSTRACT, Modifier.PROTECTED)\n    .build();\n\nTypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n    .addMethod(flux)\n    .build();\n```\n\n生成\n\n```java\npublic abstract class HelloWorld {\n  protected abstract void flux();\n}\n```\n\n修饰符的使用需要依照Java语法使用。请注意，在指定修饰符时，JavaPoet使用 [`javax.lang.model.element.Modifier`][modifier], 这在Android上不可用。此限制仅适用于代码生成代码。生成代码随处运行：JVM，Android 和 GWT。\n\n方法还具有参数，异常，可变参数，Javadoc，注释，类型变量和返回类型。所有这些都可以使用 `MethodSpec.Builder` 来配置.\n\n### Constructors\n\n`MethodSpec` 有些不太恰当；它也可以用于构造函数：\n\n```java\nMethodSpec flux = MethodSpec.constructorBuilder()\n    .addModifiers(Modifier.PUBLIC)\n    .addParameter(String.class, \"greeting\")\n    .addStatement(\"this.$N = $N\", \"greeting\", \"greeting\")\n    .build();\n\nTypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n    .addModifiers(Modifier.PUBLIC)\n    .addField(String.class, \"greeting\", Modifier.PRIVATE, Modifier.FINAL)\n    .addMethod(flux)\n    .build();\n```\n\n生成：\n\n```java\npublic class HelloWorld {\n  private final String greeting;\n\n  public HelloWorld(String greeting) {\n    this.greeting = greeting;\n  }\n}\n```\n\n在大多数情况下，构造函数的工作原理与普通方法一样。生成代码时，JavaPoet 会将构造函数放在普通方法之前。\n\n### Parameters\n\n使用 `ParametersSpec.builder()` 或 `MethodSpec` 的 `addParameter` API 声明方法和构造函数上的参数：\n\n```java\nParameterSpec android = ParameterSpec.builder(String.class, \"android\")\n    .addModifiers(Modifier.FINAL)\n    .build();\n\nMethodSpec welcomeOverlords = MethodSpec.methodBuilder(\"welcomeOverlords\")\n    .addParameter(android)\n    .addParameter(String.class, \"robot\", Modifier.FINAL)\n    .build();\n```\n\n尽管上面的生成 `android` 和 `robot` 参数的代码不同，但是输出是相同的：\n\n```java\nvoid welcomeOverlords(final String android, final String robot) {\n}\n```\n\n当参数带有注释（例如，`@Nullable`）时，扩展的 `Builder` 形式是必需的。\n\n### Fields\n\n像参数一样，可以使用构建器或使用方便的辅助方法来创建字段：\n\n```java\nFieldSpec android = FieldSpec.builder(String.class, \"android\")\n    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n    .build();\n\nTypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n    .addModifiers(Modifier.PUBLIC)\n    .addField(android)\n    .addField(String.class, \"robot\", Modifier.PRIVATE, Modifier.FINAL)\n    .build();\n```\n\n生成\n\n```java\npublic class HelloWorld {\n  private final String android;\n\n  private final String robot;\n}\n```\n\n当字段具有 Javadoc，注释或字段初始化程序时，必须使用扩展的 `Builder` 格式。字段初始值设定项使用与上述代码块相同的 [`String.format()`][formatter] 类语法：\n\n```java\nFieldSpec android = FieldSpec.builder(String.class, \"android\")\n    .addModifiers(Modifier.PRIVATE, Modifier.FINAL)\n    .initializer(\"$S + $L\", \"Lollipop v.\", 5.0d)\n    .build();\n```\n\n生成\n\n```java\nprivate final String android = \"Lollipop v.\" + 5.0;\n```\n\n### Interfaces\n\n请注意，接口方法必须始终为 `PUBLIC ABSTRACT`，并且接口字段必须始终为 `PUBLIC STATIC FINAL`。定义接口时，必须使用以下修饰符：\n\n```java\nTypeSpec helloWorld = TypeSpec.interfaceBuilder(\"HelloWorld\")\n    .addModifiers(Modifier.PUBLIC)\n    .addField(FieldSpec.builder(String.class, \"ONLY_THING_THAT_IS_CONSTANT\")\n        .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)\n        .initializer(\"$S\", \"change\")\n        .build())\n    .addMethod(MethodSpec.methodBuilder(\"beep\")\n        .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n        .build())\n    .build();\n```\n\n但是，在生成代码时将省略这些修饰符。这些是默认值，因此我们不需要为了 `javac` 的利益就包括它们！\n\n```java\npublic interface HelloWorld {\n  String ONLY_THING_THAT_IS_CONSTANT = \"change\";\n\n  void beep();\n}\n```\n\n### Enums\n\n使用 `enumBuilder` 创建枚举类型，并为每个值添加 `addEnumConstant()`：\n\n```java\nTypeSpec helloWorld = TypeSpec.enumBuilder(\"Roshambo\")\n    .addModifiers(Modifier.PUBLIC)\n    .addEnumConstant(\"ROCK\")\n    .addEnumConstant(\"SCISSORS\")\n    .addEnumConstant(\"PAPER\")\n    .build();\n```\n\n生成\n\n```java\npublic enum Roshambo {\n  ROCK,\n\n  SCISSORS,\n\n  PAPER\n}\n```\n\n支持充血枚举，其中枚举值覆盖方法或调用超类构造函数。这是一个示例：\n\n```java\nTypeSpec helloWorld = TypeSpec.enumBuilder(\"Roshambo\")\n    .addModifiers(Modifier.PUBLIC)\n    .addEnumConstant(\"ROCK\", TypeSpec.anonymousClassBuilder(\"$S\", \"fist\")\n        .addMethod(MethodSpec.methodBuilder(\"toString\")\n            .addAnnotation(Override.class)\n            .addModifiers(Modifier.PUBLIC)\n            .addStatement(\"return $S\", \"avalanche!\")\n            .returns(String.class)\n            .build())\n        .build())\n    .addEnumConstant(\"SCISSORS\", TypeSpec.anonymousClassBuilder(\"$S\", \"peace\")\n        .build())\n    .addEnumConstant(\"PAPER\", TypeSpec.anonymousClassBuilder(\"$S\", \"flat\")\n        .build())\n    .addField(String.class, \"handsign\", Modifier.PRIVATE, Modifier.FINAL)\n    .addMethod(MethodSpec.constructorBuilder()\n        .addParameter(String.class, \"handsign\")\n        .addStatement(\"this.$N = $N\", \"handsign\", \"handsign\")\n        .build())\n    .build();\n```\n\nWhich generates this:\n\n```java\npublic enum Roshambo {\n  ROCK(\"fist\") {\n    @Override\n    public String toString() {\n      return \"avalanche!\";\n    }\n  },\n\n  SCISSORS(\"peace\"),\n\n  PAPER(\"flat\");\n\n  private final String handsign;\n\n  Roshambo(String handsign) {\n    this.handsign = handsign;\n  }\n}\n```\n\n### Anonymous Inner Classes\n\n在枚举代码中，我们使用了 `TypeSpec.anonymousInnerClass()`。匿名内部类也可以用在在代码块里。它们是可以用 `$L` 引用的值：\n\n```java\nTypeSpec comparator = TypeSpec.anonymousClassBuilder(\"\")\n    .addSuperinterface(ParameterizedTypeName.get(Comparator.class, String.class))\n    .addMethod(MethodSpec.methodBuilder(\"compare\")\n        .addAnnotation(Override.class)\n        .addModifiers(Modifier.PUBLIC)\n        .addParameter(String.class, \"a\")\n        .addParameter(String.class, \"b\")\n        .returns(int.class)\n        .addStatement(\"return $N.length() - $N.length()\", \"a\", \"b\")\n        .build())\n    .build();\n\nTypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n    .addMethod(MethodSpec.methodBuilder(\"sortByLength\")\n        .addParameter(ParameterizedTypeName.get(List.class, String.class), \"strings\")\n        .addStatement(\"$T.sort($N, $L)\", Collections.class, \"strings\", comparator)\n        .build())\n    .build();\n```\n\n这生成一个方法，该方法包含一个包含方法的类：\n\n```java\nvoid sortByLength(List<String> strings) {\n  Collections.sort(strings, new Comparator<String>() {\n    @Override\n    public int compare(String a, String b) {\n      return a.length() - b.length();\n    }\n  });\n}\n```\n\n定义匿名内部类的一个特别棘手的部分是超类构造函数的参数。在上面的代码中，我们传递了没有参数的空字符串：`TypeSpec.anonymousClassBuilder()`。要传递不同的参数，请使用JavaPoet 的代码块语法和逗号分隔参数。\n\n### Annotations\n\n简单的注解很容易：\n\n```java\nMethodSpec toString = MethodSpec.methodBuilder(\"toString\")\n    .addAnnotation(Override.class)\n    .returns(String.class)\n    .addModifiers(Modifier.PUBLIC)\n    .addStatement(\"return $S\", \"Hoverboard\")\n    .build();\n```\n\n它使用 `@Override` 注解生成此方法：\n\n```java\n  @Override\n  public String toString() {\n    return \"Hoverboard\";\n  }\n```\n\n使用 `AnnotationSpec.builder()` 设置注释的属性：\n\n```java\nMethodSpec logRecord = MethodSpec.methodBuilder(\"recordEvent\")\n    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n    .addAnnotation(AnnotationSpec.builder(Headers.class)\n        .addMember(\"accept\", \"$S\", \"application/json; charset=utf-8\")\n        .addMember(\"userAgent\", \"$S\", \"Square Cash\")\n        .build())\n    .addParameter(LogRecord.class, \"logRecord\")\n    .returns(LogReceipt.class)\n    .build();\n```\n\n生成带有 `accept` 和 `userAgent` 属性的注释：\n\n```java\n@Headers(\n    accept = \"application/json; charset=utf-8\",\n    userAgent = \"Square Cash\"\n)\nLogReceipt recordEvent(LogRecord logRecord);\n```\n\n当您喜欢时，注释值可以是注释本身。使用 `$L` 进行嵌入\n\n```java\nMethodSpec logRecord = MethodSpec.methodBuilder(\"recordEvent\")\n    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n    .addAnnotation(AnnotationSpec.builder(HeaderList.class)\n        .addMember(\"value\", \"$L\", AnnotationSpec.builder(Header.class)\n            .addMember(\"name\", \"$S\", \"Accept\")\n            .addMember(\"value\", \"$S\", \"application/json; charset=utf-8\")\n            .build())\n        .addMember(\"value\", \"$L\", AnnotationSpec.builder(Header.class)\n            .addMember(\"name\", \"$S\", \"User-Agent\")\n            .addMember(\"value\", \"$S\", \"Square Cash\")\n            .build())\n        .build())\n    .addParameter(LogRecord.class, \"logRecord\")\n    .returns(LogReceipt.class)\n    .build();\n```\n\n生成\n\n```java\n@HeaderList({\n    @Header(name = \"Accept\", value = \"application/json; charset=utf-8\"),\n    @Header(name = \"User-Agent\", value = \"Square Cash\")\n})\nLogReceipt recordEvent(LogRecord logRecord);\n```\n\n请注意，您可以使用相同的属性名称多次调用 `addMember()` 来填充该属性的值列表。\n\n### Javadoc\n\n字段，方法和类型可以用Javadoc描述：\n\n```java\nMethodSpec dismiss = MethodSpec.methodBuilder(\"dismiss\")\n    .addJavadoc(\"Hides {@code message} from the caller\'s history. Other\\n\"\n        + \"participants in the conversation will continue to see the\\n\"\n        + \"message in their own history unless they also delete it.\\n\")\n    .addJavadoc(\"\\n\")\n    .addJavadoc(\"<p>Use {@link #delete($T)} to delete the entire\\n\"\n        + \"conversation for all participants.\\n\", Conversation.class)\n    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)\n    .addParameter(Message.class, \"message\")\n    .build();\n```\n\n生成\n\n```java\n  /**\n   * Hides {@code message} from the caller\'s history. Other\n   * participants in the conversation will continue to see the\n   * message in their own history unless they also delete it.\n   *\n   * <p>Use {@link #delete(Conversation)} to delete the entire\n   * conversation for all participants.\n   */\n  void dismiss(Message message);\n```\n\n在 Javadoc 中引用类型时，请使用 `$T` 以获取自动导入。\n\n## Download\n\nDownload [the latest .jar][dl] or depend via Maven:\n\n```xml\n<dependency>\n  <groupId>com.squareup</groupId>\n  <artifactId>javapoet</artifactId>\n  <version>1.12.1</version>\n</dependency>\n```\n\nor Gradle:\n\n```groovy\ncompile \'com.squareup:javapoet:1.12.1\'\n```\n\n开发版本的快照可在[Sonatype的 `snapshots` 存储库][snap]中获得。\n\n## License\n\nCopyright 2015 Square, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\n## JavaWriter\n\nJavaPoet是 [JavaWriter][javawriter] 的后继者。新项目应首选JavaPoet，因为它具有更强大的代码模型：它了解类型并可以自动管理导入。JavaPoet是也更适合合成：而不是流式传输.java文件的内容单次从上到下，文件可以组装为声明树。\n\nJavaWriter仍可在[GitHub][javawriter]和 [Maven Central][javawriter_maven]中使用。\n\n[dl]:https://search.maven.org/remote_content?g=com.squareup&a=javapoet&v=LATEST\n[snap]: https://oss.sonatype.org/content/repositories/snapshots/com/squareup/javapoet/\n[javadoc]: https://square.github.io/javapoet/1.x/javapoet/\n[javawriter]: https://github.com/square/javapoet/tree/javawriter_2\n[javawriter_maven]: https://search.maven.org/#artifactdetails%7Ccom.squareup%7Cjavawriter%7C2.5.1%7Cjar\n[formatter]: https://developer.android.com/reference/java/util/Formatter.html\n[modifier]: https://docs.oracle.com/javase/8/docs/api/javax/lang/model/element/Modifier.html\n','Java',5,'2023-05-19 13:29:42'),(1015,'JSR107中文版（非官方）','最近在学缓存这块，没找到现成的中文文档，翻译一份给大家。最终版有多个，这里翻译的是[JSR107 Specification 1.1.1 Maintenance Release - Google Doc](https://docs.google.com/document/d/1ijduF_tmHvBaUS7VBBU2ZN8_eEBiFaXXg9OI0_ZxCrA/edit?usp=sharing)。\n\n本文内容仅限于学习使用，为了便于理解，翻译并不是单词对汉语的直译，建议阅读时和英文原文进行对照。\n\n完结总评，有两点感觉：\n\n1. 感觉有点臃肿，对缓存的定义过于宽泛，从进程内缓存到跨进程缓存到分布式缓存，但截止目前，工作中真正用到的部分只有进程内缓存\n2. 管理部分基于 JMX，有点老旧\n\n我还是看看 Caffeine，感觉可能这个更好一点。\n\n## 引言\n\n本规范描述了 Java缓存API 的目标和功能。\n\nJava缓存API 为 Java 程序提供了可用于从缓存中创建，访问，更新和删除条目的统一抽象。\n\n### 概览\n\n缓存在提高应用程序性能和可伸缩性上非常有效。\n\n缓存在是将数据副本以低延迟能够获取的结构保存一段时间，以便于请求相同信息时能够更快响应。\n\n缓存适用于那些创建或访问代价比较高的应用。比如一个频繁访问的 JavaWeb Servlet 网页，里面包括多次数据库访问，网络请求，和比较耗时的计算任务；中间用到的数据可能是可以直接重用的，把这些信息缓存起来，下次访问时直接读取可以减少页面构建的时间。\n\nJava缓存API提供了一种使用缓存的通用方式，从而使开发者专注于应用本身的开发。本规范定义了缓存的术语、语义和响应的Java接口\n\n### 什么是缓存\n\n缓存在计算中无处不在。在应用程序设计领域中，它通常代表开发者使用内存或低延迟的数据结构来临时存储缓存数据的副本或引用，以便以后进行重用来减少重新访问或重新创建的成本。\n\n在 Java缓存API领域中，术语“缓存”代表的是Java开发者使用缓存组件临时缓存Java对象的技术。\n\n通常缓存的是数据库的数据，但这并不是必须的，任何创建或访问比较昂贵或耗时的数据都可以进行缓存，比如：\n\n1. Web服务调用的客户端缓存\n2. 昂贵的计算，例如渲染的图像\n3. 数据缓存\n4. servlet响应缓存\n5. 领域对象图（caching of domain object graphs）\n\n### 目标\n\nJava缓存AIP 的目标是：\n\n1. 为应用程序提供缓存功能，尤其是缓存Java对象的能力。\n2. 定义一套通用的缓存概念和设施。\n3. 减少Java开发人员采用缓存的学习成本。\n4. 最大化应用程序切换缓存实现的能力。\n5. 支持进程内和分布式缓存实现。\n6. 支持按值和（可选）按引用缓存Java对象。\n7. 参照 JSR-175 定义运行时缓存注解，以便开发者可以使用注解处理器来支持声明式缓存。\n\n### 非目标\n\nJava缓存API 无法解决的问题：\n\n1. 资源和内存限制配置。很多缓存实现都提供了约束运行时可使用资源的配置，但是这并不是本规范的内容。本规范只提供了一种标准机制使开发者去指定数据缓存的时长。\n2. 缓存数据的存储形式。本规范未指定缓存实现如何存储或表示缓存的数据。\n3. 管理。本规范并未规定如何管理缓存。仅定义了编程式配置缓存的机制和通过 JMX 来操作缓存统计信息的机制。\n4. 安全性。本规范未指定如何保​​护缓存内容或如何控制对缓存的访问和操作。\n5. 缓存和数据源数据同步。本规范未指定应用程序或缓存实现应如何使缓存和数据源数据保持一致。尽管开发者可以使用 `read-through` 和 `write-through` 技术，但是这些技术只能保证数据通过缓存更新数据源时的一致性，如果应用程序不经过缓存直接写数据源，此时缓存和数据源的数据一致性就无法保证。\n\n### Java SE 和 Java EE 支持\n\nJava缓存API兼容标准版和企业版（版本6或更高版本）的应用程序。缓存实现可以选择只在更高版本的Java上运行，可以支持使用 JavaEE 的应用，但是本规范并未定义如何实现。\n\n### 包名\n\n顶级包名是 `javax.cache`。\n\n### 可选特性\n\n本规范中的所有特性都是强制性必须实现的，但 `OptionalFeature` 枚举中列出的功能除外：\n\n`storeByReference`\n\n如果实现，则必须完全按照本规范中的描述来实现。\n\n开发者可以使用 `cachingProvider.isSupported(OptionalFeature feature)` 确定缓存提供程序已实现了哪些可选功能。\n\n一些可选功能仅在特定情况下才有意义。 例如，分布式缓存通常不支持 `storeByReference`。\n\n可选功能允许缓存实现不必支持所有功能，并且允许最终用户和框架发现支持的特性是什么，以便他们可以动态配置适当的用法。\n\n### 文档规范\n\n`Arial (11磅)` 字体用于该规范的正文。\n\n斜体 `Arial (11磅)` 字体用于包含非正文性信息的段落，例如描述典型用法的注释或使用说明性规范澄清文本的注释。\n\n`Courier New（11磅）` 字体用于代码。 Java代码，示例和示例数据片段也使用Courier New字体。 格式如下（10点字体）：\n\n```java\npackage com.example.hello;\npublic class Hello {\n    public static void main(String args[] {\n        System.out.println(“Hello Worlds”);\n    }\n}\n```\n\n另外，这些关键字‘MUST’, ‘MUST NOT’, ‘REQUIRED’, ‘SHALL’, ‘SHALL NOT’, ‘SHOULD’, ‘SHOULD NOT’, ‘RECOMMENDED’, ‘MAY’, and ‘OPTIONAL’ 应按照[RFC 2119](https://tools.ietf.org/html/rfc2119) 中的说明进行解释。\n\n### 专家组成员\n\nThis speciﬁcation is being developed under the Java Community Process v2.9.\n\nLeading experts throughout the entire Java community have come together to build this Java caching standard.\n\nThe following are expert group members:\n\n- Greg Luck\n- Brian Oliver, Oracle\n- Cameron Purdy, Oracle\n- Galder Zamarreño, Red Hat\n- Nikita Ivanov, Grid Gain\n- Chris Berry\n- Jon Stevens\n- Rick Hightower\n- Ben Cotton, Credit Suisse\n- David Mossakowski, Citigroup\n- Bongjae Chang\n- Steve Millidge\n- Gabe Montero, IBM\n- Brian Martin, IBM\n- Eric Dalquist\n- Pete Muir, Red Hat, Inc.\n- William Newport, Goldman Sachs\n- Ryan Gardner, Dealer.com\n- Chris Dennis, Terracotta, Inc.\n- Toshio Takeda, Fujitsu\n- Chang Paek, TmaxSoft, Inc.\n\nThe following are official observers:\n\n- Linda DeMichiel, Oracle\n- Bill Shannon, Oracle\n- Jens Wilke (Jens contributed very heavily to the 1.1 MR)\n\n### 致谢\n\nDuring the course of the JSR we have received many excellent suggestions on the JSR mailing lists. Thanks to those people.\n\n## 基本原理\n\n### 核心概念\n\nJava Caching API定义了五个核心接口：`CachingProvider`，`CacheManager`，`Cache`，`Entry`和`ExpiryPolicy`。\n\n`CachingProvider` 用于创建，配置，获取，管理和控制零个或多个`CacheManager` 。应用程序可以在运行时访问和使用零个或多个`CachingProvider`。\n\n`CacheManager` 用于创建，配置，获取，管理和控制零个或更多个唯一命名的 `Cache`。 `CacheManager` 由单个 `CachingProvider` 拥有。\n\n`Cache`是一种类似于 `Map` 的数据结构，它允许临时存储基于键的值。`Cache` 由单个`CacheManager` 拥有。\n\n`Entry` 是由 `Cache` 存储的单个键值对。\n\n`Cache` 中的每个 `Entry` 都有一个有效时间，在此期间可以进行访问，更新和删除操作。一旦超过此持续时间，就称该条目已过期。一旦过期，条目将不再可用于访问，更新或删除，就好像它们从未存在于缓存中一样。使用 `ExpiryPolicy` 设置到期时间。\n\n![jsr107-core-interface-class-diagram](http://image.rainstorm.vip/blog/jsr107-core-interface-class-diagram.png)\n\n[图片源文件](../../res/jsr107-core-interface-class-diagram.pu)\n\n### 按值存储和按引用存储\n\n`Cache` 存储 `Entry` 的方式有两种，一个是按值存储，一个是按引用存储\n\n`javax.cache.configuration.MutableConfiguration#isStoreByValue` 字段定义了是否按值存储，可以在创建 `Cache` 时进行配置。默认是 `true` 代表安值存储\n\n按值存储：将应用程序提供的键和值存储缓存之前先对其进行复制，访问时从缓存中返回条目的新副本。复制条目（存储在缓存中）以及从缓存返回时再次复制条目的目的是允许应用程序继续更改键和值的状态，而不会对缓存所保存的条目产生副作用。\n\nJava序列化是实现键和值副本的一种简单方法。\n\n为了确保实现之间的可移植性，建议在使用按值存储时，自定义键和值类实现并采用标准Java序列化。\n\n实现用来复制键和条目值的机制可以是可自定义的。但是，为了确保应用程序的可移植性，实现必须允许应用程序仅使用标准Java序列化。实现不得强制应用程序采用非标准Java序列化。\n\n按引用存储是一种可选方案，它代表 `Cache` 实现仅存储和返回对应用程序提供的键和值的引用，而不是按按值存储方法进行复制。如果应用程序稍后使用按引用存储的语义来更改提供给缓存的键或值，则那些从缓存访问条目的人将可以看到突变的副作用，而无需应用程序更新缓存。\n\n对于在Java堆上实现的缓存，按引用存储相对更快。\n\nTips:\n\n> Heap only: When using heap only caches, the default is by-reference unless you configure a Copier.\n>\n> Ehcache 3.8 仅使用堆存储层时，默认使用按引用存储，除非显式配置了一个 Copier\n>\n> https://www.ehcache.org/documentation/3.8/107.html\n\n```xml\n<default-copiers>\n    <copier type=\"me.rainstorm.demo.cache.domain.Person\">org.ehcache.impl.copy.SerializingCopier</copier>\n</default-copiers>\n```\n\n### 缓存与 `Map`\n\n缓存和 `Map` API 相似，下面简单描述主要的异同点\n\n相同点：\n\n1. 通过 key 进行存储和访问\n2. 每个 key 仅与一个值进行关联\n3. 可变对象作为 key 时需要特别注意，如果 key 发生了变化，且变化对 `equals` 方法有影响，此时缓存的行为是未定义的。\n4. 缓存使用相等性来判断给定的 key 或 value 是否已存在，自定义的类做为 key 或 value 时 推荐实现合适的 `Object.equals` 和 `Object.hashCode` 方法。\n\n不同点：\n\n1. 缓存键和值不能为null。\n   - 任何尝试为键或值使用null都会导致抛出NullPointerException\n2. 条目可能会过期。\n   - 确保条目不再对应用程序有效（因为它们不再被视为有效）的过程称为“到期”\n3. 条目可能会被驱逐。\n   - 缓存通常用于存储整个数据集经常使用的一小部分子集，当空间不够时就会按照一定策略进行驱逐条目。\n   - 当缓存超过资源限制时从缓存中删除条目的过程称为“逐出（eviction）”。当由于资源限制而从缓存中删除条目时，该条目被称为“被驱逐（evicted）”。\n   - 虽然规范没有定义缓存的容量，但是推荐缓存实现提供一种当达到容量限制时，结合适当的驱逐策略，来选择和驱逐条目的机制。例如：LRU逐出策略试图逐出最近最少使用的条目。\n   - 规格中未定义容量的一些原因是：\n     - 实现可以利用多层分层存储结构，从而定义每层的容量。在这种情况下，无法定义缓存的整体容量。\n     - 实现可以按字节而不是每个层上的条目数定义容量。\n     - 就内存而言，条目的相对成本与运行时条目实现的内部表示直接相关。\n4. 为了支持原子比较并交换（CAS）操作，自定义值类应提供 `Object.equals` 的适当实现。\n5. 实现可能要求键和值以某种方式可序列化。\n6. 缓存可以配置为使用按值存储或可选地使用按引用存储来控制条目的存储方式。\n7. 实现可以选择强制实施安全性限制。 如果发生违规，则必须抛出`SecurityException`。\n\n尽管建议这样做，但缓存实现调用由自定义键类定义的 `Object.hashCode` 或 `Object.equals` 方法并不是必须的。缓存实现可以自由优化，从而避免调用这些方法。\n\n由于本规范未定义对象等效性的概念，因此，依赖于缓存实现的等效性优化来确定自定义键类等效性的应用程序可能无法移植。\n\n### 一致性\n\n一致性指的是，当多个线程同时访问一个缓存时，保证并发修改的可见性是一致的。\n\nPS，这句话翻译的感觉不是特别好，放出原文。\n\n> Consistency refers to the behavior of caches and the guarantees that exist when concurrent cache mutation occur together with the visibility of the mutations when multiple threads are accessing a cache.\n\n所有缓存实现必须要支持默认一致性模型。\n\n#### 默认一致性\n\n使用默认的一致性模式时，大多数高速缓存操作在执行时，就好像缓存中的每个键都存在加锁机制一样。 当缓存操作获得对某个键的排他性读写锁时，对该键的所有后续操作都将阻塞，直至锁释放。 两个线程执行操作时，遵循 happen-before 原则（包括不同Java虚拟机中的线程）。\n\n可以理解为一个悲观锁，以加锁，修改，解锁来保证一致性。\n\n对于那些有返回值的缓存操作，返回的缓存值是最新的值，但是这个最新的值的定义，根据缓存实现的不同，可以选择操作前的值，也可以选择是操作后的值。\n\n这可以理解为没有保证一致性的无锁方法。ps：不理解这句话\n\n部分操作遵循不同的惯例，这些操作在条目的缓存值满足某种预期的状态时才进行修改。这些操作在多线程环境下好像共享一个锁，这个可以理解为是一种优化的加锁方式，这类加锁方式叫 CAS\n\n```java\nboolean putIfAbsent(K key, V value);\nboolean remove(K key, V oldValue);\nboolean replace(K key, V oldValue, V newValue);\nboolean replace(K key, V value);\nV getAndReplace(K key, V value);\n```\n\n想其他缓存操作一样，CAS 操作在写新值时也需要表现的像是获得了一个排它锁。\n\n在默认一致性下，尽管CAS方法可以允许更高级别的并发性，但它们将被非CAS方法所阻止。\n>As a result, in default consistency, while the CAS methods can allow a higher level of concurrency they will be held up by the non-CAS methods.\n\n下表显示了适用于每个Cache方法的默认一致性。\n\n|方法|默认一致性|\n|---|---|\n|`boolean containsKey(K key)`| 最新值|\n|`V get(K key)`| happen-before |\n|`Map<K,V> getAll(Collection<? extends K> keys)`|对里面的每个key，而不是整个集合|\n|`V getAndPut(K key, V value)`|happen-before|\n|`V getAndRemove(K key)`|happen-before|\n|`V getAndReplace(K key, V value)`|happen-before + CAS|\n|`CacheManager getCacheManager()`|N/A|\n|`CacheConfiguration getConfiguration()`|N/A|\n|`String getName()`|N/A|\n|`Iterator<Cache.Entry<K, V>> iterator()`|最新值|\n|`void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener listener)`|N/A|\n|`void put(K key, V value)`|happen-before|\n|`void putAll(Map<? extends K,? extends V> map)`|对里面的每个key，而不是整个集合|\n|`boolean putIfAbsent(K key, V value)`|happen-before + CAS|\n|`boolean remove(K key)`|happen-before|\n|`boolean remove(K key, V oldValue)`|happen-before + CAS|\n|`void removeAll()`|最新值|\n|`void removeAll(Set<? extends K> keys)`|happen-before + CAS|\n|`<T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments)entryProcessor);`|happen-before|\n|`<T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys,EntryProcessor<K, V, T> entryProcessor, Object... arguments);`|对里面的每个key，而不是整个集合|\n|`boolean replace(K key, V value)`|happen-before + CAS|\n|`boolean replace(K key, V oldValue, V newValue)`|happen-before + CAS|\n|`<T> T unwrap(Class<T> cls)`|N/A|\n\n#### 高级一致性模型\n\n具体实现可以自行拓展一致性模型。\n\n### 缓存拓扑\n\n尽管本规范并没有规定特定的缓存实现结构，但是显而易见的，缓存实体可以存储到当前进程本地和/或分布到多个进程。具体实现可以任意选择合适的结构。\n\n这个概念在规范有多中表现形式:\n\n- 大多数修改方法要么返回 `void` 要么返回一个低成本的值。比如 `java.util.Map` 提供了 `V put(K key, V value)`，但是 `javax.cache.Cache` 提供的是 `void put(K key, V value)`。返回类型成本更高的版本也有提供，比如 `V getAndPut(K key, V value)`，其中的返回值是旧值和 `Map` 相似。\n- 通过创建不假设实现将缓存数据放在进程内部的语义，`Configuration` 实现了 `Serializable` 接口已支持在网络中传输。开发者可以定义 `CacheEntryListener`、`ExpiryPolicy`、`CacheEntryFilter`、`CacheWriter` 和 `CacheLoader` 并将它们和 `Cache` 进行关联。为了支持分布式结构，开发者需要定义一个工场去创建它们，这个工厂需要实现 `Serializable` 接口。\n- 在整个规范中，对于那些可能很大的返回值和参数使用 `Iterable` 进行遍历。一个 `Cache` 可能很大以至于 key-set 不能完整的保存到可用内存中，并且网络也不好。`Cache`、`CacheEntryListener` 子接口上的监听器方法、`CacheLoader` 的批处理方法都使用 `Iterable` 接口。\n- `CacheEntryListener`,`ExpiryPolicy`,`CacheEntryFilter`,`CacheWriter`,`CacheLoader` 这些类在哪里实现，什么时间实例化，和执行本规范不做限制。（在分布式实现中，这些可以全部与数据存放在一起，而不是随网络传输）\n- `CachingProvider.getCacheManager(URI uri, ClassLoader classLoader)` 对特定的 `URI` 和 `ClassLoader` 来说有唯一的 `CacheManager`，这确保了实现能够实例化多个实例。\n\n### 执行上下文\n\n`EntryProcessor`, `CacheEntryListener`, `CacheLoader`, `CacheWriter` and `ExpiryPolicy` 的上下文是 `CacheManager` 这就意味着，在部署时，创建 `CacheManager` 的 `ClassLoader` 需要能够访问应用程序类。\n\n类的可用性这个目标如何实现可以由具体的实现自行定义。例如，在 Java EE 环境中，应用程序定义的上述类都包含在企业应用程序的 ear/war/jar 中。\n\n尽管上述类和应用程序类使用同一个 `ClassLoader`，从而获得直接访问所有资源的权限，但是，为了保证可移植性，上述自定义类应该仅用来尝试访问或更新缓存。\n\n在实现和部署环境中，上述自定义类可以利用一些实用技术比如依赖注入来允许直接访问应用程序和部署专用资源，但是并不需要实现去支持这个功能。\n\n### 可重入\n\n尽管此规范不限制开发人员在使用自定义 `EntryProcessor`，`CacheEntryListener`，`CacheLoader`，`CacheWriter` 和 `ExpiryPolicy` 时可能执行的操作，但缓存实现可能会限制这些接口的重入。 例如; 一个实现可能会限制 `EntryProcessor` 调用 `Cache` 上的方法或调用其他 `EntryProcessor` 的能力。 同样，实现可能会限制 `CacheLoader / CacheWriter` 访问缓存的能力。\n\n因此，强烈建议开发人员避免编写这些接口的可重入实现，因为这些实现可能不是可移植的。\n\n## 一个简单的例子\n\n### String.class,Interger.class\n\n这个简单例子穿件一个默认的 `CacheManager`，配置一个名叫 \"simpleCache\" 的缓存，使用 `String` 做 key，`Integer` 为 value，一个小时无访问过期，然后做了一些缓存操作\n\n```java\n//resolve a cache manager\nCachingProvider cachingProvider = Caching.getCachingProvider();\nCacheManager cacheManager = cachingProvider.getCacheManager();\n\n//configure the cache\nMutableConfiguration<String, Integer> config =\nnew MutableConfiguration<>()\n    .setTypes(String.class, Integer.class)\n    .setExpiryPolicyFactory(AccessedExpiryPolicy.factoryOf(ONE_HOUR))\n    .setStatisticsEnabled(true);\n\n//create the cache\nCache<String, Integer> cache = cacheManager.createCache(\"simpleCache\", config);\n\n//cache operations\nString key = \"key\";\nInteger value1 = 1;\ncache.put(\"key\", value1);\nInteger value2 = cache.get(key);\nassertEquals(value1, value2);\ncache.remove(key);\nassertNull(cache.get(key));\n```\n\n在上面的例子中，`CacheingProvider` 和 `CacheManager` 使用的都是默认的实现。除了上面的获取缓存的方法以外，还有下面一种\n\n```java\n//get the cache\nCache<String, Integer> cache = Caching.getCache(\"simpleCache\",\n    String.class, Integer.class);\n\n```\n\n## `CacheManager`\n\n`CacheManeger` 是 Java caching API 的核心概念。开发者通过 `CacheManager` 与 `Cache` 交互。\n\n`CacheManager` 提供以下能力：\n\n- 创建和配置有唯一名称的 `Cache`。\n- 通过缓存名获取 `Cache`。\n- 限定 `Cache` 的命名空间， 具有相同名称但源自不同缓存管理器的缓存被视为不同缓存。\n- 当不再需要缓存管理的时候关闭缓存。\n- 注销 `Cache` 和其中缓存的数据。\n- 如果需要，`Cache` 将使用 `ClassLoader` 加载所需的应用类。\n- 迭代当前被管理的 `Cache`。\n- 关闭 `CacheManager` 和其管理的 `Cache`。\n- 启用和禁用 `Cache` 统计数据收集。\n- 启用和禁用 `Cache` 的 JMX 管理。\n- 获取 `CachingProvider` 为 `CacheManager` 定义的属性。\n- 查询 `CachingProvider` 提供的能力和可选特性。\n\n`CacheManager` 的接口定义：\n\n```java\n\n/**\n * A {@link CacheManager} provides a means of establishing, configuring,\n * acquiring, closing and destroying uniquely named {@link Cache}s.\n * <p>\n * {@link Cache}s produced and owned by a {@link CacheManager} typically share\n * common infrastructure, for example, a common {@link ClassLoader} and\n * implementation specific {@link Properties}.\n * <p>\n * Implementations of {@link CacheManager} may additionally provide and share\n * external resources between the {@link Cache}s being managed, for example,\n * the content of the managed {@link Cache}s may be stored in the same cluster.\n * <p>\n * By default {@link CacheManager} instances are typically acquired through the\n * use of a {@link CachingProvider}.  Implementations however may additionally\n * provide other mechanisms to create, acquire, manage and configure\n * {@link CacheManager}s, including:\n * <ul>\n * <li>making use of {@link java.util.ServiceLoader}s,</li>\n * <li>permitting the use of the <code>new</code> operator to create a\n * concrete implementation, </li>\n * <li>providing the construction through the use of one or more\n * builders, and</li>\n * <li>through the use of dependency injection.</li>\n * </ul>\n * <p>\n * The default {@link CacheManager} however can always be acquired using the\n * default configured {@link CachingProvider} obtained by the {@link Caching}\n * class.  For example:\n * <pre><code>\n * CachingProvider provider = Caching.getCachingProvider();\n * CacheManager manager = provider.getCacheManager();\n * </code></pre>\n * <p>\n * Within a Java process {@link CacheManager}s and the {@link Cache}s they\n * manage are scoped and uniquely identified by a {@link URI},  the meaning of\n * which is implementation specific. To obtain the default {@link URI},\n * {@link ClassLoader} and {@link Properties} for an implementation, consult the\n * {@link CachingProvider} class.\n *\n *\n * @author Greg Luck\n * @author Yannis Cosmadopoulos\n * @author Brian Oliver\n * @see Caching\n * @see CachingProvider\n * @see Cache\n * @since 1.0\n *\n */\npublic interface CacheManager extends Closeable {\n\n  /**\n   * Get the {@link CachingProvider} that created and is responsible for\n   * the {@link CacheManager}.\n   *\n   * @return the CachingProvider or <code>null</code> if the {@link CacheManager}\n   *         was created without using a {@link CachingProvider}\n   */\n  CachingProvider getCachingProvider();\n\n  /**\n   * Get the URI of the {@link CacheManager}.\n   *\n   * @return the URI of the {@link CacheManager}\n   */\n  URI getURI();\n\n  /**\n   * Get the {@link ClassLoader} used by the {@link CacheManager}.\n   *\n   * @return  the {@link ClassLoader} used by the {@link CacheManager}\n   */\n  ClassLoader getClassLoader();\n\n  /**\n   * Get the {@link Properties} that were used to create this\n   * {@link CacheManager}.\n   * <p>\n   * Implementations are not required to re-configure the\n   * {@link CacheManager} should modifications to the returned\n   * {@link Properties} be made.\n   *\n   * @return the Properties used to create the {@link CacheManager}\n   */\n  Properties getProperties();\n\n  /**\n   * Creates a named {@link Cache} at runtime.\n   * <p>\n   * If a {@link Cache} with the specified name is known to the {@link\n   * CacheManager}, a CacheException is thrown.\n   * <p>\n   * If a {@link Cache} with the specified name is unknown the {@link\n   * CacheManager}, one is created according to the provided {@link Configuration}\n   * after which it becomes managed by the {@link CacheManager}.\n   * <p>\n   * Prior to a {@link Cache} being created, the provided {@link Configuration}s is\n   * validated within the context of the {@link CacheManager} properties and\n   * implementation.\n   * <p>\n   * Implementers should be aware that the {@link Configuration} may be used to\n   * configure other {@link Cache}s.\n   * <p>\n   * There\'s no requirement on the part of a developer to call this method for\n   * each {@link Cache} an application may use.  Implementations may support\n   * the use of declarative mechanisms to pre-configure {@link Cache}s, thus\n   * removing the requirement to configure them in an application.  In such\n   * circumstances a developer may simply call either the\n   * {@link #getCache(String)} or {@link #getCache(String, Class, Class)}\n   * methods to acquire a previously established or pre-configured {@link Cache}.\n   *\n   * @param <K> the type of key\n   * @param <V> the type of value\n   * @param <C> the type of the Configuration\n   * @param cacheName     the name of the {@link Cache}. Names should not use\n   *                      forward slashes(/) or colons(:), or start with\n   *                      java. or javax. These prefixes are reserved.\n   * @param configuration a {@link Configuration} for the {@link Cache}\n   * @throws IllegalStateException         if the {@link CacheManager}\n   *                                       {@link #isClosed()}\n   * @throws CacheException                if there was an error configuring the\n   *                                       {@link Cache}, which includes trying\n   *                                       to create a cache that already exists.\n   * @throws IllegalArgumentException      if the configuration is invalid\n   * @throws UnsupportedOperationException if the configuration specifies\n   *                                       an unsupported feature\n   * @throws NullPointerException          if the cache configuration or name\n   *                                       is null\n   * @throws SecurityException             when the operation could not be performed\n   *                                       due to the current security settings\n   */\n  <K, V, C extends Configuration<K, V>> Cache<K, V> createCache(String cacheName,\n                                                                C configuration)\n      throws IllegalArgumentException;\n\n\n  /**\n   * Looks up a managed {@link Cache} given its name.\n   * <p>\n   * Use this method to check runtime key and value types.\n   * <p>\n   * Use {@link #getCache(String)} where this check is not required.\n   * <p>\n   * Implementations must ensure that the key and value types are the same as\n   * those configured for the {@link Cache} prior to returning from this method.\n   * <p>\n   * Implementations may further perform type checking on mutative cache operations\n   * and throw a {@link ClassCastException} if these checks fail.\n   * <p>\n   * Implementations that support declarative mechanisms for pre-configuring\n   * {@link Cache}s may return a pre-configured {@link Cache} instead of\n   * <code>null</code>.\n   *\n   * @param <K> the type of key\n   * @param <V> the type of value\n   * @param cacheName the name of the managed {@link Cache} to acquire\n   * @param keyType   the expected {@link Class} of the key\n   * @param valueType the expected {@link Class} of the value\n   * @return the Cache or null if it does exist or can\'t be pre-configured\n   * @throws IllegalStateException    if the {@link CacheManager}\n   *                                  is {@link #isClosed()}\n   * @throws ClassCastException       if the specified key and/or value types are\n   *                                  incompatible with the configured cache.\n   * @throws NullPointerException     if either keyType or classType is null.\n   * @throws SecurityException        when the operation could not be performed\n   *                                  due to the current security settings\n   */\n  <K, V> Cache<K, V> getCache(String cacheName, Class<K> keyType,\n                              Class<V> valueType);\n\n  /**\n   * Looks up a managed {@link Cache} given its name.\n   * <p>\n   * This method may only be used to acquire {@link Cache}s that were\n   * configured without runtime key and value types, or were configured\n   * to use Object.class key and value types.\n   * <p>\n   * Use the {@link #getCache(String, Class, Class)} method to acquire\n   * {@link Cache}s with a check that the supplied key and value type parameters\n   * match the runtime types.\n   * <p>\n   * Implementations that support declarative mechanisms for pre-configuring\n   * {@link Cache}s may return a pre-configured {@link Cache} instead of\n   * <code>null</code>.\n   *\n   * @param <K> the type of key\n   * @param <V> the type of value\n   * @param cacheName the name of the cache to look for\n   * @return the Cache or null if it does exist or can\'t be pre-configured\n   * @throws IllegalStateException    if the CacheManager is {@link #isClosed()}\n   * @throws SecurityException        when the operation could not be performed\n   *                                  due to the current security settings\n   * @see #getCache(String, Class, Class)\n   */\n  <K, V> Cache<K, V> getCache(String cacheName);\n\n  /**\n   * Obtains an {@link Iterable} over the names of {@link Cache}s managed by the\n   * {@link CacheManager}.\n   * <p>\n   * {@link java.util.Iterator}s returned by the {@link Iterable} are immutable.\n   * If the {@link Cache}s managed by the {@link CacheManager} change,\n   * the {@link Iterable} and associated {@link java.util.Iterator}s are not\n   * affected.\n   * <p>\n   * {@link java.util.Iterator}s returned by the {@link Iterable} may not provide\n   * all of the {@link Cache}s managed by the {@link CacheManager}.  For example:\n   * Internally defined or platform specific {@link Cache}s that may be accessible\n   * by a call to {@link #getCache(String)} or {@link #getCache(String, Class,\n   * Class)} may not be present in an iteration.\n   *\n   * @return an {@link Iterable} over the names of managed {@link Cache}s.\n   * @throws IllegalStateException if the {@link CacheManager}\n   *                               is {@link #isClosed()}\n   * @throws SecurityException     when the operation could not be performed\n   *                               due to the current security settings\n   */\n  Iterable<String> getCacheNames();\n\n  /**\n   * Destroys a specifically named and managed {@link Cache}.  Once destroyed\n   * a new {@link Cache} of the same name but with a different {@link\n   * Configuration} may be configured.\n   * <p>\n   * This is equivalent to the following sequence of method calls:\n   * <ol>\n   * <li>{@link Cache#clear()}</li>\n   * <li>{@link Cache#close()}</li>\n   * </ol>\n   * followed by allowing the name of the {@link Cache} to be used for other\n   * {@link Cache} configurations.\n   * <p>\n   * From the time this method is called, the specified {@link Cache} is not\n   * available for operational use. An attempt to call an operational method on\n   * the {@link Cache} will throw an {@link IllegalStateException}.\n   *\n   * @param cacheName the cache to destroy\n   * @throws IllegalStateException if the {@link CacheManager}\n   *                               {@link #isClosed()}\n   * @throws NullPointerException  if cacheName is null\n   * @throws SecurityException     when the operation could not be performed\n   *                               due to the current security settings\n   */\n  void destroyCache(String cacheName);\n\n  /**\n   * Controls whether management is enabled. If enabled the {@link CacheMXBean}\n   * for each cache is registered in the platform MBean server. The platform\n   * MBeanServer is obtained using\n   * {@link ManagementFactory#getPlatformMBeanServer()}.\n   * <p>\n   * Management information includes the name and configuration information for\n   * the cache.\n   * <p>\n   * Each cache\'s management object must be registered with an ObjectName that\n   * is unique and has the following type and attributes:\n   * <p>\n   * Type:\n   * <code>javax.cache:type=CacheConfiguration</code>\n   * <p>\n   * Required Attributes:\n   * <ul>\n   * <li>CacheManager the URI of the CacheManager\n   * <li>Cache the name of the Cache\n   * </ul>\n   *\n   * @param cacheName the name of the cache to register\n   * @param enabled   true to enable management, false to disable.\n   * @throws IllegalStateException if the {@link CacheManager} or\n   *                               {@link Cache} {@link #isClosed()}\n   * @throws SecurityException     when the operation could not be performed\n   *                               due to the current security settings\n   */\n  void enableManagement(String cacheName, boolean enabled);\n\n  /**\n   * Enables or disables statistics gathering for a managed {@link Cache} at\n   * runtime.\n   * <p>\n   * Each cache\'s statistics object must be registered with an ObjectName that\n   * is unique and has the following type and attributes:\n   * <p>\n   * Type:\n   * <code>javax.cache:type=CacheStatistics</code>\n   * <p>\n   * Required Attributes:\n   * <ul>\n   * <li>CacheManager the URI of the CacheManager\n   * <li>Cache the name of the Cache\n   * </ul>\n   *\n   * @param cacheName the name of the cache to register\n   * @param enabled   true to enable statistics, false to disable.\n   * @throws IllegalStateException if the {@link CacheManager} or\n   *                               {@link Cache} {@link #isClosed()}\n   * @throws NullPointerException  if cacheName is null\n   * @throws SecurityException when the operation could not be performed\n   *                           due to the current security settings\n   */\n  void enableStatistics(String cacheName, boolean enabled);\n\n  /**\n   * Closes the {@link CacheManager}.\n   * <p>\n   * For each {@link Cache} managed by the {@link CacheManager}, the\n   * {@link Cache#close()} method will be invoked, in no guaranteed order.\n   * <p>\n   * If a {@link Cache#close()} call throws an exception, the exception will be\n   * ignored.\n   * <p>\n   * After executing this method, the {@link #isClosed()} method will return\n   * <code>true</code>.\n   * <p>\n   * All attempts to close a previously closed {@link CacheManager} will be\n   * ignored.\n   *\n   * Closing a CacheManager does not necessarily destroy the contents of the\n   * Caches in the CacheManager.\n   * <p>\n   * It simply signals that the CacheManager is no longer required by the application\n   * and that future uses of a specific CacheManager instance should not be permitted.\n   * <p>\n   * Depending on the implementation and Cache topology,\n   * (e.g. a storage-backed or distributed cache), the contents of closed Caches\n   * previously referenced by the CacheManager, may still be available and accessible\n   * by other applications.\n   *\n   * @throws SecurityException when the operation could not be performed due to the\n   *         current security settings\n   */\n  void close();\n\n  /**\n   * Determines whether the {@link CacheManager} instance has been closed. A\n   * {@link CacheManager} is considered closed if;\n   * <ol>\n   * <li>the {@link #close()} method has been called</li>\n   * <li>the associated {@link #getCachingProvider()} has been closed, or</li>\n   * <li>the {@link CacheManager} has been closed using the associated\n   * {@link #getCachingProvider()}</li>\n   * </ol>\n   * <p>\n   * This method generally cannot be called to determine whether the\n   * {@link CacheManager} is valid or invalid. A typical client can determine\n   * that a {@link CacheManager} is invalid by catching any exceptions that\n   * might be thrown when an operation is attempted.\n   *\n   * @return true if this {@link CacheManager} instance is closed; false if it\n   *         is still open\n   */\n  boolean isClosed();\n\n  /**\n   * Provides a standard mechanism to access the underlying concrete caching\n   * implementation to provide access to further, proprietary features.\n   * <p>\n   * If the provider\'s implementation does not support the specified class,\n   * the {@link IllegalArgumentException} is thrown.\n   *\n   * @param <T> the type of the underlying {@link CacheManager}\n   * @param clazz the proprietary class or interface of the underlying concrete\n   *              {@link CacheManager}. It is this type that is returned.\n   * @return an instance of the underlying concrete {@link CacheManager}\n   * @throws IllegalArgumentException if the caching provider doesn\'t support the\n   *                                  specified class.\n   * @throws SecurityException        when the operation could not be performed\n   *                                  due to the current security settings\n   */\n  <T> T unwrap(java.lang.Class<T> clazz);\n}\n```\n\n### 获取默认 `CacheManager`\n\n为了简化 API，开发者可以使用 `Caching` 类提供的默认 `CachingProvider` 类，获取默认的 `CacheManager`。比如\n\n```java\n// acquire the default CachingProvider\nCachingProvider provider = Caching.getCachingProvider();\n\n// acquire the default CacheManager\nCacheManager manager = provider.getCacheManager();\n```\n\n为了获取非默认或者说自定义的 `CacheManager`，需要使用 `CachingProvider` 提供的重载版本的 `getCacheManager` 方法。\n\n如何配置一个 `CachingProvider` 会在后面的一节单独介绍。\n\n### 配置 `Cache`\n\n从 `CacheManager` 配置缓存有两种方式。\n\n- `CacheManager` 必须允许应用程序在运行时编程式的配置缓存，通过 `<K, V, C extends Configuration<K, V>> Cache<K, V> createCache(String cacheName, C configuration)` 方法\n- `CacheManager` 可以有选择的提供声明式配置来防止在应用程序中使用 `createCache` 方法。\n\n对于缓存实现来说，`CacheManager` 如何实现声明式的配置是自由的，其中一种是通过 XML 文件来配置 `CacheManager` 和其中的缓存。\n\n配置相关的类在 `javax.cache.configuration` 包下。里面提供了最小化配置(`Configuration`)和完整配置(`CompleteConfiguration`)的接口。\n\n尽管此规范提供了一个最小化配置，但是只有完全支持 `CompleteConfiguration` 接口的实现才符合该规范。\n\n`javax.cache.configuration.Configuration` 接口定义如下：\n\n```java\npackage javax.cache.configuration;\n\nimport javax.cache.Cache;\nimport javax.cache.CacheManager;\nimport java.io.Serializable;\n\n/**\n * A basic read-only representation of a {@link Cache} configuration.\n * <p>\n * The properties provided by instances of this interface are used by\n * {@link CacheManager}s to configure {@link Cache}s.\n * <p>\n * Implementations of this interface must override {@link Object#hashCode()} and\n * {@link Object#equals(Object)} as {@link Configuration}s are often compared at\n * runtime.\n *\n * @param <K> the type of keys maintained the cache\n * @param <V> the type of cached values\n * @author Greg Luck\n * @author Brian Oliver\n * @since 1.0\n */\npublic interface Configuration<K, V> extends Serializable {\n\n  /**\n   * Determines the required type of keys for {@link Cache}s configured\n   * with this {@link Configuration}.\n   *\n   * @return the key type or <code>Object.class</code> if the type is undefined\n   */\n  Class<K> getKeyType();\n\n  /**\n   * Determines the required type of values for {@link Cache}s configured\n   * with this {@link Configuration}.\n   *\n   * @return the value type or <code>Object.class</code> if the type is undefined\n   */\n  Class<V> getValueType();\n\n  /**\n   * Whether storeByValue (true) or storeByReference (false).\n   * When true, both keys and values are stored by value.\n   * <p>\n   * When false, both keys and values are stored by reference.\n   * Caches stored by reference are capable of mutation by any threads holding\n   * the reference. The effects are:\n   * <ul>\n   * <li>if the key is mutated, then the key may not be retrievable or\n   * removable</li>\n   * <li>if the value is mutated, then all threads in the JVM can potentially\n   * observe those mutations, subject to the normal Java Memory Model rules.</li>\n   * </ul>\n   * Storage by reference only applies to the local heap. If an entry is moved off\n   * heap it will need to be transformed into a representation. Any mutations that\n   * occur after transformation may not be reflected in the cache.\n   * <p>\n   * When a cache is storeByValue, any mutation to the key or value does not\n   * affect the key of value stored in the cache.\n   * <p>\n   * The default value is <code>true</code>.\n   *\n   * @return true if the cache is store by value\n   */\n  boolean isStoreByValue();\n}\n```\n\n`javax.cache.configuration.CompleteConfiguration` 接口定义如下：\n\n```java\npackage javax.cache.configuration;\n\nimport javax.cache.expiry.ExpiryPolicy;\nimport javax.cache.integration.CacheLoader;\nimport javax.cache.integration.CacheWriter;\nimport java.io.Serializable;\n\n/**\n * A read-only representation of the complete JCache {@link javax.cache.Cache}\n * configuration.\n * <p>\n * The properties provided by instances of this interface are used by\n * {@link javax.cache.CacheManager}s to configure {@link javax.cache.Cache}s.\n * <p>\n * Implementations of this interface must override {@link Object#hashCode()} and\n * {@link Object#equals(Object)} as\n * {@link javax.cache.configuration.CompleteConfiguration}s are often compared at\n * runtime.\n *\n * @param <K> the type of keys maintained the cache\n * @param <V> the type of cached values\n * @author Greg Luck\n * @author Yannis Cosmadopoulos\n * @author Brian Oliver\n * @since 1.0\n */\npublic interface CompleteConfiguration<K, V> extends Configuration<K, V>,\n    Serializable {\n\n  /**\n   * Determines if a {@link javax.cache.Cache} should operate in read-through mode.\n   * <p>\n   * When in \"read-through\" mode, cache misses that occur due to cache entries\n   * not existing as a result of performing a \"get\" will appropriately\n   * cause the configured {@link javax.cache.integration.CacheLoader} to be\n   * invoked.\n   * <p>\n   * The default value is <code>false</code>.\n   *\n   * @return <code>true</code> when a {@link javax.cache.Cache} is in\n   * \"read-through\" mode.\n   * @see #getCacheLoaderFactory()\n   */\n  boolean isReadThrough();\n\n  /**\n   * Determines if a {@link javax.cache.Cache} should operate in write-through\n   * mode.\n   * <p>\n   * When in \"write-through\" mode, cache updates that occur as a result of\n   * performing \"put\" operations called via one of\n   * {@link javax.cache.Cache#put(Object, Object)},\n   * {@link javax.cache.Cache#getAndRemove(Object)},\n   * {@link javax.cache.Cache#removeAll()},\n   * {@link javax.cache.Cache#getAndPut(Object, Object)}\n   * {@link javax.cache.Cache#getAndRemove(Object)},\n   * {@link javax.cache.Cache#getAndReplace(Object,\n   * Object)}, {@link javax.cache.Cache#invoke(Object,\n   * javax.cache.processor.EntryProcessor,\n   * Object...)}, {@link javax.cache.Cache#invokeAll(java.util.Set,\n   * javax.cache.processor.EntryProcessor, Object...)} will appropriately cause\n   * the configured {@link javax.cache.integration.CacheWriter} to be invoked.\n   * <p>\n   * The default value is <code>false</code>.\n   *\n   * @return <code>true</code> when a {@link javax.cache.Cache} is in\n   *        \"write-through\" mode.\n   * @see #getCacheWriterFactory()\n   */\n  boolean isWriteThrough();\n\n  /**\n   * Checks whether statistics collection is enabled in this cache.\n   * <p>\n   * The default value is <code>false</code>.\n   *\n   * @return true if statistics collection is enabled\n   */\n  boolean isStatisticsEnabled();\n\n  /**\n   * Checks whether management is enabled on this cache.\n   * <p>\n   * The default value is <code>false</code>.\n   *\n   * @return true if management is enabled\n   */\n  boolean isManagementEnabled();\n\n  /**\n   * Obtains the {@link javax.cache.configuration.CacheEntryListenerConfiguration}s\n   * for {@link javax.cache.event.CacheEntryListener}s to be configured on a\n   * {@link javax.cache.Cache}.\n   *\n   * @return an {@link Iterable} over the\n   * {@link javax.cache.configuration.CacheEntryListenerConfiguration}s\n   */\n  Iterable<CacheEntryListenerConfiguration<K,\n      V>> getCacheEntryListenerConfigurations();\n\n  /**\n   * Gets the {@link javax.cache.configuration.Factory} for the\n   * {@link javax.cache.integration.CacheLoader}, if any.\n   * <p>\n   * A CacheLoader should be configured for \"Read Through\" caches to load values\n   * when a cache miss occurs using either the\n   * {@link javax.cache.Cache#get(Object)} and/or\n   * {@link javax.cache.Cache#getAll(java.util.Set)} methods.\n   * <p>\n   * The default value is <code>null</code>.\n   *\n   * @return the {@link javax.cache.configuration.Factory} for the\n   * {@link javax.cache.integration.CacheLoader} or null if none has been set.\n   */\n  Factory<CacheLoader<K, V>> getCacheLoaderFactory();\n\n  /**\n   * Gets the {@link javax.cache.configuration.Factory} for the\n   * {@link javax.cache.integration.CacheWriter}, if any.\n   * <p>\n   * The default value is <code>null</code>.\n   *\n   * @return the {@link javax.cache.configuration.Factory} for the\n   * {@link javax.cache.integration.CacheWriter} or null if none has been set.\n   */\n  Factory<CacheWriter<? super K, ? super V>> getCacheWriterFactory();\n\n  /**\n   * Gets the {@link javax.cache.configuration.Factory} for the\n   * {@link javax.cache.expiry.ExpiryPolicy} to be used for caches.\n   * <p>\n   * The default value is a {@link javax.cache.configuration.Factory} that will\n   * produce a {@link javax.cache.expiry.EternalExpiryPolicy} instance.\n   *\n   * @return the {@link javax.cache.configuration.Factory} for\n   * {@link javax.cache.expiry.ExpiryPolicy} (must not be <code>null</code>)\n   */\n  Factory<ExpiryPolicy> getExpiryPolicyFactory();\n\n}\n```\n\n为了方便配置，提供了一个 `javax.cache.configuration.MutableConfiguration` 作为 `CompleteConfiguration` 的实现类。\n\n缓存实现可以提供自定义的 `Configuration` 接口实现来拓展配置。\n\n为了简化 `MutableConfiguration` 的使用，所有 setter 方法都返回 `MutableConfiguration` 的实例。\n\n`CacheManger` 有责任去校验 `Cache` 的配置是否合法，`Cache` 配置可以在创建时被 `CacheManager` 接受，在创建 `Cache` 时抛出 `IllegalArgumentException`。\n\n`MutableConfiguration` 经常使用的构造器和和 setter 方法如下：\n\n```java\n/**\n   * Default JavaBean constructor.\n   * <p>\n   * Creates a default configuration. Default configurations have no\n   * runtime type checking and are set for eternal expiry.\n   * </p><p>\n   * To enable runtime type enforcement, if supported by the implementation, call\n   * {@link #setTypes} after construction.\n   * </p><p>\n   * After construction set any other configuration parameters in the\n   * fluent style. e.g.\n   * </p>\n   * <pre>{@code\n   * CacheConfiguration<Integer, String> = new MutableConfiguration<Integer, String>()\n   *         .setTypes(Integer.class, String.class)\n   *         .setReadThrough(true)\n   *         . . .\n   * }</pre>\n   * @see #setTypes(Class, Class)\n   */\n  public MutableConfiguration()\n\n  /**\n   * Constructs a {@link MutableConfiguration} based on another\n   * {@link CompleteConfiguration}.\n   *\n   * @param configuration the {@link CompleteConfiguration}\n   */\n  public MutableConfiguration(CompleteConfiguration<K, V> configuration)\n\n  /**\n   * Sets the expected type of keys and values for a {@link Cache}\n   * configured with this {@link Configuration}. Setting both to\n   * <code>Object.class</code> means type-safety checks are not required.\n* <p>\n   * This is used by {@link CacheManager} to ensure that the key and value\n   * types are the same as those configured for the {@link Cache} prior to\n   * returning a requested cache from this method.\n   * <p>\n   * Implementations may further perform type checking on mutative cache operations\n   * and throw a {@link ClassCastException} if these checks fail.\n   *\n   * @param keyType   the expected key type\n   * @param valueType the expected value type\n   * @return the {@link MutableConfiguration} to permit fluent-style method calls\n   * @throws NullPointerException should the key or value type be null\n   * @see CacheManager#getCache(String, Class, Class)\n   */\n  public MutableConfiguration<K, V> setTypes(Class<K> keyType, Class<V> valueType)\n\n\n  /**\n   * Add a configuration for a {@link CacheEntryListener}.\n   *\n   * @param cacheEntryListenerConfiguration the\n   *  {@link CacheEntryListenerConfiguration}\n   * @return the {@link MutableConfiguration} to permit fluent-style method calls\n   * @throws IllegalArgumentException is the same CacheEntryListenerConfiguration\n   * is used more than once\n   */\n  public MutableConfiguration<K, V> addCacheEntryListenerConfiguration(\n      CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration)\n\n\n  /**\n   * Remove a configuration for a {@link CacheEntryListener}.\n   *\n   * @param cacheEntryListenerConfiguration  the\n   *     {@link CacheEntryListenerConfiguration} to remove\n   * @return the {@link MutableConfiguration} to permit fluent-style method calls\n   */\n  public MutableConfiguration<K, V> removeCacheEntryListenerConfiguration(\n      CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration)\n\n\n  /**\n   * Set the {@link CacheLoader} factory.\n   *\n   * @param factory the {@link CacheLoader} {@link Factory}\n   * @return the {@link MutableConfiguration} to permit fluent-style method calls\n   */\n  public MutableConfiguration<K, V> setCacheLoaderFactory(Factory<? extends\n      CacheLoader<K, V>> factory)\n\n  /**\n   * Set the {@link CacheWriter} factory.\n   *\n * @param factory the {@link CacheWriter} {@link Factory}\n   * @return the {@link MutableConfiguration} to permit fluent-style method calls\n   */\n  public MutableConfiguration<K, V> setCacheWriterFactory(Factory<? extends\n      CacheWriter<? super K, ? super V>> factory)\n\n  /**\n   * Set the {@link Factory} for the {@link ExpiryPolicy}.  If <code>null</code>\n   * is specified the default {@link ExpiryPolicy} is used.\n   * <p>\n   * Only one expiry policy can be set for a cache. The last policy applied\n   * before cache construction will be the one used.\n   * @param factory the {@link ExpiryPolicy} {@link Factory}\n   * @return the {@link MutableConfiguration} to permit fluent-style method calls\n   */\n  public MutableConfiguration<K, V> setExpiryPolicyFactory(Factory<? extends\n      ExpiryPolicy> factory)\n\n  /**\n   * Set if read-through caching should be used.\n   * <p>\n   * It is an invalid configuration to set this to true without specifying a\n   * {@link CacheLoader} {@link Factory}.\n   *\n   * @param isReadThrough <code>true</code> if read-through is required\n   * @return the {@link MutableConfiguration} to permit fluent-style method calls\n   */\n  public MutableConfiguration<K, V> setReadThrough(boolean isReadThrough)\n\n\n  /**\n   * Set if write-through caching should be used.\n   * <p>\n   * It is an invalid configuration to set this to true without specifying a\n   * {@link CacheWriter} {@link Factory}.\n   *\n   * @param isWriteThrough <code>true</code> if write-through is required\n   * @return the {@link MutableConfiguration} to permit fluent-style method calls\n   */\n  public MutableConfiguration<K, V> setWriteThrough(boolean isWriteThrough)\n\n\n  /**\n   * Set if a configured cache should use store-by-value or store-by-reference\n   * semantics.\n   *\n   * @param isStoreByValue <code>true</code> if store-by-value is required,\n   *                       <code>false</code> for store-by-reference\n   * @return the {@link MutableConfiguration} to permit fluent-style method calls\n   */\n  public MutableConfiguration<K, V> setStoreByValue(boolean isStoreByValue)\n\n  /**\n   * Sets whether statistics gathering is enabled on a cache.\n   * <p>\n   * Statistics may be enabled or disabled at runtime via\n   * {@link CacheManager#enableStatistics(String, boolean)}.\n   *\n   * @param enabled true to enable statistics, false to disable.\n   * @return the {@link MutableConfiguration} to permit fluent-style method calls\n   */\n  public MutableConfiguration<K, V> setStatisticsEnabled(boolean enabled)\n\n  /**\n   * Sets whether management is enabled on a cache.\n   * <p>\n   * Management may be enabled or disabled at runtime via\n   * {@link CacheManager#enableManagement(String, boolean)}.\n   *\n   * @param enabled true to enable statistics, false to disable.\n   * @return the {@link MutableConfiguration} to permit fluent-style method calls\n   */\n  public MutableConfiguration<K, V> setManagementEnabled(boolean enabled)\n\n\n```\n\n`MutableConfiguration` 中提供的配置和 `Configuration` 会在后面的章节中深入讨论。\n\n下表是一个 `MutableConfiguration` 实例所提供的默认值。\n\n|配置项|类型|默认值|\n|---|---|---|\n|Key 类型|`Class<?>`|`Object.class`|\n|Value 类型|`Class<?>`|`Object.class`|\n|Cache Loader Factory|`Factory<CacheLoader<K, V>>`|`null`|\n|Cache Writer Factory|`Factory<CacheWriter<? super K, ? super V>>`|`null`|\n|Expiry Policy Factory|`Factory<ExpiryPolicy<K>>`|`a factory producing an EternalExpiryPolicy`|\n|Read Through Enabled|`boolean`|`false`|\n|Write Through Enabled|`boolean`|`false`|\n|Cache Entry Listener Configuration|`Iterable<CacheEntryListenerConfiguration<? super K, ? super V>>`|`an empty iteration`|\n|Statistics Enabled|`boolean`|`false`|\n|Management Enabled|`boolean`|`false`|\n\n### 缓存名和缓存作用域\n\n对于每一个 `Cache`，在创建该 `Cache` 的 `CacheManager` 的作用域内，由 缓存名 唯一确定\n\n因为缓存名作为 Java String 存在，所以就可移植性来说，有如下限制和推荐的命名规定\n\n- `java.` 或 `javax.` 开头的缓存名不能使用。因为可能作为平台级的缓存名前缀。\n- 缓存名不能包含 `/` 和 `:`，因为可能被用于 Java EE 环境中基于 JNDI 查询。\n- 缓存名可以使用 Unicode 字符\n\n虽然不是必须的，应用程序恶意使用要缓存的 `Value` 类的全类名作为缓存名，比如 缓存 Orders 的缓存可以叫 `com.mycompany.Orders`。\n\n### 获取缓存\n\n目前有两种方式从 `CacheManager` 中获取缓存。\n\n- 当需要一个类型安全的 `Cache` 时，应该使用 `CacheManger` 提供的 `<K, V> Cache<K, V> getCache(String cacheName,Class<K> keyType, Class<V> valueType)`。\n- 当不需要类型安全校验时（由应用自己来确保），应该使用 `<K, V> Cache<K, V> Cache getCache(String cacheName);`\n\n可以查阅 缓存类型安全 一节来获得相关的更多信息。\n\n一个简单的获取缓存的例子：\n\n```java\nCache<String, Integer> cache = cacheManager.getCache(\n        \"simpleCache\", String.class, Integer.class);\n```\n\n### `Cache` 和 `CacheManager` 的生命周期\n\n所有 `Cache` 和 `CacheManager` 实例只有两个状态，`opened` 和 `closed`，当打开时，所有操作都是允许的，包括创建、更新、删除条目或配置、获取、关闭、删除缓存等。当关闭时，所有操作都会抛出 `IllegalStateException`。\n\n### 关闭缓存\n\n通过调用 `Cache.close()` 方法关闭 `Cache` 会向创建或拥有该 `Cache` 的 `CacheManager` 发出信号，表明不应再对其进行管理。在次数，`CacheManger` 做了如下操作：\n\n- 必须关闭和释放与该缓存相关的所有资源。这包括调用 `CacheLoader`、`CacheWriter`、`CacheEntryListener`、`ExpiryPolicy` 实例的 `close` 方法。\n- 不再传递事件给该 `Cache` 的 `CacheEntryListener`。\n- 当调用 `CacheManager getCacheNames()` 时，不再返回该缓存的名字。\n\n一旦缓存关闭后，所有对缓存的操作都会抛出 `IllegalStateException`，以下是操作方法：\n\n```java\n- clear\n- containsKey\n- deregisterCacheEntryListener\n- get\n- getAll\n- getAndPut\n- getAndRemove\n- getAndReplace\n- invoke\n- invokeAll\n- iterator\n- loadAll\n- put\n- putAll\n- putIfAbsent\n- registerCacheEntryListener\n- remove\n- removeAll\n- replace\n```\n\n关闭缓存并不一定必须要销毁缓存的所有内容。它仅仅是向拥有它的 `CacheManager` 发出信号。表示应用程序已经不再需要该缓存且不允许对该缓存做任何操作。根据实现的不同（基于存储或分布式），已关闭的缓存内容可能仍然可以被【其他】应用程序访问，不管是在关闭之前获取到的还是在关闭之后获取到的。\n\n### 销毁缓存\n\n要销毁一个 `Cache`，将其从被管理的状态中释放出来，并删除所有缓存条目，从而允许创建一个具有相同名称但可能具有不同配置的新缓存，应调用 `CacheManager destroyCache` 方法。\n\n```java\n/**\n * Destroys a specifically named and managed {@link Cache}.  Once destroyed\n * a new {@link Cache} of the same name but with a different {@link\n * Configuration} may be configured.\n * <p>\n * This is equivalent to the following sequence of method calls:\n * <ol>\n * <li>{@link Cache#clear()}</li>\n * <li>{@link Cache#close()}</li>\n * </ol>\n * followed by allowing the name of the {@link Cache} to be used for other\n * {@link Cache} configurations.\n * <p>\n * From the time this method is called, the specified {@link Cache} is not\n * available for operational use. An attempt to call an operational method on\n * the {@link Cache} will throw an {@link IllegalStateException}.\n *\n * @param cacheName the cache to destroy\n * @throws IllegalStateException if the {@link CacheManager}\n *                               {@link #isClosed()}\n * @throws NullPointerException  if cacheName is null\n * @throws SecurityException     when the operation could not be performed\n *                               due to the current security settings\n */\nvoid destroyCache(String cacheName);\n```\n\n一旦被销毁：\n\n- 任何试图操作操作该缓存的方法调用将抛出 `IllegalStateException`\n- 被销毁的缓存的名字可以被新缓存重用，跟之前的区别是配置不同。\n\n一旦销毁，就无法通过 `CacheManager` 使用缓存。 销毁缓存可确保关闭缓存，并且无论应用程序或拓扑如何，所有应用程序都将立即或将来不再使用所有关联条目。\n\n### 关闭 `CacheManager`\n\n可以通过 `CacheManager.close()` 或者 `CachingProvider.close(...)` 方法来关闭 `CacheManager`，这两个方法调用会有如下效果：\n\n- 关闭被其管理的所有 `Cache`。\n- 释放用来管理 `Cache` 的所有资源。\n- 一旦关闭，任何试图操作 `CacheManager` 或其管理的 `Cache` 的行为都将抛出 `IllegalStateException`，其中涉及的方法如下：\n\n```java\n- createCache\n- destroyCache\n- enableManagement\n- enableStatistics\n- getCache\n- getCacheNames\n```\n\n关闭 `CacheManager` 后，可以使用最初创建 `CacheManager` 的 `CachingProvider` 创建另外一个实例。这部分将在 `CachingProvder` 部分进行介绍。\n\n关闭 `CacheManager` 并不一定会销毁 `CacheManager` 中 `Cache` 里的数据。 它只是表明应用程序不再需要拥有的`CacheManager`，并且不应再允许该特定 `CacheManager` 实例的将来使用。 取决于实现（基于存储或分布式），已关闭的`CacheManager` 管理的 `Cache`的数据可能仍然可以被【其他】应用程序访问。\n\n### 类加载\n\n同一个 `CacheManager` 中的所有 `Cache` 共用用于创建 `CacheManager` 的类加载器。\n\n如果不同的 `Cache` 要使用不同的类加载器，则必须通过创建不同的 `CacheManager` 实现。有关如何配置 `CacheManager` 的信息，请参阅关于 `CachingProvider` 的部分。\n\n## `Cache`\n\n开发者主要通过 `javax.cache.Cache` 与 `Cache` 进行交互。\n\n`javax.cache.Cache` 接口提供了 Map-like 的方法来访问、更新、删除缓存条目。\n\n`javax.cache.Cache` 接口定义如下：\n\n```java\nimport javax.cache.configuration.CacheEntryListenerConfiguration;\nimport javax.cache.configuration.Configuration;\nimport javax.cache.event.CacheEntryListener;\nimport javax.cache.event.CacheEntryRemovedListener;\nimport javax.cache.expiry.ExpiryPolicy;\nimport javax.cache.integration.CacheLoader;\nimport javax.cache.integration.CacheWriter;\nimport javax.cache.integration.CompletionListener;\nimport javax.cache.processor.EntryProcessor;\nimport javax.cache.processor.EntryProcessorException;\nimport javax.cache.processor.EntryProcessorResult;\nimport java.io.Closeable;\nimport java.util.Iterator;\nimport java.util.Map;\nimport java.util.Set;\n\n/**\n * A {@link Cache} is a Map-like data structure that provides temporary storage\n * of application data.\n * <p>\n * Like {@link Map}s, {@link Cache}s\n * <ol>\n * <li>store key-value pairs, each referred to as an {@link Entry}</li>\n * <li>allow use of Java Generics to improve application type-safety</li>\n * <li>are {@link Iterable}</li>\n * </ol>\n * <p>\n * Unlike {@link Map}s, {@link Cache}s\n * <ol>\n * <li>do not allow null keys or values.  Attempts to use <code>null</code>\n * will result in a {@link NullPointerException}</li>\n * <li>provide the ability to read values from a\n * {@link CacheLoader} (read-through-caching)\n * when a value being requested is not in a cache</li>\n * <li>provide the ability to write values to a\n * {@link CacheWriter} (write-through-caching)\n * when a value being created/updated/removed from a cache</li>\n * <li>provide the ability to observe cache entry changes</li>\n * <li>may capture and measure operational statistics</li>\n * </ol>\n * <p>\n * A simple example of how to use a cache is:\n * <pre><code>\n * String cacheName = \"sampleCache\";\n * CachingProvider provider = Caching.getCachingProvider();\n * CacheManager manager = provider.getCacheManager();\n * Cache&lt;Integer, Date&gt; cache = manager.getCache(cacheName, Integer.class,\n *                                                     Date.class);\n * Date value1 = new Date();\n * Integer key = 1;\n * cache.put(key, value1);\n * Date value2 = cache.get(key);\n * </code></pre>\n *\n * @param <K> the type of key\n * @param <V> the type of value\n * @author Greg Luck\n * @author Yannis Cosmadopoulos\n * @author Brian Oliver\n * @since 1.0\n */\npublic interface Cache<K, V> extends Iterable<Cache.Entry<K, V>>, Closeable {\n    /**\n     * Gets an entry from the cache.\n     * <p>\n     * If the cache is configured to use read-through, and get would return null\n     * because the entry is missing from the cache, the Cache\'s {@link CacheLoader}\n     * is called in an attempt to load the entry.\n     *\n     * @param key the key whose associated value is to be returned\n     * @return the element, or null, if it does not exist.\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws NullPointerException  if the key is null\n     * @throws CacheException        if there is a problem fetching the value\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     */\n    V get(K key);\n\n    /**\n     * Gets a collection of entries from the {@link Cache}, returning them as\n     * {@link Map} of the values associated with the set of keys requested.\n     * <p>\n     * If the cache is configured read-through, and a get for a key would\n     * return null because an entry is missing from the cache, the Cache\'s\n     * {@link CacheLoader} is called in an attempt to load the entry. If an\n     * entry cannot be loaded for a given key, the key will not be present in\n     * the returned Map.\n     *\n     * @param keys The keys whose associated values are to be returned.\n     * @return A map of entries that were found for the given keys. Keys not found\n     *         in the cache are not in the returned map.\n     * @throws NullPointerException  if keys is null or if keys contains a null\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem fetching the values\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     */\n    Map<K, V> getAll(Set<? extends K> keys);\n\n    /**\n     * Determines if the {@link Cache} contains an entry for the specified key.\n     * <p>\n     * More formally, returns <tt>true</tt> if and only if this cache contains a\n     * mapping for a key <tt>k</tt> such that <tt>key.equals(k)</tt>.\n     * (There can be at most one such mapping.)</p>\n     * <p>\n     * If the cache is configured read-through the associated {@link CacheLoader}\n     * is not called. Only the cache is checked.\n     * </p>\n     * @param key key whose presence in this cache is to be tested.\n     * @return <tt>true</tt> if this map contains a mapping for the specified key\n     * @throws NullPointerException  if key is null\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        it there is a problem checking the mapping\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see java.util.Map#containsKey(Object)\n     */\n    boolean containsKey(K key);\n\n    /**\n     * Asynchronously loads the specified entries into the cache using the\n     * configured {@link CacheLoader} for the given keys.\n     * <p>\n     * If an entry for a key already exists in the Cache, a value will be loaded\n     * if and only if <code>replaceExistingValues</code> is true.   If no loader\n     * is configured for the cache, no objects will be loaded.  If a problem is\n     * encountered during the retrieving or loading of the objects,\n     * an exception is provided to the {@link CompletionListener}.  Once the\n     * operation has completed, the specified CompletionListener is notified.\n     * <p>\n     * Implementations may choose to load multiple keys from the provided\n     * {@link Set} in parallel.  Iteration however must not occur in parallel,\n     * thus allow for non-thread-safe {@link Set}s to be used.\n     * <p>\n     * The thread on which the completion listener is called is implementation\n     * dependent. An implementation may also choose to serialize calls to\n     * different CompletionListeners rather than use a thread per\n     * CompletionListener.\n     *\n     * @param keys                  the keys to load\n     * @param replaceExistingValues when true existing values in the Cache will\n     *                              be replaced by those loaded from a CacheLoader\n     * @param completionListener    the CompletionListener (may be null)\n     * @throws NullPointerException  if keys is null or if keys contains a null.\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        thrown if there is a problem performing the\n     *                               load. This may also be thrown on calling if\n     *                               there are insufficient threads available to\n     *                               perform the load.\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     */\n    void loadAll(Set<? extends K> keys, boolean replaceExistingValues,\n                 CompletionListener completionListener);\n\n    /**\n     * Associates the specified value with the specified key in the cache.\n     * <p>\n     * If the {@link Cache} previously contained a mapping for the key, the old\n     * value is replaced by the specified value.  (A cache <tt>c</tt> is said to\n     * contain a mapping for a key <tt>k</tt> if and only if {@link\n     * #containsKey(Object) c.containsKey(k)} would return <tt>true</tt>.)\n     * <p>\n     * If the cache is configured write-through the\n     * {@link CacheWriter#write(Cache.Entry)} method will be called.\n     * </p>\n     *\n     * @param key   key with which the specified value is to be associated\n     * @param value value to be associated with the specified key\n     * @throws NullPointerException  if key is null or if value is null\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem doing the put\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see java.util.Map#put(Object, Object)\n     * @see #getAndPut(Object, Object)\n     * @see #getAndReplace(Object, Object)\n     * @see CacheWriter#write\n     */\n    void put(K key, V value);\n\n    /**\n     * Associates the specified value with the specified key in this cache,\n     * returning an existing value if one existed.\n     * <p>\n     * If the cache previously contained a mapping for\n     * the key, the old value is replaced by the specified value.  (A cache\n     * <tt>c</tt> is said to contain a mapping for a key <tt>k</tt> if and only\n     * if {@link #containsKey(Object) c.containsKey(k)} would return\n     * <tt>true</tt>.)\n     * <p>\n     * The previous value is returned, or null if there was no value associated\n     * with the key previously.</p>\n     * <p>\n     * If the cache is configured write-through the associated\n     * {@link CacheWriter#write(Cache.Entry)} method will be called.\n     * </p>\n     *\n     * @param key   key with which the specified value is to be associated\n     * @param value value to be associated with the specified key\n     * @return the value associated with the key at the start of the operation or\n     *         null if none was associated\n     * @throws NullPointerException  if key is null or if value is null\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem doing the put\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see #put(Object, Object)\n     * @see #getAndReplace(Object, Object)\n     * @see CacheWriter#write(Cache.Entry)\n     */\n    V getAndPut(K key, V value);\n\n    /**\n     * Copies all of the entries from the specified map to the {@link Cache}.\n     * <p>\n     * The effect of this call is equivalent to that of calling\n     * {@link #put(Object, Object) put(k, v)} on this cache once for each mapping\n     * from key <tt>k</tt> to value <tt>v</tt> in the specified map.\n     * <p>\n     * The order in which the individual puts occur is undefined.\n     * <p>\n     * The behavior of this operation is undefined if entries in the cache\n     * corresponding to entries in the map are modified or removed while this\n     * operation is in progress. or if map is modified while the operation is in\n     * progress.\n     * <p>\n     * In Default Consistency mode, individual puts occur atomically but not\n     * the entire putAll.  Listeners may observe individual updates.\n     * <p>\n     * If the cache is configured write-through the associated\n     * {@link CacheWriter#writeAll} method will be called.\n     * </p>\n     *\n     * @param map mappings to be stored in this cache\n     * @throws NullPointerException  if map is null or if map contains null keys\n     *                               or values.\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem doing the put.\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see CacheWriter#writeAll\n     */\n    void putAll(java.util.Map<? extends K, ? extends V> map);\n\n    /**\n     * Atomically associates the specified key with the given value if it is\n     * not already associated with a value.\n     * <p>\n     * This is equivalent to:\n     * <pre><code>\n     * if (!cache.containsKey(key)) {}\n     *   cache.put(key, value);\n     *   return true;\n     * } else {\n     *   return false;\n     * }\n     * </code></pre>\n     * except that the action is performed atomically.\n     * <p>\n     * If the cache is configured write-through, and this method returns true,\n     * the associated {@link CacheWriter#write(Cache.Entry)} method will be called.\n     * </p>\n     * @param key   key with which the specified value is to be associated\n     * @param value value to be associated with the specified key\n     * @return true if a value was set.\n     * @throws NullPointerException  if key is null or value is null\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem doing the put\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see CacheWriter#write\n     */\n    boolean putIfAbsent(K key, V value);\n\n    /**\n     * Removes the mapping for a key from this cache if it is present.\n     * <p>\n     * More formally, if this cache contains a mapping from key <tt>k</tt> to\n     * value <tt>v</tt> such that\n     * <code>(key==null ?  k==null : key.equals(k))</code>, that mapping is removed.\n     * (The cache can contain at most one such mapping.)\n     *\n     * <p>Returns <tt>true</tt> if this cache previously associated the key,\n     * or <tt>false</tt> if the cache contained no mapping for the key.\n     * <p>\n     * The cache will not contain a mapping for the specified key once the\n     * call returns.\n     * <p>\n     * If the cache is configured write-through the associated\n     * {@link CacheWriter#delete(Object)} method will be called.\n     * </p>\n     * @param key key whose mapping is to be removed from the cache\n     * @return returns false if there was no matching key\n     * @throws NullPointerException  if key is null\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem doing the remove\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see CacheWriter#delete\n     */\n    boolean remove(K key);\n\n    /**\n     * Atomically removes the mapping for a key only if currently mapped to the\n     * given value.\n     * <p>\n     * This is equivalent to:\n     * <pre><code>\n     * if (cache.containsKey(key) &amp;&amp; equals(cache.get(key), oldValue) {\n     *   cache.remove(key);\n     *   return true;\n     * } else {\n     *   return false;\n     * }\n     * </code></pre>\n     * except that the action is performed atomically.\n     * <p>\n     * If the cache is configured write-through, and this method returns true,\n     * the associated {@link CacheWriter#delete(Object)} method will be called.\n     * </p>\n     * @param key      key whose mapping is to be removed from the cache\n     * @param oldValue value expected to be associated with the specified key\n     * @return returns false if there was no matching key\n     * @throws NullPointerException  if key is null\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem doing the remove\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see CacheWriter#delete\n     */\n    boolean remove(K key, V oldValue);\n\n    /**\n     * Atomically removes the entry for a key only if currently mapped to some\n     * value.\n     * <p>\n     * This is equivalent to:\n     * <pre><code>\n     * if (cache.containsKey(key)) {\n     *   V oldValue = cache.get(key);\n     *   cache.remove(key);\n     *   return oldValue;\n     * } else {\n     *   return null;\n     * }\n     * </code></pre>\n     * except that the action is performed atomically.\n     * <p>\n     * If the cache is configured write-through the associated\n     * {@link CacheWriter#delete(Object)} method will be called.\n     * </p>\n     *\n     * @param key key with which the specified value is associated\n     * @return the value if one existed or null if no mapping existed for this key\n     * @throws NullPointerException  if the specified key or value is null.\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem during the remove\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see CacheWriter#delete\n     */\n    V getAndRemove(K key);\n\n    /**\n     * Atomically replaces the entry for a key only if currently mapped to a\n     * given value.\n     * <p>\n     * This is equivalent to:\n     * <pre><code>\n     * if (cache.containsKey(key) &amp;&amp; equals(cache.get(key), oldValue)) {\n     *  cache.put(key, newValue);\n     * return true;\n     * } else {\n     *  return false;\n     * }\n     * </code></pre>\n     * except that the action is performed atomically.\n     * <p>\n     * If the cache is configured write-through, and this method returns true,\n     * the associated {@link CacheWriter#write(Cache.Entry)} method will be called.\n     * </p>\n     * @param key      key with which the specified value is associated\n     * @param oldValue value expected to be associated with the specified key\n     * @param newValue value to be associated with the specified key\n     * @return <tt>true</tt> if the value was replaced\n     * @throws NullPointerException  if key is null or if the values are null\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem during the replace\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see CacheWriter#write\n     */\n    boolean replace(K key, V oldValue, V newValue);\n\n    /**\n     * Atomically replaces the entry for a key only if currently mapped to some\n     * value.\n     * <p>\n     * This is equivalent to\n     * <pre><code>\n     * if (cache.containsKey(key)) {\n     *   cache.put(key, value);\n     *   return true;\n     * } else {\n     *   return false;\n     * }</code></pre>\n     * except that the action is performed atomically.\n     * <p>\n     * If the cache is configured write-through, and this method returns true,\n     * the associated {@link CacheWriter#write(Cache.Entry)} method will be called.\n     * </p>\n     * @param key  the key with which the specified value is associated\n     * @param value the value to be associated with the specified key\n     * @return <tt>true</tt> if the value was replaced\n     * @throws NullPointerException  if key is null or if value is null\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem during the replace\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see #getAndReplace(Object, Object)\n     * @see CacheWriter#write\n     */\n    boolean replace(K key, V value);\n\n    /**\n     * Atomically replaces the value for a given key if and only if there is a\n     * value currently mapped by the key.\n     * <p>\n     * This is equivalent to\n     * <pre><code>\n     * if (cache.containsKey(key)) {\n     *   V oldValue = cache.get(key);\n     *   cache.put(key, value);\n     *   return oldValue;\n     * } else {\n     *   return null;\n     * }\n     * </code></pre>\n     * except that the action is performed atomically.\n     * <p>\n     * If the cache is configured write-through, and this method returns true,\n     * the associated {@link CacheWriter#write(Cache.Entry)} method will be called.\n     * </p>\n     * @param key   key with which the specified value is associated\n     * @param value value to be associated with the specified key\n     * @return the previous value associated with the specified key, or\n     *         <tt>null</tt> if there was no mapping for the key.\n     * @throws NullPointerException  if key is null or if value is null\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem during the replace\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see java.util.concurrent.ConcurrentMap#replace(Object, Object)\n     * @see CacheWriter#write\n     */\n    V getAndReplace(K key, V value);\n\n    /**\n     * Removes entries for the specified keys.\n     * <p>\n     * The order in which the individual entries are removed is undefined.\n     * <p>\n     * For every entry in the key set, the following are called:\n     * <ul>\n     *   <li>any registered {@link CacheEntryRemovedListener}s</li>\n     *   <li>if the cache is a write-through cache, the {@link CacheWriter}</li>\n     * </ul>\n     *\n     * @param keys the keys to remove\n     * @throws NullPointerException  if keys is null or if it contains a null key\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem during the remove\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see CacheWriter#deleteAll\n     */\n    void removeAll(Set<? extends K> keys);\n\n    /**\n     * Removes all of the mappings from this cache.\n     * <p>\n     * The order that the individual entries are removed is undefined.\n     * <p>\n     * For every mapping that exists the following are called:\n     * <ul>\n     *   <li>any registered {@link CacheEntryRemovedListener}s</li>\n     *   <li>if the cache is a write-through cache, the {@link CacheWriter}</li>\n     * </ul>\n     * If the cache is empty, the {@link CacheWriter} is not called.\n     * <p>\n     * This is potentially an expensive operation as listeners are invoked.\n     * Use {@link #clear()} to avoid this.\n     *\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem during the remove\n     * @see #clear()\n     * @see CacheWriter#deleteAll\n     */\n    void removeAll();\n\n    /**\n     * Clears the contents of the cache, without notifying listeners or\n     * {@link CacheWriter}s.\n     *\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     * @throws CacheException        if there is a problem during the clear\n     */\n    void clear();\n\n    /**\n     * Provides a standard way to access the configuration of a cache using\n     * JCache configuration or additional proprietary configuration.\n     * <p>\n     * The returned value must be immutable.\n     * <p>\n     * If the provider\'s implementation does not support the specified class,\n     * the {@link IllegalArgumentException} is thrown.\n     *\n     * @param <C> the type of the Configuration\n     * @param clazz the configuration interface or class to return. This includes\n     *              {@link Configuration}.class and\n     *              {@link javax.cache.configuration.CompleteConfiguration}s.\n     * @return the requested implementation of {@link Configuration}\n     * @throws IllegalArgumentException if the caching provider doesn\'t support\n     *                                  the specified class.\n     */\n    <C extends Configuration<K, V>> C getConfiguration(Class<C> clazz);\n\n    /**\n     * Invokes an {@link EntryProcessor} against the {@link Entry} specified by\n     * the provided key.\n     *\n     * @param <T>            the type of the return value\n     * @param key            the key to the entry\n     * @param entryProcessor the {@link EntryProcessor} to invoke\n     * @param arguments      additional arguments to pass to the\n     *                       {@link EntryProcessor}\n     * @return the result of the processing, if any, defined by the\n     *         {@link EntryProcessor} implementation\n     * @throws NullPointerException    if key or {@link EntryProcessor} is null\n     * @throws IllegalStateException   if the cache is {@link #isClosed()}\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @throws EntryProcessorException if an exception is thrown by the {@link\n     *                                 EntryProcessor}, a Caching Implementation\n     *                                 must wrap any {@link Exception} thrown\n     *                                 wrapped in an {@link EntryProcessorException}.\n     * @see EntryProcessor\n     */\n    <T> T invoke(K key,\n                 EntryProcessor<K, V, T> entryProcessor,\n                 Object... arguments) throws EntryProcessorException;\n\n    /**\n     * Invokes an {@link EntryProcessor} against the set of {@link Entry}s\n     * specified by the set of keys.\n     * <p>\n     * The order that the entries for the keys are processed is undefined.\n     * Implementations may choose to process the entries in any order, including\n     * concurrently.  Furthermore there is no guarantee implementations will\n     * use the same {@link EntryProcessor} instance to process each entry, as\n     * the case may be in a non-local cache topology.\n     * <p>\n     * The result of executing the {@link EntryProcessor} is returned as a\n     * {@link Map} of {@link EntryProcessorResult}s, one result per key.  Should the\n     * {@link EntryProcessor} or Caching implementation throw an exception, the\n     * exception is wrapped and re-thrown when a call to\n     * {@link javax.cache.processor.EntryProcessorResult#get()} is made.\n     *\n     * @param <T>            the type of the return value\n     * @param keys           the set of keys for entries to process\n     * @param entryProcessor the {@link EntryProcessor} to invoke\n     * @param arguments      additional arguments to pass to the\n     *                       {@link EntryProcessor}\n     * @return the map of {@link EntryProcessorResult}s of the processing per key,\n     * if any, defined by the {@link EntryProcessor} implementation.  No mappings\n     * will be returned for {@link EntryProcessor}s that return a\n     * <code>null</code> value for a key.\n     * @throws NullPointerException    if keys or {@link EntryProcessor} are null\n     * @throws IllegalStateException   if the cache is {@link #isClosed()}\n     * @throws ClassCastException    if the implementation is configured to perform\n     *                               runtime-type-checking, and the key or value\n     *                               types are incompatible with those that have been\n     *                               configured for the {@link Cache}\n     * @see EntryProcessor\n     */\n    <T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys,\n                                                  EntryProcessor<K, V, T>\n                                                          entryProcessor,\n                                                  Object... arguments);\n\n    /**\n     * Return the name of the cache.\n     *\n     * @return the name of the cache.\n     */\n    String getName();\n\n    /**\n     * Gets the {@link CacheManager} that owns and manages the {@link Cache}.\n     *\n     * @return the manager or <code>null</code> if the {@link Cache} is not\n     *         managed\n     */\n    CacheManager getCacheManager();\n\n    /**\n     * Closing a {@link Cache} signals to the {@link CacheManager} that produced or\n     * owns the {@link Cache} that it should no longer be managed. At this\n     * point in time the {@link CacheManager}:\n     * <ul>\n     * <li>must close and release all resources being coordinated on behalf of the\n     * Cache by the {@link CacheManager}. This includes calling the <code>close\n     * </code> method on configured {@link CacheLoader},\n     * {@link CacheWriter}, registered {@link CacheEntryListener}s and\n     * {@link ExpiryPolicy} instances that implement the java.io.Closeable\n     * interface.\n     * <li>prevent events being delivered to configured {@link CacheEntryListener}s\n     * registered on the {@link Cache}\n     * </li>\n     * <li>not return the name of the Cache when the CacheManager getCacheNames()\n     * method is called</li>\n     * </ul>\n     * Once closed any attempt to use an operational method on a Cache will throw an\n     * {@link IllegalStateException}.\n     * <p>\n     * Closing a Cache does not necessarily destroy the contents of a Cache.\n     * It simply signals to the owning CacheManager that the Cache is no longer\n     * required by the application and that future uses of a specific Cache instance\n     * should not be permitted.\n     * <p>\n     * Depending on the implementation and Cache topology,\n     * (e.g. a storage-backed or distributed cache), the contents of a closed Cache\n     * may still be available and accessible by other applications, or, in fact, via\n     * the Cache Manager that previously owned the Cache, if an application calls\n     * getCache at some point in the future.\n     *\n     * @throws SecurityException when the operation could not be performed\n     *                           due to the current security settings\n     */\n    void close();\n\n    /**\n     * Determines whether this Cache instance has been closed. A Cache is\n     * considered closed if;\n     * <ol>\n     * <li>the {@link #close()} method has been called</li>\n     * <li>the associated {@link #getCacheManager()} has been closed, or</li>\n     * <li>the Cache has been removed from the associated\n     * {@link #getCacheManager()}</li>\n     * </ol>\n     * <p>\n     * This method generally cannot be called to determine whether a Cache instance\n     * is valid or invalid. A typical client can determine that a Cache is invalid\n     * by catching any exceptions that might be thrown when an operation is\n     * attempted.\n     *\n     * @return true if this Cache instance is closed; false if it is still open\n     */\n    boolean isClosed();\n\n    /**\n     * Provides a standard way to access the underlying concrete caching\n     * implementation to provide access to further, proprietary features.\n     * <p>\n     * If the provider\'s implementation does not support the specified class,\n     * the {@link IllegalArgumentException} is thrown.\n     *\n     * @param <T> the type of the underlying {@link Cache} implementation\n     * @param clazz the proprietary class or interface of the underlying concrete\n     *              cache. It is this type that is returned.\n     * @return an instance of the underlying concrete cache\n     * @throws IllegalArgumentException if the caching provider doesn\'t support\n     *                                  the specified class.\n     * @throws SecurityException        when the operation could not be performed\n     *                                  due to the current security settings\n     */\n    <T> T unwrap(java.lang.Class<T> clazz);\n\n    /**\n     * Registers a {@link CacheEntryListener}. The supplied\n     * {@link CacheEntryListenerConfiguration} is used to instantiate a listener\n     * and apply it to those events specified in the configuration.\n     *\n     * @param cacheEntryListenerConfiguration\n     *         a factory and related configuration\n     *         for creating the listener\n     * @throws IllegalArgumentException is the same CacheEntryListenerConfiguration\n     *                                  is used more than once\n     * @throws IllegalStateException    if the cache is {@link #isClosed()}\n     * @see CacheEntryListener\n     */\n    void registerCacheEntryListener(\n            CacheEntryListenerConfiguration<K, V> cacheEntryListenerConfiguration);\n\n    /**\n     * Deregisters a listener, using the\n     * {@link CacheEntryListenerConfiguration} that was used to register it.\n     * <p>\n     * Both listeners registered at configuration time,\n     * and those created at runtime with {@link #registerCacheEntryListener} can\n     * be deregistered.\n     *\n     * @param cacheEntryListenerConfiguration\n     *         the factory and related configuration\n     *         that was used to create the\n     *         listener\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     */\n    void deregisterCacheEntryListener(CacheEntryListenerConfiguration<K, V>\n                                              cacheEntryListenerConfiguration);\n\n    /**\n     * {@inheritDoc}\n     * <p>\n     * The ordering of iteration over entries is undefined.\n     * <p>\n     * During iteration, any entries that are removed will have their appropriate\n     * CacheEntryRemovedListeners notified.\n     * <p>\n     * When iterating over a cache it must be assumed that the underlying\n     * cache may be changing, with entries being added, removed, evicted\n     * and expiring. {@link java.util.Iterator#next()} may therefore return\n     * null.\n     *\n     * @throws IllegalStateException if the cache is {@link #isClosed()}\n     */\n    Iterator<Cache.Entry<K, V>> iterator();\n\n    /**\n     * A cache entry (key-value pair).\n     */\n    interface Entry<K, V> {\n\n        /**\n         * Returns the key corresponding to this entry.\n         *\n         * @return the key corresponding to this entry\n         */\n        K getKey();\n\n        /**\n         * Returns the value stored in the cache when this entry was created.\n         *\n         * @return the value corresponding to this entry\n         */\n        V getValue();\n\n        /**\n         * Provides a standard way to access the underlying concrete cache entry\n         * implementation in order to provide access to further, proprietary features.\n         * <p>\n         * If the provider\'s implementation does not support the specified class,\n         * the {@link IllegalArgumentException} is thrown.\n         *\n         * @param <T> the type of the underlying {@link Entry} implementation\n         * @param clazz the proprietary class or interface of the underlying\n         *              concrete cache. It is this type that is returned.\n         * @return an instance of the underlying concrete cache\n         * @throws IllegalArgumentException if the caching provider doesn\'t support\n         *                                  the specified class.\n         */\n        <T> T unwrap(Class<T> clazz);\n    }\n}\n```\n\n### 缓存类型安全\n\nJava Caching API 大量使用了 JSR-14 中定义的泛型，以便在采用缓存时能够开发编译时类型安全的应用程序。\n\n编译时的类型安全性不能保证运行时类型正确性。 对于某些缓存实现，特别是那些跨Java进程存储或访问条目的缓存实现，Java运行时类型信息擦除以及无法获取和传输泛型信息可能意味着应用程序类型无法确保此类中缓存操作的类型安全性。 始终应注意确保使用适当的键和值类型配置缓存，以便实现可以根据需要或要求执行类型检查。\n\n### 编译时类型安全\n\n编译时类型安全由泛型来保证。\n\n#### 例1\n\n下面的这个例子中，Key 类型是 `String`，Value 类型是 `Integer`。当与 `Cache` 交互时使用了不兼容的类型时会报编译时错误。\n\n```java\nConfiguration config = new MutableConfiguration();\n\n//create the cache\ncacheManager.createCache(cacheName, config);\n\n//... then later to get the cache\nCache<String, Integer> cache = cacheManager.getCache(cacheName);\n\n//use the cache\nString key = \"key\";\nInteger value1 = 1;\ncache.put(\"key\", value1);\nInteger value2 = cache.get(key);\n\n\n//the following will not compile - incorrect types specified\n//cache.put(2, \"some value\");\n```\n\n尽管可以通过使用原始类型（不指定泛型类型参数）声明一个Cache来规避编译时类型安全检查，但不建议这样做，因为它允许发生简单的编程错误。\n\n#### 例2\n\n下面这个例子中，`Cache` 被声明为一个原始类型，这里面不会做编译时类型检查（尽管会生成类型警告）\n\n```java\nConfiguration config = new MutableConfiguration();\ncacheManager.createCache(cacheName, config);\n\n//... then later to get the cache without type information\nCache cache = cacheManager.getCache(cacheName);\nString key = \"key\";\nInteger value1 = 1;\ncache.put(\"key\", value1);\n\ncache.put(value1, \"key1\");  //not intended but will still compile and execute!\nInteger value2 = (Integer) cache.get(key);\nassertEquals(value1, value2);\n```\n\n### 运行时类型安全\n\n除了编译时类型安全，开发者可以通过配置 `Cache` 的 key 和 Value 的类型来保证运行时类型安全。例如，`MutableConfiguration` 类提供了下面的方法来定义需要的key 和 Value 类型。\n\n```java\n/**\n * Sets the expected type of keys and values for a {@link Cache}\n * configured with this {@link Configuration}. Setting both to\n * <code>Object.class</code> means type-safety checks are not required.\n * <p/>\n * This is used by {@link CacheManager} to ensure that the key and value\n * types are the same as those configured for the {@link Cache} prior to\n * returning a requested cache from this method.\n * <p/>\n * Implementations may further perform type checking on mutative cache operations\n * and throw a {@link ClassCastException} if these checks fail.\n *\n * @param keyType   the expected key type\n * @param valueType the expected value type\n * @return the {@link MutableConfiguration} to permit fluent-style method calls\n * @throws NullPointerException should the key or value type be null\n * @see CacheManager#getCache(String, Class, Class)\n */\npublic MutableConfiguration<K, V> setTypes(Class<K> keyType, Class<V> valueType)\n```\n\n当缓存配置定义了 key 和 Value 的类型，由 `CacheManager.getCache` 返回的 `Cache` 必须强制入参的的键和值类型与配置的键和值类型相同。此时必须使用下面的方法来获取缓存\n\n```java\n<K, V> Cache<K, V> getCache(String cacheName, Class<K> keyType, Class<V> valueType);\n```\n\n当使用上面的方法时，缓存实现必须确保返回的缓存显式配置了键值类型。这给开发者提供了相比仅使用泛型更高级别的安全性。\n\n实现可以在可变缓存操作时做运行时类键值检查。\n\n当配置未定义所需的键和值类型，或者它们都定义为 `Object.class` 时，在请求缓存时，不需要实现来执行运行时类型检查。 要在不检查使用的情况下请求缓存使用：\n\n```java\n <K, V> Cache<K, V> Cache getCache(String cacheName);\n```\n\n在没有配置键值类型的情况下，尝试使用具有特定类型参数的 `getCache` 会引发 `IllegalArgumentException`。 对任何具有特定键和值类型配置的键或没有定义键或值类型或两者均为 `Object.class` 的任何 `Cache` 使用不带特定类型参数的 `getCache` 时，将返回不进行任何类型检查的 `Cache`。\n\n#### 例子\n\n在此示例中，缓存配置为具有字符串键类型和整数值类型。 然后，实现将确保声明的类型与配置的缓存匹配，否则将抛出`IllegalArgumentException`。\n\n```java\nCachingProvider cachingProvider = Caching.getCachingProvider();\nCacheManager cacheManager = cachingProvider.getCacheManager();\n\nMutableConfiguration<String, Integer> config = new\n    MutableConfiguration<String, Integer>();\nconfig.setTypes(String.class, Integer.class);\ncacheManager.createCache(\"simpleCache\", config);\n\n//... then later to get the cache without type information\nCache<String, Integer> simpleCache = cacheManager.getCache(\"simpleCache\",\n    String.class, Integer.class);\n\nsimpleCache.put(\"key1\", 3);\nInteger value2 = simpleCache.get(\"key1\");\n```\n\n尽管 Java Caching API 提供了用于编译和运行时类型安全的机制，但是类型检查仅适用于键和值的可验证类型，包括所有通用集合类型。\n例如，类型 `List<MyClass>` 在运行时不可修改，因此只能与类型 `List.class` 进行比较。\n\n## 过期策略\n\n如果条目已过期，它就不能从缓存中被获取到。如果 `Cache` 没有配置过期策略，默认用不过期\n\n虽然“用不过期”策略不自动过期条目，但是缓存实现可以支持手动驱逐。\n\n过期策略在配置时指定，过期策略需要实现 `ExpiryPolicy` 接口，接口定义如下：\n\n```java\npackage javax.cache.expiry;\n\n/**\n * Defines functions to determine when cache entries will expire based on\n * creation, access and modification operations.\n * <p>\n * Each of the functions return a new {@link Duration} that specifies the\n * amount of time that must pass before a cache entry is considered expired.\n * {@link Duration} has constants defined for useful durations.\n *\n * @author Brian Oliver\n * @author Greg Luck\n * @since 1.0\n * @see Duration\n */\npublic interface ExpiryPolicy {\n\n  /**\n   * Gets the {@link Duration} before a newly created Cache.Entry is considered\n   * expired.\n   * <p>\n   * This method is called by a caching implementation after a Cache.Entry is\n   * created, but before a Cache.Entry is added to a cache, to determine the\n   * {@link Duration} before an entry expires.  If a {@link Duration#ZERO}\n   * is returned the new Cache.Entry is considered to be already expired and\n   * will not be added to the Cache.\n   * <p>\n   * Should an exception occur while determining the Duration, an implementation\n   * specific default {@link Duration} will be used.\n   *\n   * @return the new {@link Duration} before a created entry expires\n   */\n  Duration getExpiryForCreation();\n\n  /**\n   * Gets the {@link Duration} before an accessed Cache.Entry is\n   * considered expired.\n   * <p>\n   * This method is called by a caching implementation after a Cache.Entry is\n   * accessed to determine the {@link Duration} before an entry expires.  If a\n   * {@link Duration#ZERO} is returned a Cache.Entry will be\n   * considered immediately expired.  Returning <code>null</code> will result\n   * in no change to the previously understood expiry {@link Duration}.\n   * <p>\n   * Should an exception occur while determining the Duration, an implementation\n   * specific default Duration will be used.\n   *\n   * @return the new {@link Duration} before an accessed entry expires\n   */\n  Duration  getExpiryForAccess();\n\n  /**\n   * Gets the {@link Duration} before an updated Cache.Entry is considered\n   * expired.\n   * <p>\n   * This method is called by the caching implementation after a Cache.Entry is\n   * updated to determine the {@link Duration} before the updated entry expires.\n   * If a {@link Duration#ZERO} is returned a Cache.Entry is considered\n   * immediately expired.  Returning <code>null</code> will result in no change\n   * to the previously understood expiry {@link Duration}.\n   * <p>\n   * Should an exception occur while determining the Duration, an implementation\n   * specific default Duration will be used.\n   *\n   * @return the new {@link Duration} before an updated entry expires\n   */\n  Duration getExpiryForUpdate();\n}\n```\n\n缓存条目在执行完指定操作一段时间后过期，这个时间间隔由 `javax.cache.expiry.Duration` 来定义。 `Duration` 由 `java.util.concurrent.TimeUnit` 和 `long durationAmount` 两部分组成，最小的时间单位是 `TimeUnit.MILLISECONDS`;\n\n过期时间由配置的过期策略和执行的缓存操作有关。下面是 `ExpiryPolicy` 接口中对于指定操作获取对应的时间间隔的方法\n\n- `getExpiryForCreation()` 条目创建时的有效时长\n- `getExpiryForAccess()` 条目被访问时新的有效时长\n- `getExpiryForUpdate()` 条目更新时新的有效时长\n\n当一个缓存实现调用了上面的三个方法,会返回下面几种结果其中之一：\n\n- 一个新的有效时长\n- `Duration.ZERO`，代表条目立即过期\n- `null`，`getExpiryForUpdate()` 和 `getExpiryForAccess()` 可能返回，代表不修改条目当前的有效时长。\n\n除了 `Duration#ZERO`，还定义了如下常量\n\n```java\n\n  /**\n   * ETERNAL (forever).\n   */\n  public static final Duration ETERNAL = new Duration();\n\n  /**\n   * One day.\n   */\n  public static final Duration ONE_DAY = new Duration(DAYS, 1);\n\n  /**\n   * One hour.\n   */\n  public static final Duration ONE_HOUR = new Duration(HOURS, 1);\n\n  /**\n   * Thirty minutes.\n   */\n  public static final Duration THIRTY_MINUTES = new Duration(MINUTES, 30);\n\n  /**\n   * Twenty minutes.\n   */\n  public static final Duration TWENTY_MINUTES = new Duration(MINUTES, 20);\n\n  /**\n   * Ten minutes.\n   */\n  public static final Duration TEN_MINUTES = new Duration(MINUTES, 10);\n\n  /**\n   * Five minutes.\n   */\n  public static final Duration FIVE_MINUTES = new Duration(MINUTES, 5);\n\n  /**\n   * One minute.\n   */\n  public static final Duration ONE_MINUTE = new Duration(MINUTES, 1);\n\n  /**\n   * Zero (no time).\n   */\n  public static final Duration ZERO = new Duration(SECONDS, 0);\n```\n\n下面的表格中描述了缓存方法如何与过期策略进行交互\n\n|缓存方法|`ExpiryPolicy.getExpiryForCreation`<br> 是否调用|`ExpiryPolicy.getExpiryForAccess`<br> 是否调用|`ExpiryPolicy.getExpiryForUpdate`<br> 是否调用|\n|---|---|---|---|\n|`boolean containsKey(K key)`|NO|NO|NO|\n|`V get(K key)`|NO (unless read-though caused a load)|YES|NO|\n|`Map<K,V> getAll(Collection<? extends K> keys)`|No (unless read-though caused a load)|YES|NO|\n|`V getAndPut(K key, V value)`|YES (when the key is not associated with an existing value)|NO|YES (when the key is associated with an existing value)|\n|`V getAndRemove(K key)`|NO|NO|NO|\n|`V getAndReplace(K key, V value)`|NO|NO|Yes (when the key is associated with an existing value)|\n|`CacheManager getCacheManager()`|NO|NO|NO|\n|`CacheConfiguration getConfiguration()`|NO|NO|NO|\n|`String getName()`|NO|NO|NO|\n|`Iterator<Cache.Entry<K, V>> iterator()`|NO|YES (when an entry is visited by an iterator)|NO|\n|`void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener listener)`|YES (when a key is not associated with a loaded value)|NO|YES (when a key is associated with a loaded value and the value should be replaced)|\n|`void put(K key, V value)`|YES (when the key is not associated with an existing value)|NO|YES (when the key is associated with an existing value)|\n|`void putAll(Map<? extends K,? extends V> map)`|YES (when the key is not associated with an existing value)|NO|YES(when the key is associated with an existing value)|\n|`boolean putIfAbsent(K key, V value)`|YES (when the key is not associated with an existing value)|NO|NO|\n|`boolean remove(K key)`|NO|NO|NO|\n|`boolean remove(K key, V oldValue)`|NO|YES (when the old value does not match the existing value)|NO|\n|`void removeAll()`|NO|NO|NO|\n|`void removeAll(Set<? extends K> keys)`|NO|NO|NO|\n|`<T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments)entryProcessor);`|Yes (for the following cases:<br>(1) setValue called and entry did not exist for key before invoke was called.<br>(2) if read-through enabled and getValue() is called and causes a new entry to be loaded for key)|Yes (when getValue was called and no other mutations occurred during entry processor execution. note: Create, modify or remove take precedence over Access)|Yes (when setValue was called and the entry already existed before entry processor was called)|\n|`<T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys, EntryProcessor<K, V, T> entryProcessor, Object... arguments);`|同 invoke|同 invoke|同 invoke|\n|`boolean replace(K key, V value)`|NO|NO|YES (when the key is associated with an existing value)|\n|`boolean replace(K key, V oldValue, V newValue)`|NO|YES (when value is not replaced)|YES (when value is replaced)|\n|`<T> T unwrap(Class<T> cls)`|NO|NO|NO|\n\n本规范预定义了五种过期策略，在 `javax.cache.expiry` 包下可以找到对应实现:\n\n- `CreatedExpiryPolicy` 创建后一段时间过期。\n- `ModifiedExpiryPolicy` 创建后一段时间过期，更新时刷新过期时间。\n- `AccessedExpiryPolicy` 创建后一段时间过期，访问时刷新过期时间。\n- `TouchedExpiryPolicy` 创建后一段时间过期，访问或更新时刷新过期时间。\n- `EternalExpiryPolicy` 用不过期，这是默认的过期策略。\n\n## 集成\n\n`javax.cache.integration` 包里提供了一些便于与外部资源整合的工具。\n\n下面定义了 `CacheLoader` 和 `CacheWriter` 类：\n\n```java\npackage javax.cache.integration;\n\nimport javax.cache.configuration.CompleteConfiguration;\nimport java.util.Map;\n\n/**\n * Used when a cache is read-through or when loading data into a cache via the\n * {@link javax.cache.Cache#loadAll(java.util.Set, boolean,\n * CompletionListener)} method.\n *\n * @param <K> the type of keys handled by this loader\n * @param <V> the type of values generated by this loader\n * @author Greg Luck\n * @author Yannis Cosmadopoulos\n * @see CompleteConfiguration#isReadThrough()\n * @see CacheWriter\n * @since 1.0\n */\npublic interface CacheLoader<K, V> {\n\n  /**\n   * Loads an object. Application developers should implement this\n   * method to customize the loading of a value for a cache entry. This method\n   * is called by a cache when a requested entry is not in the cache. If\n   * the object can\'t be loaded <code>null</code> should be returned.\n   *\n   * @param key the key identifying the object being loaded\n   * @return The value for the entry that is to be stored in the cache or\n   *         <code>null</code> if the object can\'t be loaded\n   * @throws CacheLoaderException if there is problem executing the loader.\n   */\n  V load(K key) throws CacheLoaderException;\n\n\n\n  /**\n   * Loads multiple objects. Application developers should implement this\n   * method to customize the loading of cache entries. This method is called\n   * when the requested object is not in the cache. If an object can\'t be loaded,\n   * it is not returned in the resulting map.\n   *\n   * @param keys keys identifying the values to be loaded\n   * @return A map of key, values to be stored in the cache.\n   * @throws CacheLoaderException if there is problem executing the loader.\n   */\n  Map<K, V> loadAll(Iterable<? extends K> keys) throws CacheLoaderException;\n}\n\n```\n\n```java\npackage javax.cache.integration;\n\n\nimport javax.cache.Cache;\nimport java.util.Collection;\n\n/**\n * A CacheWriter is used for write-through to an external resource.\n * <p>\n * Under Default Consistency, the non-batch writer methods are atomic with respect\n * to the corresponding cache operation.\n * <p>\n * For batch methods under Default Consistency, the entire cache operation\n * is not required to be atomic in {@link Cache} and is therefore not required to\n * be atomic in the writer. As individual writer operations can fail, cache\n * operations are not required to occur until after the writer batch method has\n * returned or, in the case of partial success, thrown an exception. In the case\n * of partial success, the collection of entries return must only contain\n * those entries that failed.\n * <p>\n * The entry passed into {@link #write(Cache.Entry)} is independent\n * of the cache mapping for that key, meaning that if the value changes in the\n * cache or is removed it does not change the entry.\n *\n * @param <K> the type of keys maintained by this map\n * @param <V> the type of mapped values\n * @author Greg Luck\n * @author Brian Oliver\n * @see CacheLoader\n * @since 1.0\n */\npublic interface CacheWriter<K, V> {\n\n\n  /**\n   * Write the specified value under the specified key to the external resource.\n   * <p>\n   * This method is intended to support both key/value creation and value update\n   * for a specific key.\n   *\n   * @param entry the entry to be written\n   * @throws CacheWriterException if the write fails. If thrown the\n   *                              cache mutation will not occur.\n   */\n  void write(Cache.Entry<? extends K, ? extends V> entry) throws CacheWriterException;\n\n  /**\n   * Write the specified entries to the external resource. This method is intended\n   * to support both insert and update.\n   * <p>\n   * The order that individual writes occur is undefined, as\n   * {@link Cache#putAll(java.util.Map)} also has undefined ordering.\n   * <p>\n   * If this operation fails (by throwing an exception) after a partial success,\n   * the writer must remove any successfully written entries from the entries\n   * collection so that the caching implementation knows what succeeded and can\n   * mutate the cache.\n   *\n   * @param entries a mutable collection to write. Upon invocation, it contains\n   *                the entries to write for write-through. Upon return the\n   *                collection must only contain entries that were not\n   *                successfully written. (see partial success above)\n   * @throws CacheWriterException if one or more of the writes fail. If\n   *                              thrown cache mutations will occur for\n   *                              entries that succeeded.\n   */\n  void writeAll(Collection<Cache.Entry<? extends K, ? extends V>> entries) throws\n      CacheWriterException;\n\n\n  /**\n   * Delete the cache entry from the external resource.\n   * <p>\n   * Expiry of a cache entry is not a delete hence will not cause this method to\n   * be invoked.\n   * <p>\n   * This method is invoked even if no mapping for the key exists.\n   *\n   * @param key the key that is used for the delete operation\n   * @throws CacheWriterException if delete fails. If thrown the cache delete will\n   *                              not occur.\n   */\n  void delete(Object key) throws CacheWriterException;\n\n\n  /**\n   * Remove data and keys from the external resource for the given collection of\n   * keys, if present.\n   * <p>\n   * The order that individual deletes occur is undefined, as\n   * {@link Cache#removeAll(java.util.Set)} also has undefined ordering.\n   * <p>\n   * If this operation fails (by throwing an exception) after a partial success,\n   * the writer must remove any successfully written entries from the entries\n   * collection so that the caching implementation knows what succeeded and can\n   * mutate the cache.\n   * <p>\n   * Expiry of a cache entry is not a delete hence will not cause this method to\n   * be invoked.\n   * <p>\n   * This method may include keys even if there is no mapping for that key,\n   * in which case the data represented by that key should be removed from the\n   * underlying resource.\n   *\n   * @param keys a mutable collection of keys for entries to delete. Upon\n   *             invocation, it contains the keys to delete for write-through.\n   *             Upon return the collection must only contain the keys that were\n   *             not successfully deleted. (see partial success above)\n   * @throws CacheWriterException if one or more deletes fail. If thrown\n   *                              cache deletes will occur for entries that\n   *                              succeeded.\n   */\n  void deleteAll(Collection<?> keys) throws CacheWriterException;\n}\n```\n\n### 缓存加载\n\n`loadAll` 方法用来将外部资源加载到缓存中，定义如下：\n\n```java\n/**\n* Asynchronously loads the specified entries into the cache using the\n* configured {@link CacheLoader} for the given keys.\n* <p>\n* If an entry for a key already exists in the Cache, a value will be loaded\n* if and only if <code>replaceExistingValues</code> is true.   If no loader\n* is configured for the cache, no objects will be loaded.  If a problem is\n* encountered during the retrieving or loading of the objects,\n* an exception is provided to the {@link CompletionListener}.  Once the\n* operation has completed, the specified CompletionListener is notified.\n* <p>\n* Implementations may choose to load multiple keys from the provided\n* {@link Set} in parallel.  Iteration however must not occur in parallel,\n* thus allow for non-thread-safe {@link Set}s to be used.\n* <p>\n* The thread on which the completion listener is called is implementation\n* dependent. An implementation may also choose to serialize calls to\n* different CompletionListeners rather than use a thread per\n* CompletionListener.\n*\n* @param keys                  the keys to load\n* @param replaceExistingValues when true existing values in the Cache will\n*                              be replaced by those loaded from a CacheLoader\n* @param completionListener    the CompletionListener (may be null)\n* @throws NullPointerException  if keys is null or if keys contains a null.\n* @throws IllegalStateException if the cache is {@link #isClosed()}\n* @throws CacheException        thrown if there is a problem performing the\n*                               load. This may also be thrown on calling if\n*                               there are insufficient threads available to\n*                               perform the load.\n* @throws ClassCastException    if the implementation is configured to perform\n*                               runtime-type-checking, and the key or value\n*                               types are incompatible with those that have been\n*                               configured for the {@link Cache}\n*/\nvoid loadAll(Set<? extends K> keys, boolean replaceExistingValues,\nCompletionListener completionListener);\n```\n\n为了使用这个方法，在创建缓存时必须配置 `CacheLoader`。不需要将缓存配置为 `read-through` 模式。\n\n加载可能耗时较长，因为这个原因，可以给该方法传递一个 `CompletionListener`，来接收加载完成或加载异常的通知。该接口的定义如下：\n\n```java\npackage javax.cache.integration;\n\n/**\n * A CompletionListener is implemented by an application when it needs to be\n * notified of the completion of some Cache operation.\n * <p>\n * When the operation is complete, the Cache provider notifies the application\n * by calling the {@link #onCompletion()} method of the {@link\n * CompletionListener}.\n * <p>\n * If the operation fails for any reason, the Cache provider calls the\n * {@link #onException(Exception)} method of the {@link CompletionListener}.\n * <p>\n * To support a Java Future-based approach to synchronously wait for a Cache\n * operation to complete, use a {@link CompletionListenerFuture}.\n * <p>\n * A Cache provider will use an implementation specific thread to call methods\n * on this interface.\n *\n * @author Brian Oliver\n * @since 1.0\n * @see CompletionListenerFuture\n */\npublic interface CompletionListener {\n\n  /**\n   * Notifies the application that the operation completed successfully.\n   */\n  void onCompletion();\n\n  /**\n   * Notifies the application that the operation failed.\n   *\n   * @param e the Exception that occurred\n   */\n  void onException(Exception e);\n}\n```\n\n本规范也提供了一个阻塞版本的 `CompletionListener` 实现，`CompletionListenerFuture`。它实现了 `CompletionListener` 和 `Future` 两个接口。如果 `onException(Exception e)` 方法被调用，异常会被重新封装成 `ExecutionException` 由 `Future get()/get(long timeout, TimeUnit unit)` 重抛。\n\n#### 例子\n\n```java\nHashSet<String> keys = new HashSet<>();\nkeys.add(\"23432lkj\");\nkeys.add(\"4fsdldkj\");\n\n\n//create a completion future to use to wait for loadAll\nCompletionListenerFuture future = new CompletionListenerFuture();\n\n//load the values for the set of keys, replacing those that may already\n//exist in the cache\ncache.loadAll(keys, true, future);\n\n//wait for the cache to load the keys\ntry {\n  future.get();\n} catch (InterruptedException e) {\n  //future interrupted\n  e.printStackTrace();\n} catch (ExecutionException e) {\n  //throwable was what was sent to onException(Exception e)\n  Throwable throwable = e.getCause();\n}\n\n```\n\n`loadAll` 方法用来从外部资源预加载数据非常有用。一种用法是应用程序假定缓存一定存在，不然会有异常；另一种是用来做缓存预热，如果缓存中没有数据，不会导致错误，但是会对性能有影响。\n\n### `Read-Through` 模式\n\n`Read-Through` 模式和非`Read-Through` 模式几乎完全相同，不同之处就在于当缓存中没有数据时，会调用 `CacheLoader` 去加载。\n\n通过 `MutableConfiguration`  上调用 `setReadThrough(boolean isReadThrough)` 来配置该模式，与该模式配套的 `CacheLoader Factory` 也必须配置。\n\n下表用于描述 `Cache` 的那些方法会使用该模式加载数据：\n\n|方法|启用 Read-Through|\n|---|---|\n|`boolean containsKey(K key)`| NO|\n|`V get(K key)`| YES |\n|`Map<K,V> getAll(Collection<? extends K> keys)`|YES, 调用 `loadAll()`|\n|`V getAndPut(K key, V value)`|NO|\n|`V getAndRemove(K key)`|NO|\n|`V getAndReplace(K key, V value)`|NO|\n|`<T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments)entryProcessor);`|当 `getValue()` 被调用时|\n|`<T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys,EntryProcessor<K, V, T> entryProcessor, Object... arguments);`|当 `getValue()` 被调用时|\n|`Iterator<Cache.Entry<K, V>> iterator()`|NO|\n|`void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener listener)`|YES,使用 `CacheLoader.loadAll()`，不管当前缓存是否是 Read-Through 模式|\n|`void put(K key, V value)`|NO|\n|`void putAll(Map<? extends K,? extends V> map)`|NO|\n|`boolean putIfAbsent(K key, V value)`|NO|\n|`boolean remove(K key)`|NO|\n|`boolean remove(K key, V oldValue)`|NO|\n|`void removeAll()`|NO|\n|`void removeAll(Set<? extends K> keys)`|NO|\n|`boolean replace(K key, V value)`|NO|\n|`boolean replace(K key, V oldValue, V newValue)`|NO|\n\nRead-Through 模式的使用惯例是懒加载。在屏蔽缓存加载的细节上，这种模式也很有用。\n\n当 一些或全部数据需要被预先加载时，使用 `loadAll` 方法。\n\n### `Write-Through` 模式\n\n`Write-Through` 模式和非`Write-Through` 模式几乎完全相同，不同之处就在于当缓存数据变更时，会调用 `CacheWriter`。\n\n通过 `MutableConfiguration`  上调用 `setWriteThrough(boolean isWriteThrough)` 来配置该模式，与该模式配套的 `CacheWriter Factory` 也必须配置。`CacheWriter` 用来更新/删除外部资源。\n\n下表用于描述 `Cache` 的那些方法会使用该模式将变更写到外部资源：\n\n|方法|启用 Write-Through|\n|---|---|\n|`boolean containsKey(K key)`| NO|\n|`V get(K key)`| NO |\n|`Map<K,V> getAll(Collection<? extends K> keys)`|NO|\n|`V getAndPut(K key, V value)`|YES|\n|`V getAndRemove(K key)`|YES|\n|`V getAndReplace(K key, V value)`|当Key能查到对应Value时|\n|`<T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments)entryProcessor);`|当 `setValue()` 被调用时|\n|`<T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys,EntryProcessor<K, V, T> entryProcessor, Object... arguments);`|当 `setValue()` 被调用时|\n|`Iterator<Cache.Entry<K, V>> iterator()`|NO|\n|`void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener listener)`|NO|\n|`void put(K key, V value)`|YES|\n|`void putAll(Map<? extends K,? extends V> map)`|YES，将会调用 `writeAll`|\n|`boolean putIfAbsent(K key, V value)`|返回true时|\n|`boolean remove(K key)`|YES，不管key是否存在|\n|`boolean remove(K key, V oldValue)`|返回true时|\n|`void removeAll()`|YES，将会调用 `deleteAll`|\n|`void removeAll(Set<? extends K> keys)`|YES, 不管key是否存在|\n|`void clear()`|NO|\n|`boolean replace(K key, V value)`|返回true时|\n|`boolean replace(K key, V oldValue, V newValue)`|返回true时|\n\n`Write-Through` 主要用于在缓存更新时对外部资源进行更新。该模式对用户屏蔽了写入外部资源的细节。\n\n## 缓存条目监听器\n\n`javax.cache.event` 包下包括了用户处理 `Cache` 产生事件的类和接口。\n\n### 事件和事件类型\n\n`CacheEntryEvent` 定义如下：\n\n```java\npackage javax.cache.event;\n\nimport javax.cache.Cache;\nimport javax.cache.configuration.CacheEntryListenerConfiguration;\nimport java.util.EventObject;\n\n/**\n * A Cache entry event base class.\n *\n * @param <K> the type of key\n * @param <V> the type of value\n * @author Greg Luck\n * @since 1.0\n */\npublic abstract class CacheEntryEvent<K, V> extends EventObject\n    implements Cache.Entry<K, V> {\n\n  private EventType eventType;\n\n  /**\n   * Constructs a cache entry event from a given cache as source\n   *\n   * @param source the cache that originated the event\n   * @param eventType the event type for this event\n   */\n  public CacheEntryEvent(Cache source, EventType eventType) {\n    super(source);\n    this.eventType = eventType;\n  }\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public final Cache getSource() {\n    return (Cache) super.getSource();\n  }\n\n  /**\n   * Returns the value stored in the cache when this entry was created or updated.\n   * <p>\n   * The value will be available\n   * for {@link CacheEntryCreatedListener} and {@link CacheEntryUpdatedListener}.\n   * Returns the same value as {@link #getOldValue()} for\n   * {@link CacheEntryExpiredListener} and {@link CacheEntryRemovedListener}.\n   * Cache clients that need to maintain compatibility with JSR107 version 1.0\n   * cache implementations, need to use this method for retrieving the expired\n   * or removed value. When using cache implementations compatible with JSR107\n   * version 1.1, clients should prefer the method {@link #getOldValue()}.\n   *\n   * @return the value corresponding to this entry\n   * @see #getOldValue()\n   */\n  @Override\n  public abstract V getValue();\n\n  /**\n   * Returns the previous value that existed for entry in the cache before\n   * modification or removal.\n   *\n   * The old value will be available\n   * for {@link CacheEntryUpdatedListener}, {@link CacheEntryExpiredListener}\n   * and {@link CacheEntryRemovedListener}\n   * if {@link CacheEntryListenerConfiguration#isOldValueRequired()} is true.\n   * The old value may be available for {@link CacheEntryUpdatedListener},\n   * {@link CacheEntryExpiredListener} and {@link CacheEntryRemovedListener}\n   * if {@link CacheEntryListenerConfiguration#isOldValueRequired()} is false.\n   *\n   * @return the previous value or <code>null</code> if there was no previous\n   * value or the previous value is not available\n   */\n  public abstract V getOldValue();\n\n  /**\n   * Whether the old value is available. The old value will be available\n   * for {@link CacheEntryUpdatedListener}, {@link CacheEntryExpiredListener}\n   * and {@link CacheEntryRemovedListener}\n   * if {@link CacheEntryListenerConfiguration#isOldValueRequired()} is true.\n   * The old value <b>may</b> be available for {@link CacheEntryUpdatedListener},\n   * {@link CacheEntryExpiredListener} and {@link CacheEntryRemovedListener}\n   * if {@link CacheEntryListenerConfiguration#isOldValueRequired()} is false.\n   *\n   * @return true if the old value is definitely available\n   */\n  public abstract boolean isOldValueAvailable();\n\n  /**\n   * Gets the event type of this event\n   *\n   * @return the event type.\n   */\n  public final EventType getEventType() {\n    return eventType;\n  }\n}\n```\n\n`EventType` 定义如下：\n\n```java\npackage javax.cache.event;\n\n/**\n * The type of event received by the listener.\n *\n * @author Greg Luck\n * @since 1.0\n */\npublic enum EventType {\n\n  /**\n   * An event type indicating that the cache entry was created.\n   */\n  CREATED,\n\n  /**\n   * An event type indicating that the cache entry was updated. i.e. a previous\n   * mapping existed\n   */\n  UPDATED,\n\n\n  /**\n   * An event type indicating that the cache entry was removed.\n   */\n  REMOVED,\n\n\n  /**\n   * An event type indicating that the cache entry has expired.\n   */\n  EXPIRED\n\n}\n```\n\n#### `CacheEntryEvent` 中 `getValue` 和 `getOldValue` 的可用性\n\n下表总结了 `isOldValueRequired` 为 true 时，各个监听器调用 `getValue` 和 `getOldValue` 时的返回值。\n\n|`CacheEntryEvent`|`CacheEntryCreatedListener`|`CacheEntryUpdatedListener`|`CacheEntryRemovedListener`<br>`CacheEntryExpiredListener`|\n|---|---|---|---|\n|`getValue`|新值|新值|旧值|\n|`getOldValue`|`null`|旧值|旧值|\n\n下表总结了 `isOldValueRequired` 为 false 时，各个监听器调用 `getValue` 和 `getOldValue` 时的返回值。\n\n|`CacheEntryEvent`|`CacheEntryCreatedListener`|`CacheEntryUpdatedListener`|`CacheEntryRemovedListener`<br>`CacheEntryExpiredListener`|\n|---|---|---|---|\n|`getValue`|新值|新值|旧值或`null`|\n|`getOldValue`|`null`|旧值或`null`|旧值`null`|\n\n当 `isOldValueRequired` 为 false 时，缓存实现可以自由选择是否返回旧值。\n\n### 缓存条目监听器\n\n`CacheEntryListener` 通过 `CacheEntryListenerConfiguration` 注册到 `Cache` 中。`CacheEntryListener` 接口定义如下：\n\n```java\npackage javax.cache.event;\n\nimport java.util.EventListener;\n\n/**\n * A tagging interface for cache entry listeners.\n * <p>\n * Sub-interfaces exist for the various cache events allowing a listener to be\n * created that implements only those listeners it is interested in.\n * <p>\n * Listeners should be implemented with care. In particular it is important to\n * consider their impact on performance and latency.\n * <p>\n * Listeners:\n * <ul>\n * <li>are fired after the entry is mutated in the cache</li>\n * <li>if synchronous are fired, for a given key, in the order that events\n * occur</li>\n * <li>block the calling thread until the listener returns,\n * where the listener was registered as synchronous</li>\n * <li>that are asynchronous iterate through multiple events with an undefined\n * ordering, except that events on the same key are in the order that the\n * events occur.</li>\n * </ul>\n * Listeners follow the observer pattern. An exception thrown by a\n * listener does not cause the cache operation to fail.\n * <p>\n * Listeners can only throw {@link CacheEntryListenerException}. Caching\n * implementations must catch any other {@link Exception} from a listener, then\n * wrap and rethrow it as a {@link CacheEntryListenerException}.\n * <p>\n * A listener that mutates a cache on the CacheManager may cause a deadlock.\n * Detection and response to deadlocks is implementation specific.\n *\n * @param <K> the type of key\n * @param <V> the type of value\n * @author Yannis Cosmadopoulos\n * @author Greg Luck\n * @see CacheEntryCreatedListener\n * @see CacheEntryUpdatedListener\n * @see CacheEntryRemovedListener\n * @see CacheEntryExpiredListener\n * @see EventType\n * @since 1.0\n */\npublic interface CacheEntryListener<K, V> extends EventListener {\n\n}\n```\n\n对应不同的 `EventType`，本规范定义了四个子接口。\n\n```java\n/**\n * Invoked after a cache entry is created, or if a batch call is made, after the\n * entries are created.\n * <p>\n * If an entry for the key existed prior to the operation it is not invoked,\n * instead {@link CacheEntryUpdatedListener} is invoked.\n *\n * @param <K> the type of key\n * @param <V> the type of value\n * @author Yannis Cosmadopoulos\n * @author Greg Luck\n * @see CacheEntryUpdatedListener\n * @since 1.0\n */\npublic interface CacheEntryCreatedListener<K, V> extends CacheEntryListener<K, V> {\n\n  /**\n   * Called after one or more entries have been created.\n   *\n   * @param events The entries just created.\n   * @throws CacheEntryListenerException if there is problem executing the listener\n   */\n  void onCreated(Iterable<CacheEntryEvent<? extends K, ? extends V>> events)\n      throws CacheEntryListenerException;\n\n}\n```\n\n```java\npackage javax.cache.event;\n\n/**\n * Invoked if an existing cache entry is updated, or if a batch call is made,\n * after the entries are updated.\n *\n * @param <K> the type of key\n * @param <V> the type of value\n * @author Yannis Cosmadopoulos\n * @author Greg Luck\n * @see CacheEntryCreatedListener\n * @since 1.0\n */\npublic interface CacheEntryUpdatedListener<K, V> extends CacheEntryListener<K, V> {\n\n  /**\n   * Called after one or more entries have been updated.\n   *\n   * @param events The entries just updated.\n   * @throws CacheEntryListenerException if there is problem executing the listener\n   */\n  void onUpdated(Iterable<CacheEntryEvent<? extends K, ? extends V>> events)\n      throws CacheEntryListenerException;\n}\n```\n\n```java\npackage javax.cache.event;\n\n\n/**\n * Invoked if a cache entry or entries are evicted due to expiration.\n *\n * @param <K> the type of key\n * @param <V> the type of value\n * @author Greg Luck\n * @since 1.0\n */\npublic interface CacheEntryExpiredListener<K, V> extends CacheEntryListener<K, V> {\n\n  /**\n   * Called after one or more entries have been expired by the cache. This is not\n   * necessarily when an entry is expired, but when the cache detects the expiry.\n   *\n   * @param events The entries just removed.\n   * @throws CacheEntryListenerException if there is problem executing the listener\n   */\n  void onExpired(Iterable<CacheEntryEvent<? extends K, ? extends V>> events)\n      throws CacheEntryListenerException;\n\n}\n```\n\n```java\npackage javax.cache.event;\n\n/**\n * Invoked if a cache entry is removed, or if a batch call is made, after the\n * entries are removed.\n *\n * @param <K> the type of key\n * @param <V> the type of value\n * @author Yannis Cosmadopoulos\n * @author Greg Luck\n * @since 1.0\n */\npublic interface CacheEntryRemovedListener<K, V> extends CacheEntryListener<K, V> {\n\n  /**\n   * Called after one or more entries have been removed. If no entry existed for\n   * a key an event is not raised for it.\n   *\n   * @param events The entries just removed.\n   * @throws CacheEntryListenerException if there is problem executing the listener\n   */\n  void onRemoved(Iterable<CacheEntryEvent<? extends K, ? extends V>> events)\n      throws CacheEntryListenerException;\n\n\n}\n```\n\n这样设计的初衷是为了很好的支持分布式监听器的实现。\n\n### 监听器注册\n\n监听器和 `Cache` 可能不在同一个进程。为了避免监听器实例不支持序列化的情况，我们使用 `CacheEntryListenerConfiguration` 来传递配置。该配置可以在初始化时使用 `MutableConfiguation.addCacheEntryListenerConfiguration` 配置，也可以使用 `Cache.registerCacheEntryListener` 在运行时注册。\n\n运行时注销监听器可以使用 `Cache.deregisterCacheEntryListener`。\n\n```java\npackage javax.cache.configuration;\n\nimport javax.cache.event.CacheEntryEventFilter;\nimport javax.cache.event.CacheEntryListener;\nimport java.io.Serializable;\n\n/**\n * Defines the configuration requirements for a\n * {@link CacheEntryListener} and a {@link Factory} for its\n * creation.\n *\n * @param <K> the type of keys\n * @param <V> the type of values\n * @author Brian Oliver\n * @author Greg Luck\n * @since 1.0\n */\npublic interface CacheEntryListenerConfiguration<K, V> extends Serializable {\n  /**\n   * Obtains the {@link Factory} for the\n   * {@link CacheEntryListener}.\n   *\n   * @return the {@link Factory} for the\n   *         {@link CacheEntryListener}\n   */\n  Factory<CacheEntryListener<? super K, ? super V>> getCacheEntryListenerFactory();\n\n  /**\n   * Determines if the old value should be provided to the\n   * {@link CacheEntryListener}.\n   *\n   * @return <code>true</code> if the old value is required by the\n   *         {@link CacheEntryListener}\n   */\n  boolean isOldValueRequired();\n\n  /**\n   * Obtains the {@link Factory} for the {@link CacheEntryEventFilter} that should be\n   * applied prior to notifying the {@link CacheEntryListener}.\n   * <p>\n   * When <code>null</code> no filtering is applied and all appropriate events\n   * are notified.\n   *\n   * @return the {@link Factory} for the\n   *         {@link CacheEntryEventFilter} or <code>null</code>\n   *         if no filtering is required\n   */\n  Factory<CacheEntryEventFilter<? super K, ? super V>>\n  getCacheEntryEventFilterFactory();\n\n  /**\n   * Determines if the thread that caused an event to be created should be\n   * blocked (not return from the operation causing the event) until the\n   * {@link CacheEntryListener} has been notified.\n   *\n   * @return <code>true</code> if the thread that created the event should block\n   */\n  boolean isSynchronous();\n}\n```\n\n为了便于使用，本规范提供了一个实现 `javax.cache.configuration.MutableCacheEntryListenerConfiguration`\n\n### 监听器的调用\n\n缓存监听器：\n\n- 条目变更时被触发。\n- 如果是同步的，对应一个指定的 key，事件处理的顺序是事件发生的顺序，在监听器处理完之前会阻塞调用线程。\n- 如果是异步的，多个事件的遍历顺序未定义，但是对于同一个key 的事件，必须按照事件发生的顺序来处理。\n\n监听器使用观察者模式，缓存监听器内的异常不会导致缓存操作失败。\n\n监听器可能会导致死锁，对死锁的检测和响应取决于实现。\n\n对于每个事件来说，特定的监听器最多只被调用一次。该监听器的调用指的是集群范围内的调用，而不是每个节点的。\n\n监听器和原始的事件可以不在同一个进程。在分布式实现中，监听器可以位于任何位置。\n\n监听器可能有对应的事件过滤器 `CacheEntryEventFilter`，这是 `CacheEntryListenerConfiguration` 配置的一部分。接口定义如下：\n\n```java\npackage javax.cache.event;\n\n/**\n * A function that may be used to check {@link CacheEntryEvent}s prior to being\n * dispatched to {@link CacheEntryListener}s.\n * <p>\n * A filter must not create side effects.\n *\n * @param <K> the type of key\n * @param <V> the type of value\n * @author Greg Luck\n * @author Brian Oliver\n * @since 1.0\n */\npublic interface CacheEntryEventFilter<K, V> {\n\n  /**\n   * Evaluates specified {@link CacheEntryEvent}.\n   *\n   * @param event the event that occurred\n   * @return true if the evaluation passes, otherwise false.\n   *         The effect of returning true is that listener will be invoked\n   * @throws CacheEntryListenerException if there is problem executing the listener\n   */\n  boolean evaluate(CacheEntryEvent<? extends K, ? extends V> event)\n      throws CacheEntryListenerException;\n}\n```\n\n`CacheEntryEventFilter` 不需要和原始事件在同一进程，在分布式实现中，过滤器可以在可以提供最好性能的位置实现。\n\n下表中总结了缓存操作可能触发的监听器。条件是触发缓存操作前调班的状态，过期总是不触发的，确切的过期时间由缓存实现来决定。\n\n|方法|创建|过期|删除|更新|\n|---|---|---|---|---|\n|`boolean containsKey(K key)`|NO|NO|NO|NO|\n|`V get(K key)`|Yes, if created by read-through|No|No|No|\n|`Map<K,V> getAll(Collection<? extends K> keys)`|Yes, if created by read-through|No|No|No|\n|`V getAndPut(K key, V value)`|if missing|No|No|if there|\n|`V getAndRemove(K key)`|No|No|if there|No|\n|`V getAndReplace(K key, V value)`|No|No|No|if there|\n|`<T> T invoke(K key, EntryProcessor<K, V> entryProcessor);`|Yes, if setValue() created an entry, or getValue() created an entry by read-through|No|Yes, if remove() did remove an entry|Yes, if setValue() updated an entry|\n|`<T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys, EntryProcessor<K, V, T> entryProcessor, Object... arguments);`|Yes, if setValue() created an entry, or getValue() created an entry by read-through|No|Yes, if remove() did remove an entry|Yes, if setValue() updated an entry|\n|`Iterator<Cache.Entry<K, V>> iterator()`|No|No|Yes, if remove() did remove an entry|No|\n|`void loadAll(Set<? extends K> keys,boolean replaceExistingValues, CompletionListener completionListener);`|if missing|No|No|if there|\n|`void put(K key, V value)`|if missing|No|No|if there|\n|`void putAll(Map<? extends K,? extends V> map)`|if missing|No|No|if there|\n|`boolean putIfAbsent(K key, V value)`|if missing|No|No|No|\n|`boolean remove(K key)`|No|No|if there|No|\n|`boolean remove(K key, V oldValue)`|No|No|if there && equal|No|\n|`void removeAll()`|No|No|if there|No|\n|`void removeAll(Set<? extends K> keys)`|No|No|if there|No|\n|`boolean replace(K key, V value)`|No|No|No|if there|\n|`boolean replace(K key, V oldValue, V newValue)`|No|No|No|if there && equal|\n\n## Entry Processors\n\n`javax.cache.processor.EntryProcessor` 是一个可调用函数，类似于 `java.util.concurrent.Callable`，它提供了一种有效执行复合缓存操作的一种方式，不通过事务或显式加锁来原子性的访问，更新，删除指定的 key。\n\n使用 `Cache.invoke` 或 `Cache.invokeAll` 时，`MutableEntry` 会作为入参传递给 `EntryProcessor`，此时该处理器拥有该实体的排他访问权。\n\n`MutableEntry` 接口定义如下：\n\n```java\npackage javax.cache.processor;\n\nimport javax.cache.Cache;\nimport javax.cache.integration.CacheLoader;\n\n/**\n * A mutable representation of a {@link javax.cache.Cache.Entry}.\n * <p>\n * Mutable entries are used by {@link EntryProcessor}s to mutate\n * {@link Cache.Entry}s in place, atomically.\n *\n * @param <K> the type of key\n * @param <V> the type of value\n *\n * @author Greg Luck\n * @since 1.0\n * @see EntryProcessor\n */\npublic interface MutableEntry<K, V> extends Cache.Entry<K, V> {\n\n  /**\n   * Checks for the existence of the entry in the cache\n   *\n   * @return true if the entry exists\n   */\n  boolean exists();\n\n  /**\n   * Removes the entry from the Cache.\n   * <p>\n   * This has the same semantics as calling {@link Cache#remove}.\n   */\n  void remove();\n\n  /**\n   * Returns the value stored in the cache.\n   * <p>\n   * If the cache is configured to use read-through, and this method\n   * would return null because the entry is missing from the cache,\n   * the Cache\'s {@link CacheLoader} is called in an attempt to load\n   * the entry.\n   *\n   * @return the value corresponding to this entry\n   */\n  V getValue();\n\n  /**\n   * Sets or replaces the value associated with the key.\n   * <p>\n   * If {@link #exists} is false and setValue is called\n   * then a mapping is added to the cache visible once the EntryProcessor\n   * completes. Moreover a second invocation of {@link #exists()}\n   * will return true.\n   *\n   * @param value the value to update the entry with\n   * @throws ClassCastException if the implementation supports and is\n   *                            configured to perform runtime-type-checking,\n   *                            and value type is incompatible with that\n   *                            which has been configured for the\n   *                            {@link Cache}\n   */\n  void setValue(V value);\n}\n```\n\n应用可能想要原子的检查条目的值，计算新值，更新条目并返回其他值，可以考虑使用 `EntryProcessor` 来实现这个操作。\n\n`javax.cache.processor.EntryProcessor` 接口定义如下：\n\n```java\npackage javax.cache.processor;\n\nimport javax.cache.Cache;\nimport javax.cache.event.CacheEntryListener;\nimport javax.cache.expiry.ExpiryPolicy;\nimport javax.cache.integration.CacheWriter;\n\n\n/**\n * An invocable function that allows applications to perform compound operations\n * on a {@link javax.cache.Cache.Entry} atomically, according to the defined\n * consistency of a {@link Cache}.\n * <p>\n * Any {@link javax.cache.Cache.Entry} mutations will not take effect until after\n * the {@link EntryProcessor#process(MutableEntry, Object...)} method has completed\n * execution.\n * <p>\n * If an exception is thrown by an {@link EntryProcessor}, a Caching Implementation\n * must wrap any {@link Exception} thrown wrapped in an {@link\n * EntryProcessorException}. If this occurs no mutations will be made to the\n * {@link javax.cache.Cache.Entry}.\n * <p>\n * Implementations may execute {@link EntryProcessor}s in situ, thus avoiding\n * locking, round-trips and expensive network transfers.\n *\n * <h3>Effect of {@link MutableEntry} operations</h3>\n * {@link javax.cache.Cache.Entry} access, via a call to\n * {@link javax.cache.Cache.Entry#getValue()}, will behave as if\n * {@link Cache#get(Object)} was called for the key.  This includes updating\n * necessary statistics, consulting the configured {@link ExpiryPolicy} and loading\n * from a configured {@link javax.cache.integration.CacheLoader}.\n * <p>\n * {@link javax.cache.Cache.Entry} mutation, via a call to\n * {@link MutableEntry#setValue(Object)}, will behave as if {@link\n * Cache#put(Object, Object)} was called for the key. This includes updating\n * necessary statistics, consulting the configured {@link\n * ExpiryPolicy}, notifying {@link CacheEntryListener}s and writing to a\n * configured {@link CacheWriter}.\n * <p>\n * {@link javax.cache.Cache.Entry} removal, via a call to\n * {@link MutableEntry#remove()}, will behave as if {@link Cache#remove(Object)}\n * was called for the key. This includes updating necessary statistics, notifying\n * {@link CacheEntryListener}s and causing a delete on a configured\n * {@link CacheWriter}.\n * <p>\n * As implementations may choose to execute {@link EntryProcessor}s remotely,\n * {@link EntryProcessor}s, together with specified parameters and return\n * values, may be required to implement {@link java.io.Serializable}.\n *\n * <h3>Effect of multiple {@link MutableEntry} operations performed by one {@link\n * EntryProcessor}</h3>\n * Only the net effect of multiple operations has visibility outside of the Entry\n * Processor. The entry is locked by the entry processor for the entire scope\n * of the entry processor, so intermediate effects are not visible.\n * <h4>Example 1</h4>\n * In this example, an {@link EntryProcessor} calls:\n * <ol>\n * <li>{@link MutableEntry#getValue()}</li>\n * <li>{@link MutableEntry#setValue(Object)}</li>\n * <li>{@link MutableEntry#getValue()}</li>\n * <li>{@link MutableEntry#setValue(Object)}</li>\n * </ol>\n * This will have the following {@link Cache} effects:\n * <br>\n * Final value of the cache: last setValue<br>\n * Statistics: one get and one put as the second get and the first put are\n * internal to the EntryProcessor.<br>\n * Listeners: second put will cause either a put or an update depending on whether\n * there was an initial value for the entry.<br>\n * CacheLoader: Invoked by the first get only if the entry is not present, a\n * loader was registered and read through is enabled.<br>\n * CacheWriter: Invoked by the second put only as the first put was internal to\n * the Entry Processor.<br>\n * ExpiryPolicy: The first get and the second put only are visible to the\n * ExpiryPolicy.<br>\n *\n * <h4>Example 2</h4>\n * In this example, an {@link EntryProcessor} calls:\n * <ol>\n * <li>{@link MutableEntry#getValue()}</li>\n * <li>{@link MutableEntry#remove()}}</li>\n * <li>{@link MutableEntry#getValue()}</li>\n * <li>{@link MutableEntry#setValue(Object)}</li>\n * </ol>\n * This will have the following {@link Cache} effects:\n * <br>\n * Final value of the cache: last setValue<br>\n * Statistics: one get and one put as the second get and the first put are\n * internal to the EntryProcessor.<br>\n * Listeners: second put will cause either a put or an update depending on whether\n * there was an initial value for the entry.<br>\n * CacheLoader: Invoked by the first get only if the entry is not present, a loader\n * was registered and read through is enabled.<br>\n * CacheWriter: Invoked by the second put only as the first put was internal to\n * the Entry Processor.<br>\n * ExpiryPolicy: The first get and the second put only are visible to the\n * ExpiryPolicy.<br>\n *\n * <h4>Example 3</h4>\n * In this example, an {@link EntryProcessor} calls:\n * <ol>\n * <li>{@link MutableEntry#getValue()}</li>\n * <li>{@link MutableEntry#setValue(Object)}}</li>\n * <li>{@link MutableEntry#getValue()}</li>\n * <li>{@link MutableEntry#setValue(Object)}</li>\n * <li>{@link MutableEntry#remove()}</li>\n * </ol>\n * This will have the following {@link Cache} effects:\n * <br>\n * Final value of the cache: the entry is removed if it was present<br>\n * Statistics: one get and one remove as the second get and the two puts are\n * internal to the EntryProcessor.<br>\n * Listeners: remove if there was initial value in the cache, otherwise no\n * listener invoked.\n * <br> CacheLoader: Invoked by the first get only if the entry is not present,\n * a loader was registered and read through is enabled.\n * <br> CacheWriter: Invoked by the remove only as the two puts are internal to\n * the Entry Processor, provided that the first #getValue was non-null.<br>\n * ExpiryPolicy: The first get only is visible to the ExpiryPolicy. There is no\n * remove event in ExpiryPolicy.\n *\n * @param <K> the type of keys maintained by this cache\n * @param <V> the type of cached values\n * @param <T> the type of the return value\n * @author Greg Luck\n * @since 1.0\n */\npublic interface EntryProcessor<K, V, T> {\n\n  /**\n   * Process an entry.\n   *\n   * @param entry     the entry\n   * @param arguments a number of arguments to the process.\n   * @return the user-defined result of the processing, if any.\n   * @throws EntryProcessorException if there is a failure in entry processing.\n   */\n  T process(MutableEntry<K, V> entry, Object... arguments)\n      throws EntryProcessorException;\n}\n```\n\n为了对指定条目使用 `EntryProcessor`，应用必须使用 `Cache.invoke` 或 `Cache.invokeAll` 方法。\n\n```java\n/**\n * Invokes an {@link EntryProcessor} against the {@link Entry} specified by\n * the provided key.\n *\n * @param <T>            the type of the return value\n * @param key            the key to the entry\n * @param entryProcessor the {@link EntryProcessor} to invoke\n * @param arguments      additional arguments to pass to the\n *                       {@link EntryProcessor}\n * @return the result of the processing, if any, defined by the\n *         {@link EntryProcessor} implementation\n * @throws NullPointerException    if key or {@link EntryProcessor} is null\n * @throws IllegalStateException   if the cache is {@link #isClosed()}\n * @throws ClassCastException    if the implementation is configured to perform\n *                               runtime-type-checking, and the key or value\n *                               types are incompatible with those that have been\n *                               configured for the {@link Cache}\n * @throws EntryProcessorException if an exception is thrown by the {@link\n *                                 EntryProcessor}, a Caching Implementation\n *                                 must wrap any {@link Exception} thrown\n *                                 wrapped in an {@link EntryProcessorException}.\n * @see EntryProcessor\n */\n<T> T invoke(K key,\n             EntryProcessor<K, V, T> entryProcessor,\n             Object... arguments) throws EntryProcessorException;\n```\n\n```java\n/**\n * Invokes an {@link EntryProcessor} against the set of {@link Entry}s\n * specified by the set of keys.\n * <p>\n * The order that the entries for the keys are processed is undefined.\n * Implementations may choose to process the entries in any order, including\n * concurrently.  Furthermore there is no guarantee implementations will\n * use the same {@link EntryProcessor} instance to process each entry, as\n * the case may be in a non-local cache topology.\n * <p>\n * The result of executing the {@link EntryProcessor} is returned as a\n * {@link Map} of {@link EntryProcessorResult}s, one result per key.  Should the\n * {@link EntryProcessor} or Caching implementation throw an exception, the\n * exception is wrapped and re-thrown when a call to\n * {@link javax.cache.processor.EntryProcessorResult#get()} is made.\n *\n * @param <T>            the type of the return value\n * @param keys           the set of keys for entries to process\n * @param entryProcessor the {@link EntryProcessor} to invoke\n * @param arguments      additional arguments to pass to the\n *                       {@link EntryProcessor}\n * @return the map of {@link EntryProcessorResult}s of the processing per key,\n * if any, defined by the {@link EntryProcessor} implementation.  No mappings\n * will be returned for {@link EntryProcessor}s that return a\n * <code>null</code> value for a key.\n * @throws NullPointerException    if keys or {@link EntryProcessor} are null\n * @throws IllegalStateException   if the cache is {@link #isClosed()}\n * @throws ClassCastException    if the implementation is configured to perform\n *                               runtime-type-checking, and the key or value\n *                               types are incompatible with those that have been\n *                               configured for the {@link Cache}\n * @see EntryProcessor\n */\n<T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys,\n                                              EntryProcessor<K, V, T> entryProcessor,\n                                              Object... arguments);\n```\n\n下面是一个例子\n\n```java\nCachingProvider provider = Caching.getCachingProvider();\nCacheManager manager = provider.getCacheManager();\n\nMutableConfiguration<String, Integer> configuration =\n  new MutableConfiguration<String, Integer>()\n    .setTypes(String.class, Integer.class);\n\nCache<String, Integer> cache = manager.createCache(\"example\", configuration);\n\nString key = \"counter\";\ncache.put(key, 1);\n\nint previous = cache.invoke(key, new IncrementProcessor<String>());\n\nassert previous == 1;\nassert cache.get(key) == 2;\n```\n\n```java\n/**\n * An {@link EntryProcessor} that increments an {@link Integer}.\n *\n * @param <K> the type of keys\n */\npublic static class IncrementProcessor<K> implements EntryProcessor<K,\n    Integer, Integer>, Serializable {\n\n  /**\n   * The serialVersionUID required for {@link java.io.Serializable}.\n   */\n  public static final long serialVersionUID = 201306211238L;\n\n  /**\n   * {@inheritDoc}\n   */\n  @Override\n  public Integer process(MutableEntry<K, Integer> entry, Object... arguments) {\n    if (entry.exists()) {\n      Integer current = entry.getValue();\n      entry.setValue(current + 1);\n      return current;\n    } else {\n      entry.setValue(0);\n      return -1;\n    }\n  }\n}\n```\n\n支持远程或分布式缓存拓扑的实现可以选择在远程进程中执行 `EntryProcessor`。 在这种情况下，实现可能需要 `EntryProcessor`，调用参数和返回类型来实现 `java.lang.Serializable` 或以某种方式可序列化。 或者，实现可以选择简单地将 `EntryProcessor` 类名与指定的调用参数一起序列化，并通过实例化 `EntryProcessor` 类和使用反序列化的调用参数进行来远程执行请求。\n\n由于 `EntryProcessor` 的结果是原子的，因此与 `CacheLoader`，`CacheWriter`，`CacheEntryListener` 和 `ExpiryPolicy` 的交互也是如此。\n\n在调用 `EntryProcessor` 时，应用程序永远不会观察到对 `MutableEntry` `getValue`，`setValue`，`remove` 等的单独调用的中间事件或副作用。 相反，应用程序将仅观察由 `EntryProcessor` 对 `Cache.Entry` 执行的操作的“净”结果。\n\n例如，一个 `EntryProcessor` 有如下操作：\n\n```java\nV v1 = entry.getValue();\nentry.setValue(v2);\nentry.remove();\nentry.setValue(v3);\nv4 = entry.getValue();\n```\n\n仅会产生一个从 `v1 -> V3` 的更新事件。\n\n### `EntryProcessor` 中的异常\n\n如果通过缓存实现或 `EntryProcessor` 本身在调用 `EntryProcessor` 期间引发异常，则必须将异常包装为 `javax.cache.processor.EntryProcessorException` 返回给调用应用程序。\n\n当在使用 `Cache.invoke` 方法调用 `EntryProcessor` 的过程中发生异常时，该异常将包装为 `EntryProcessorException` 并重新抛出给调用应用程序。\n\n当使用 `Cache.invokeAll` 方法调用 `EntryProcessor` 时发生异常时，该异常将被包装并作为 `EntryProcessorResult` 的一部分返回给调用应用程序。\n\n### `Cache.invokeAll` 中的 `EntryProcessorResults`\n\n当使用 `Cache.invokeAll` 方法针对一组键调用 `EntryProcessor` 时，结果为 `EntryProcessorResult`的 `Map`，每个键一个（除非对键的 `EntryProcessor` 调用结果为 `null`）。\n\n若要检索 `EntryProcessor` 为特定键返回的值，应用程序应为该键的 `EntryProcessorResult` 调用 `EntryProcessorResult.get` 方法。 如果 `EntryProcessor` 在处理 key 时产生了的异常，则调用 `EntryProcessorResult.get` 将引发相应的封装异常。\n\n## `CachingProvider`\n\n`CachingProvider` 是 Java Caching API 里的核心概念。开发者可以通过 `CachingProvider` 来获取 `CacheManager` 以便可以与 `Cache` 进行交互。\n\n`CachingProvider` 提供了以下特性：\n\n- 获取默认的 `CacheManager` 实例\n- 创建 `CacheManager` 实例，由特定的URI唯一标识。例如 一个实现可能会请求在类路径上声明式的配置了配置文件的 `CacheManager`,\n  - `cachingProvider.getCacheManager（“/sample/ConfigurationFile.xml”）;`\n- 通过 `URI` 和 `ClassLoader` 范围和管理 `CacheManager` 实例\n- 关闭并释放特定的或相关的 `CacheManager` 集合\n- 查询 `CachingProvider` 实现的功能，包括对可选功能的支持。\n\n### `CacheManager` 唯一标识和配置\n\n- `CacheManager` 在 `CachingProvider` 范围内，由 URI 唯一标识。\n\n由 `CachingProvider` 提供的使用默认URI和默认 `ClassLoader` 创建的 `CacheManager` 称为“默认缓存管理器”。 它是通过 `CacheManager getCacheManager();` 获得的。\n\n尽管应用程序通常使用由 `CachingProvider` 定义的默认URI作为获取 `CacheManager` 的方式，但应用程序可能会另外使用特定于实现的URI来进行 `CacheManager` 的高级配置。\n\n例如，一种实现可以允许将URI用作配置文件的位置，例如用于预配置的缓存。\n\n`cachingProvider.getCacheManager（“/sample/ConfigurationFile.xml”;`\n\n在应用程序部署中使用相同的URI和相同的 `ClassLoader` 定义的两个或多个 `CacheManager` 在逻辑上是等效的，并且必须管理相同的Cache。\n\n用于获取 `CacheManager` 的URI定义的缓存的语义与实现有关。\n\n例如：两个或更多使用相同URI且具有支持分布式缓存的实现的应用程序可以在逻辑上共享同名缓存的缓存内容。 在这种情况下，对一个应用程序中的缓存条目的更改将对另一应用程序可见。\n\n或者，即使使用相同的缓存名称，使用相同URI且仅支持本地缓存的实现的两个或多个应用程序也可能无法共享缓存内容。 在这种情况下，对一个应用程序中的缓存条目的更改可能对另一应用程序不可见。\n\n下表概述了CacheManager URI如何使用仅支持本地（非共享）缓存和分布式（或共享）缓存的实现方式影响同名缓存中的缓存条目的可见性。\n\n|`CacheManager` URI|本地缓存|分布式缓存|\n|相同|相同的配置，但是条目不同|相同配置，相同实体|\n|不同|不同配置，不同实体|不同配置，不同实体|\n\n`CachingProvider` 接口定义如下：\n\n```java\npackage javax.cache.spi;\n\nimport javax.cache.CacheException;\nimport javax.cache.CacheManager;\nimport javax.cache.configuration.OptionalFeature;\nimport java.io.Closeable;\nimport java.net.URI;\nimport java.util.Properties;\n\n/**\n * Provides mechanisms to create, request and later manage the life-cycle of\n * configured {@link CacheManager}s, identified by {@link URI}s and scoped by\n * {@link ClassLoader}s.\n * <p>\n * The meaning and semantics of the {@link URI} used to identify a\n * {@link CacheManager} is implementation dependent.  For applications to remain\n * implementation independent, they should avoid attempting to create {@link URI}s\n * and instead use those returned by {@link #getDefaultURI()}.\n *\n * @author Brian Oliver\n * @author Greg Luck\n * @since 1.0\n */\npublic interface CachingProvider extends Closeable {\n\n  /**\n   * Requests a {@link CacheManager} configured according to the implementation\n   * specific {@link URI} be made available that uses the provided\n   * {@link ClassLoader} for loading underlying classes.\n   * <p>\n   * Multiple calls to this method with the same {@link URI} and\n   * {@link ClassLoader} must return the same {@link CacheManager} instance,\n   * except if a previously returned {@link CacheManager} has been closed.\n   * <p>\n   * Properties are used in construction of a {@link CacheManager} and do not form\n   * part of the identity of the CacheManager. i.e. if a second call is made to\n   * with the same {@link URI} and {@link ClassLoader} but different properties,\n   * the {@link CacheManager} created in the first call is returned.\n   * <p>\n   * Properties names follow the same scheme as package names.\n   * The prefixes {@code java} and {@code javax} are reserved.\n   * Properties are passed through and can be retrieved via\n   * {@link CacheManager#getProperties()}.\n   * Properties within the package scope of a caching implementation may be used for\n   * additional configuration.\n   *\n   * @param uri         an implementation specific URI for the\n   *                    {@link CacheManager} (null means use\n   *                    {@link #getDefaultURI()})\n   * @param classLoader the {@link ClassLoader}  to use for the\n   *                    {@link CacheManager} (null means use\n   *                    {@link #getDefaultClassLoader()})\n   * @param properties  the {@link Properties} for the {@link CachingProvider}\n   *                    to create the {@link CacheManager} (null means no\n   *                    implementation specific Properties are required)\n   * @throws CacheException    when a {@link CacheManager} for the\n   *                           specified arguments could not be produced\n   * @throws SecurityException when the operation could not be performed\n   *                           due to the current security settings\n   */\n  CacheManager getCacheManager(URI uri, ClassLoader classLoader,\n                               Properties properties);\n\n  /**\n   * Obtains the default {@link ClassLoader} that will be used by the\n   * {@link CachingProvider}.\n   *\n   * @return the default {@link ClassLoader} used by the {@link CachingProvider}\n   */\n  ClassLoader getDefaultClassLoader();\n\n  /**\n   * Obtains the default {@link URI} for the {@link CachingProvider}.\n   * <p>\n   * Use this method to obtain a suitable {@link URI} for the\n   * {@link CachingProvider}.\n   *\n   * @return the default {@link URI} for the {@link CachingProvider}\n   */\n  URI getDefaultURI();\n\n  /**\n   * Obtains the default {@link Properties} for the {@link CachingProvider}.\n   * <p>\n   * Use this method to obtain suitable {@link Properties} for the\n   * {@link CachingProvider}.\n   *\n   * @return the default {@link Properties} for the {@link CachingProvider}\n   */\n  Properties getDefaultProperties();\n\n  /**\n   * Requests a {@link CacheManager} configured according to the implementation\n   * specific {@link URI} that uses the provided {@link ClassLoader} for loading\n   * underlying classes.\n   * <p>\n   * Multiple calls to this method with the same {@link URI} and\n   * {@link ClassLoader} must return the same {@link CacheManager} instance,\n   * except if a previously returned {@link CacheManager} has been closed.\n   *\n   * @param uri         an implementation specific {@link URI} for the\n   *                    {@link CacheManager} (null means\n   *                    use {@link #getDefaultURI()})\n   * @param classLoader the {@link ClassLoader}  to use for the\n   *                    {@link CacheManager} (null means\n   *                    use {@link #getDefaultClassLoader()})\n   * @throws CacheException    when a {@link CacheManager} for the\n   *                           specified arguments could not be produced\n   * @throws SecurityException when the operation could not be performed\n   *                           due to the current security settings\n   */\n  CacheManager getCacheManager(URI uri, ClassLoader classLoader);\n\n  /**\n   * Requests a {@link CacheManager} configured according to the\n   * {@link #getDefaultURI()} and {@link #getDefaultProperties()} be made\n   * available that using the {@link #getDefaultClassLoader()} for loading\n   * underlying classes.\n   * <p>\n   * Multiple calls to this method must return the same {@link CacheManager}\n   * instance, except if a previously returned {@link CacheManager} has been\n   * closed.\n   *\n   * @throws SecurityException when the operation could not be performed\n   *                           due to the current security settings\n   */\n  CacheManager getCacheManager();\n\n  /**\n   * Closes all of the {@link CacheManager} instances and associated resources\n   * created and maintained by the {@link CachingProvider} across all\n   * {@link ClassLoader}s.\n   * <p>\n   * After closing the {@link CachingProvider} will still be operational.  It\n   * may still be used for acquiring {@link CacheManager} instances, though\n   * those will now be new.\n   *\n   * @throws SecurityException when the operation could not be performed\n   *                           due to the current security settings\n   */\n  void close();\n\n  /**\n   * Closes all {@link CacheManager} instances and associated resources created\n   * by the {@link CachingProvider} using the specified {@link ClassLoader}.\n   * <p>\n   * After closing the {@link CachingProvider} will still be operational.  It\n   * may still be used for acquiring {@link CacheManager} instances, though\n   * those will now be new for the specified {@link ClassLoader} .\n   *\n   * @param classLoader the {@link ClassLoader}  to release\n   * @throws SecurityException when the operation could not be performed\n   *                           due to the current security settings\n   */\n  void close(ClassLoader classLoader);\n\n  /**\n   * Closes all {@link CacheManager} instances and associated resources created\n   * by the {@link CachingProvider} for the specified {@link URI} and\n   * {@link ClassLoader}.\n   *\n   * @param uri         the {@link URI} to release\n   * @param classLoader the {@link ClassLoader}  to release\n   * @throws SecurityException when the operation could not be performed\n   *                           due to the current security settings\n   */\n  void close(URI uri, ClassLoader classLoader);\n\n  /**\n   * Determines whether an optional feature is supported by the\n   * {@link CachingProvider}.\n   *\n   * @param optionalFeature the feature to check for\n   * @return true if the feature is supported\n   */\n  boolean isSupported(OptionalFeature optionalFeature);\n}\n```\n\n尽管是可选的，在 Java SE 环境中获取 `CachingProvider` 的主要途径是 `Caching` 类。\n\n`Caching` 类提供了三种方式来加载和实例化 `CachingProvider`。\n\n- 假设将实现定义为服务，并通过使用 `java.util.ServiceLoader` 对其进行解析\n- 许开发人员使用 `javax.cache.CachingProvider` 对应的Java系统属性来指定默认实现的全类名。\n- 允许应用程序使用所需的 `CachingProvider` 的全类名来显式请求特定的实现\n\n尽管开发人员可以选择使用依赖于实现的方式来获取 `CachingProvider`，但这样做可能会降低可移植性。\n\n为了使 `CachingProvider` 实现由 `Caching` 类通过 `java.util.ServiceLoader` 自动定位，必须以 Jar 文件规范中定义的格式，在 `META-INF/services/javax.cache.spi.CachingProvider` 中定义`CachingProvider` 实现的全类名。\n\n`javax.cache.spi.CachingProvider` 配置文件用于为 `Caching` 类定义特定的 `CachingProvider` 实现类，从而允许它根据请求自动定位，加载并提供适当的实例给应用程序。\n\n`javax.cache.spi.CachingProvider` 配置文件的内容只是一个或多个全类名，每个类名都位于单独的行中，每个类名都是可用的`CachingProvider` 实现。\n\n例如：\nJava Caching API 实现程序 ACME Caching Products 附带了一个名为 acme.jar 的 JAR，其中包含 `CachingProvider` 实现。 JAR的内容包括 `CachingProvider` 实现和 `javax.cache.spi.CachingProvider` 配置文件。\n\n```\nMETA-INF/services/javax.cache.spi.CachingProvider\ncom/acme/cache/ACMECachingProvider.class\n...\n```\n\n`META-INF/services/javax.cache.spi.CachingProvider` 的内容只不过是实现类的名称：`com.acme.cache.ACMECachingProvider`\n\n通过正确配置 `META-INF/services/javax.cache.spi.CachingProvider` 文件，应用程序可以使用多个 `CachingProvider` 实现。 当有多个 `CachingProvider` 可用时，从 `Caching` 类返回默认 `CachingProvider` 的请求将导致异常。\n\n`Caching` 类定义如下：\n\n```java\npackage javax.cache;\n\nimport javax.cache.spi.CachingProvider;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.util.Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.ServiceLoader;\nimport java.util.WeakHashMap;\n\n/**\n * The {@link Caching} class provides a convenient means for an application to\n * acquire an appropriate {@link CachingProvider} implementation.\n * <p>\n * While defined as part of the specification, its use is not required.\n * Applications and/or containers may instead choose to directly instantiate a\n * {@link CachingProvider} implementation based on implementation specific\n * instructions.\n * <p>\n * When using the {@link Caching} class, {@link CachingProvider} implementations\n * are automatically discovered when they follow the conventions outlined by the\n * Java Development Kit {@link ServiceLoader} class.\n * <p>\n * Although automatically discovered, applications that choose to use this class\n * should not make assumptions regarding the order in which implementations are\n * returned by the {@link #getCachingProviders()} or\n * {@link #getCachingProviders(ClassLoader)} methods.\n * <p>\n * For a {@link CachingProvider} to be automatically discoverable by the\n * {@link Caching} class, the fully qualified class name of the\n * {@link CachingProvider} implementation must be declared in the following\n * file:\n * <pre>\n *   META-INF/services/javax.cache.spi.CachingProvider\n * </pre>\n * This file must be resolvable via the class path.\n * <p>\n * For example, in the reference implementation the contents of this file are:\n * <code>org.jsr107.ri.RICachingProvider</code>\n * <p>\n * Alternatively when the fully qualified class name of a\n * {@link CachingProvider} implementation is specified using the system property\n * <code>javax.cache.spi.cachingprovider</code>, that implementation will be used\n * as the default {@link CachingProvider}.\n * <p>\n * All {@link CachingProvider}s that are automatically detected or explicitly\n * declared and loaded by the {@link Caching} class are maintained in an\n * internal registry.  Consequently when a previously loaded\n * {@link CachingProvider} is requested, it will be simply returned from the\n * internal registry, without reloading and/or instantiating the said\n * implementation again.\n * <p>\n * As required by some applications and containers, multiple co-existing\n * {@link CachingProvider}s implementations, from the same or different\n * implementors are permitted at runtime.\n * <p>\n * To iterate through those that are currently registered a developer may use\n * the following methods:\n * <ol>\n * <li>{@link #getCachingProviders()}</li>\n * <li>{@link #getCachingProviders(ClassLoader)}</li>\n * </ol>\n * To request a specific {@link CachingProvider} implementation, a developer\n * should use either the {@link #getCachingProvider(String)} or\n * {@link #getCachingProvider(String, ClassLoader)} method.\n * <p>\n * Where multiple {@link CachingProvider}s are present, the\n * {@link CachingProvider} returned by getters {@link #getCachingProvider()} and\n * {@link #getCachingProvider(ClassLoader)} is undefined and as a result a\n * {@link CacheException} will be thrown when attempted.\n *\n * @author Brian Oliver\n * @author Greg Luck\n * @author Yannis Cosmadopoulos\n * @since 1.0\n * @see ServiceLoader\n * @see CachingProvider\n */\npublic final class Caching {\n\n  /**\n   * The <code>javax.cache.spi.cachingprovider</code> constant.\n   */\n  public static final String JAVAX_CACHE_CACHING_PROVIDER = \"javax.cache\" +\n      \".spi.CachingProvider\";\n\n  /**\n   * The {@link CachingProviderRegistry} that tracks the {@link CachingProvider}s.\n   */\n  private static final CachingProviderRegistry CACHING_PROVIDERS =\n      new CachingProviderRegistry();\n\n  /**\n   * No public constructor as all methods are static.\n   */\n  private Caching() {\n  }\n\n  /**\n   * Obtains the {@link ClassLoader} to use for API methods that don\'t\n   * explicitly require a {@link ClassLoader} but internally require one.\n   * <p>\n   * By default this is the {@link Thread#getContextClassLoader()}.\n   *\n   * @return the default {@link ClassLoader}\n   */\n  public static ClassLoader getDefaultClassLoader() {\n    return CACHING_PROVIDERS.getDefaultClassLoader();\n  }\n\n  /**\n   * Set the {@link ClassLoader} to use for API methods that don\'t explicitly\n   * require a {@link ClassLoader}, but internally use one.\n   *\n   * @param classLoader the {@link ClassLoader} or <code>null</code> if the\n   *                    calling {@link Thread#getContextClassLoader()} should\n   *                    be used\n   */\n  public static void setDefaultClassLoader(ClassLoader classLoader) {\n    CACHING_PROVIDERS.setDefaultClassLoader(classLoader);\n  }\n\n  /**\n   * Obtains the default {@link CachingProvider} available via the\n   * {@link #getDefaultClassLoader()}.\n   *\n   * @return the {@link CachingProvider}\n   * @throws CacheException    should zero, or more than one\n   *                           {@link CachingProvider} be available on the\n   *                           classpath, or it could not be loaded\n   * @throws SecurityException when the operation could not be performed\n   *                           due to the current security settings\n   */\n  public static CachingProvider getCachingProvider() {\n    return CACHING_PROVIDERS.getCachingProvider();\n  }\n\n  /**\n   * Obtains the single {@link CachingProvider} visible to the specified\n   * {@link ClassLoader}.\n   *\n   * @param classLoader the {@link ClassLoader} to use for loading the\n   *                    {@link CachingProvider}\n   * @return the {@link CachingProvider}\n   * @throws CacheException    should zero, or more than one\n   *                           {@link CachingProvider} be available on the\n   *                           classpath, or it could not be loaded\n   * @throws SecurityException when the operation could not be performed\n   *                           due to the current security settings\n   * @see #getCachingProviders(ClassLoader)\n   */\n  public static CachingProvider getCachingProvider(ClassLoader classLoader) {\n    return CACHING_PROVIDERS.getCachingProvider(classLoader);\n  }\n\n  /**\n   * Obtains the {@link CachingProvider}s that are available via the\n   * {@link #getDefaultClassLoader()}.\n   * <p>\n   * If a <code>javax.cache.spi.cachingprovider</code> system property is defined,\n   * only that {@link CachingProvider} specified by that property is returned.\n   * Otherwise all {@link CachingProvider}s that are available via a\n   * {@link ServiceLoader} for {@link CachingProvider}s using the default\n   * {@link ClassLoader} (including those previously requested via\n   * {@link #getCachingProvider(String)}) are returned.\n   *\n   * @return an {@link Iterable} of {@link CachingProvider}s loaded by the\n   *         specified {@link ClassLoader}\n   */\n  public static Iterable<CachingProvider> getCachingProviders() {\n    return CACHING_PROVIDERS.getCachingProviders();\n  }\n\n  /**\n   * Obtains the {@link CachingProvider}s that are available via the specified\n   * {@link ClassLoader}.\n   * <p>\n   * If a <code>javax.cache.spi.cachingprovider</code> system property is defined,\n   * only that {@link CachingProvider} specified by that property is returned.\n   * Otherwise all {@link CachingProvider}s that are available via a\n   * {@link ServiceLoader} for {@link CachingProvider}s using the specified\n   * {@link ClassLoader} (including those previously requested via\n   * {@link #getCachingProvider(String, ClassLoader)}) are returned.\n   *\n   * @param classLoader the {@link ClassLoader} of the returned\n   *                    {@link CachingProvider}s\n   * @return an {@link Iterable} of {@link CachingProvider}s loaded by the\n   *         specified {@link ClassLoader}\n   */\n  public static Iterable<CachingProvider> getCachingProviders(\n      ClassLoader classLoader) {\n    return CACHING_PROVIDERS.getCachingProviders(classLoader);\n  }\n\n  /**\n   * Obtain the {@link CachingProvider} that is implemented by the specified\n   * fully qualified class name using the {@link #getDefaultClassLoader()}.\n   * Should this {@link CachingProvider} already be loaded it is simply returned,\n   * otherwise an attempt will be made to load and instantiate the specified\n   * class (using a no-args constructor).\n   *\n   * @param fullyQualifiedClassName the fully qualified class name of the\n   *                                {@link CachingProvider}\n   * @return the {@link CachingProvider}\n   * @throws CacheException    if the {@link CachingProvider} cannot be created\n   * @throws SecurityException when the operation could not be performed\n   *                           due to the current security settings\n   */\n  public static CachingProvider getCachingProvider(String fullyQualifiedClassName) {\n    return CACHING_PROVIDERS.getCachingProvider(fullyQualifiedClassName);\n  }\n\n  /**\n   * Obtain the {@link CachingProvider} that is implemented by the specified\n   * fully qualified class name using the provided {@link ClassLoader}.\n   * Should this {@link CachingProvider} already be loaded it is returned,\n   * otherwise an attempt will be made to load and instantiate the specified\n   * class (using a no-args constructor).\n   *\n   * @param fullyQualifiedClassName the fully qualified class name of the\n   *                                {@link CachingProvider}\n   * @param classLoader             the {@link ClassLoader} to load the\n   *                                {@link CachingProvider}\n   * @return the {@link CachingProvider}\n   * @throws CacheException    if the {@link CachingProvider} cannot be created\n   * @throws SecurityException when the operation could not be performed\n   *                           due to the current security settings\n   */\n  public static CachingProvider getCachingProvider(String fullyQualifiedClassName,\n                                                   ClassLoader classLoader) {\n    return CACHING_PROVIDERS.getCachingProvider(fullyQualifiedClassName,\n        classLoader);\n  }\n\n\n  /**\n   * A convenience that method that looks up a managed {@link Cache} given its\n   * name. using the default <code>CachingProvider</code> and <code>CacheManager\n   * </code>. For the full range of <code>Cache</code> look up methods see\n   * {@link CacheManager}.\n   * <p>\n   * This method must be used for {@link Cache}s that were configured with\n   * runtime key and value types. Use {@link CacheManager#getCache(String)} for\n   * {@link Cache}s where these were not specified.\n   * <p>\n   * Implementations must ensure that the key and value types are the same as\n   * those configured for the {@link Cache} prior to returning from this method.\n   * <p>\n   * Implementations may further perform type checking on mutative cache operations\n   * and throw a {@link ClassCastException} if these checks fail.\n   * <p>\n   * Implementations that support declarative mechanisms for pre-configuring\n   * {@link Cache}s may return a pre-configured {@link Cache} instead of\n   * <code>null</code>.\n   * @param <K> the type of key\n   * @param <V> the type of value\n   * @param cacheName the name of the managed {@link Cache} to acquire\n   * @param keyType   the expected {@link Class} of the key\n   * @param valueType the expected {@link Class} of the value\n   * @return the Cache or null if it does exist or can\'t be pre-configured\n   * @throws IllegalStateException    if the CacheManager is\n   *                                  {@link CacheManager#isClosed()}\n   * @throws IllegalArgumentException if the specified key and/or value types are\n   *                                  incompatible with the configured cache.\n   * @throws SecurityException        when the operation could not be performed\n   *                                  due to the current security settings\n   * @see CacheManager#getCache(String, Class, Class)\n   * @see CacheManager#getCache(String)\n   */\n  public static <K, V> Cache<K, V> getCache(String cacheName, Class<K> keyType,\n                              Class<V> valueType) {\n\n    return getCachingProvider().getCacheManager().getCache(cacheName, keyType,\n        valueType);\n  }\n\n  /**\n   * Maintains a registry of loaded {@link CachingProvider}s scoped by\n   * {@link ClassLoader}.\n   */\n  private static class CachingProviderRegistry {\n\n    /**\n     * The {@link CachingProvider}s by Class Name organized by the\n     * {@link ClassLoader} was used to load them.\n     */\n    private WeakHashMap<ClassLoader, LinkedHashMap<String, CachingProvider>>\n        cachingProviders;\n\n    /**\n     * The default {@link ClassLoader}.  When <code>null</code> the\n     * {@link Thread#getContextClassLoader()} will be used.\n     */\n    private volatile ClassLoader classLoader;\n\n    /**\n     * Constructs a CachingProviderManager.\n     */\n    public CachingProviderRegistry() {\n      this.cachingProviders = new WeakHashMap<ClassLoader, LinkedHashMap<String,\n          CachingProvider>>();\n      this.classLoader = null;\n    }\n\n    /**\n     * Obtains the {@link ClassLoader} to use for API methods that don\'t\n     * explicitly require a {@link ClassLoader} but internally require one.\n     * <p>\n     * By default this is the {@link Thread#getContextClassLoader()}.\n     * </p>\n     * @return the default {@link ClassLoader}\n     */\n    public ClassLoader getDefaultClassLoader() {\n      ClassLoader loader = classLoader;\n      return loader == null ? Thread.currentThread().getContextClassLoader() : loader;\n    }\n\n    /**\n     * Set the {@link ClassLoader} to use for API methods that don\'t explicitly\n     * require a {@link ClassLoader}, but internally use one.\n     *\n     * @param classLoader the {@link ClassLoader} or <code>null</code> if the\n     *                    calling {@link Thread#getContextClassLoader()} should\n     *                    be used\n     */\n    public void setDefaultClassLoader(ClassLoader classLoader) {\n      this.classLoader = classLoader;\n    }\n\n    /**\n     * Obtains the only {@link CachingProvider} defined by the\n     * {@link #getDefaultClassLoader()}.\n     * <p>\n     * Should zero or more than one {@link CachingProvider}s be available, a\n     * CacheException is thrown.\n     * </p>\n     * @return the {@link CachingProvider}\n     * @throws CacheException should zero or more than one\n     *                        {@link CachingProvider} be available\n     *                        or a {@link CachingProvider} could not be loaded\n     * @see #getCachingProvider(ClassLoader)\n     * @see #getCachingProviders(ClassLoader)\n     */\n    public CachingProvider getCachingProvider() {\n      return getCachingProvider(getDefaultClassLoader());\n    }\n\n    /**\n     * Obtains the only {@link CachingProvider} defined by the specified\n     * {@link ClassLoader}.\n     * <p>\n     * Should zero or more than one {@link CachingProvider}s be available, a\n     * CacheException is thrown.\n     * </p>\n     * @param classLoader the {@link ClassLoader} to use for loading the\n     *                    {@link CachingProvider}\n     * @return the {@link CachingProvider}\n     * @throws CacheException should zero or more than one\n     *                        {@link CachingProvider} be available\n     *                        or a {@link CachingProvider} could not be loaded\n     * @see #getCachingProviders(ClassLoader)\n     */\n    public CachingProvider getCachingProvider(ClassLoader classLoader) {\n      Iterator<CachingProvider> iterator = getCachingProviders(classLoader).iterator();\n\n      if (iterator.hasNext()) {\n        CachingProvider provider = iterator.next();\n\n        if (iterator.hasNext()) {\n          throw new CacheException(\"Multiple CachingProviders have been configured when only a single CachingProvider is expected\");\n        } else {\n          return provider;\n        }\n      } else {\n        throw new CacheException(\"No CachingProviders have been configured\");\n      }\n    }\n\n    /**\n     * Obtain the {@link CachingProvider}s that are available via the\n     * {@link #getDefaultClassLoader()}.\n     * <p>\n     * If a <code>javax.cache.spi.cachingprovider</code> system property is defined,\n     * only that {@link CachingProvider} specified by that property is returned.\n     * Otherwise all {@link CachingProvider}s that are available via a\n     * {@link ServiceLoader} for {@link CachingProvider}s using the default\n     * {@link ClassLoader} (and those explicitly requested via\n     * {@link #getCachingProvider(String)}) are returned.\n     * </p>\n     * @return an {@link Iterable} of {@link CachingProvider}s loaded by the\n     *         default {@link ClassLoader}\n     */\n    public Iterable<CachingProvider> getCachingProviders() {\n      return getCachingProviders(getDefaultClassLoader());\n    }\n\n    /**\n     * Obtain the {@link CachingProvider}s that are available via the specified\n     * {@link ClassLoader}.\n     * <p>\n     * If a <code>javax.cache.spi.cachingprovider</code> system property is defined,\n     * only that {@link CachingProvider} specified by that property is returned.\n     * Otherwise all {@link CachingProvider}s that are available via a\n     * {@link ServiceLoader} for {@link CachingProvider}s using the specified\n     * {@link ClassLoader} (and those explicitly requested via\n     * {@link #getCachingProvider(String, ClassLoader)}) are returned.\n     * </p>\n     * @param classLoader the {@link ClassLoader} of the returned\n     *                    {@link CachingProvider}s\n     * @return an {@link Iterable} of {@link CachingProvider}s loaded by the\n     *         specified {@link ClassLoader}\n     */\n    public synchronized Iterable<CachingProvider> getCachingProviders(ClassLoader classLoader) {\n\n      final ClassLoader serviceClassLoader = classLoader == null ? getDefaultClassLoader() : classLoader;\n      LinkedHashMap<String, CachingProvider> providers = cachingProviders.get(serviceClassLoader);\n\n      if (providers == null) {\n\n        String className = System.getProperty(JAVAX_CACHE_CACHING_PROVIDER);\n        if (className != null) {\n          providers = new LinkedHashMap<String, CachingProvider>();\n          providers.put(className, loadCachingProvider(className, serviceClassLoader));\n\n        } else {\n          providers = AccessController.doPrivileged(new PrivilegedAction<LinkedHashMap<String, CachingProvider>>() {\n            @Override\n            public LinkedHashMap<String, CachingProvider> run() {\n              LinkedHashMap<String, CachingProvider> result = new LinkedHashMap<String, CachingProvider>();\n\n              ServiceLoader<CachingProvider> serviceLoader = ServiceLoader.load(CachingProvider.class, serviceClassLoader);\n              for (CachingProvider provider : serviceLoader) {\n                result.put(provider.getClass().getName(), provider);\n              }\n              return result;\n            }\n          });\n\n        }\n\n        cachingProviders.put(serviceClassLoader, providers);\n      }\n\n      return providers.values();\n    }\n\n    /**\n     * Obtain the {@link CachingProvider} that is implemented by the specified\n     * fully qualified class name using the {@link #getDefaultClassLoader()}.\n     * Should this {@link CachingProvider} already be loaded it is simply\n     * returned, otherwise an attempt will be made to load and instantiate the\n     * specified class name (using a no-args constructor).\n     *\n     * @param fullyQualifiedClassName the fully qualified class name of the\n     *                                {@link CachingProvider}\n     * @return the {@link CachingProvider}\n     * @throws CacheException when the {@link CachingProvider} can\'t be created\n     */\n    public CachingProvider getCachingProvider(String fullyQualifiedClassName) {\n      return getCachingProvider(fullyQualifiedClassName, getDefaultClassLoader());\n    }\n\n    /**\n     * Load and instantiate the {@link CachingProvider} with the specified\n     * fully qualified class name using the provided {@link ClassLoader}\n     *\n     * @param fullyQualifiedClassName the name of the {@link CachingProvider}\n     *                                class\n     * @param classLoader             the {@link ClassLoader} to use\n     * @return a new {@link CachingProvider} instance\n     * @throws CacheException if the specified {@link CachingProvider} could not be\n     *                        loaded\n     *                        or the specified class is not a {@link\n     *                        CachingProvider}\n     */\n    protected CachingProvider loadCachingProvider(String fullyQualifiedClassName, ClassLoader classLoader) throws CacheException {\n      synchronized (classLoader) {\n        try {\n          Class<?> clazz = classLoader.loadClass(fullyQualifiedClassName);\n          if (CachingProvider.class.isAssignableFrom(clazz)) {\n            return ((Class<CachingProvider>) clazz).newInstance();\n          } else {\n            throw new CacheException(\"The specified class [\" + fullyQualifiedClassName + \"] is not a CachingProvider\");\n          }\n        } catch (Exception e) {\n          throw new CacheException(\"Failed to load the CachingProvider [\" + fullyQualifiedClassName + \"]\", e);\n        }\n      }\n    }\n\n    /**\n     * Obtain the {@link CachingProvider} that is implemented by the specified\n     * fully qualified class name using the provided {@link ClassLoader}.\n     * Should this {@link CachingProvider} already be loaded it is returned,\n     * otherwise an attempt will be made to load and instantiate the specified\n     * class (using a no-args constructor).\n     *\n     * @param fullyQualifiedClassName the fully qualified class name of the\n     *                                {@link CachingProvider}\n     * @param classLoader             the {@link ClassLoader} to load the\n     *                                {@link CachingProvider}\n     * @return the {@link CachingProvider}\n     * @throws CacheException when the {@link CachingProvider} can\'t be created\n     */\n    public synchronized CachingProvider getCachingProvider(String fullyQualifiedClassName, ClassLoader classLoader) {\n      ClassLoader serviceClassLoader = classLoader == null ? getDefaultClassLoader() : classLoader;\n\n      LinkedHashMap<String, CachingProvider> providers = cachingProviders.get(serviceClassLoader);\n\n      if (providers == null) {\n        // first load the CachingProviders for the {@link ClassLoader}\n        // this may automatically load the CachingProvider we desire\n        getCachingProviders(serviceClassLoader);\n        providers = cachingProviders.get(serviceClassLoader);\n      }\n\n      CachingProvider provider = providers.get(fullyQualifiedClassName);\n\n      if (provider == null) {\n        provider = loadCachingProvider(fullyQualifiedClassName, serviceClassLoader);\n        providers.put(fullyQualifiedClassName, provider);\n      }\n\n      return provider;\n    }\n  }\n}\n```\n\n## Caching Annotations\n\n注解为用户提供的与缓存交互的类提供了方法拦截器。相关类在 `javax.cache.annotation` 中定义了下面几种：\n\n- `@CacheDefaults`\n- `@CacheResult`\n- `@CachePut`\n- `@CacheRemove`\n- `@CacheRemoveAll`\n\n注解是缓存操作API的一次封装。 无论是通过注解还是通过使用预定义的Java API操作，都必须获得相同的结果。\n\n注释是与缓存交互的新方式。仅最常用的缓存方法有对应的注解。\n\n为了在应用程序中使用注解，需要一个库或框架来处理这些注释并拦截对带注释的应用程序对象的调用。 在一个应用程序中，处理类缓存注释的方法和配置留给实现来决定。\n\n这通常将由 CDI 定义的依赖注入框架提供。 RI 包括与 CDI，Spring 和 Guice 一起使用的示例实现。\n\n### Annotations\n\n#### `@CacheDefaults`\n\n这是一个类级别的注释，用于为类中使用的所有与缓存相关的注释定义默认属性值。 可以指定 `cacheName`，`cacheResolverFactory` 和`cacheKeyGenerator` 属性，所有属性都是可选的。\n\n如果在类上指定了 `@CacheDefaults`，但是不存在方法级的缓存注释，则将忽略 `@CacheDefaults` 注释。\n\n下面的示例将一个名为 “cities” 的缓存。 `getCity` 方法上的 `@CacheResult` 注解将在运行时使用此缓存名称。\n\n```java\n@CacheDefaults(cacheName=”cities”)\npublic class CitySource {\n    @CacheResult\n    public City getCity(int lat, int lon) {\n        //...\n    }\n}\n```\n\n注解定义如下：\n\n```java\npackage javax.cache.annotation;\n\nimport javax.cache.CacheManager;\nimport javax.enterprise.util.Nonbinding;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.Arrays;\n\n\n/**\n * Allows the configuration of defaults for {@link CacheResult}, {@link CachePut},\n * {@link CacheRemove}, and {@link CacheRemoveAll} at the class level. Without\n * the method level annotations this annotation has no effect.\n * <p>\n * Following is an example of specifying a default cache name that is used by\n * the annotations on the getDomain and deleteDomain methods. The annotation for\n * getAllDomains would use the \"allDomains\" cache name specified in the method\n * level annotation.\n * <pre><code>\n * package my.app;\n *\n * &#64;CacheDefaults(cacheName=\"domainCache\")\n * public class DomainDao {\n *   &#64;CacheResult\n *   public Domain getDomain(String domainId, int index) {\n *     ...\n *   }\n *\n *   &#64;CacheRemove\n *   public void deleteDomain(String domainId, int index) {\n *     ...\n *   }\n *\n *   &#64;CacheResult(cacheName=\"allDomains\")\n *   public List&lt;Domain&gt; getAllDomains() {\n *     ...\n *   }\n * }\n * </code></pre>\n *\n * @author Rick Hightower\n * @since 1.0\n */\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface CacheDefaults {\n\n  /**\n   * The default name of the cache for the annotated class\n   * <p>\n   * If not specified defaults to:\n   * package.name.ClassName.methodName(package.ParameterType,package.ParameterType)\n   * <p>\n   * Applicable for {@link CacheResult}, {@link CachePut}, {@link CacheRemove},\n   * and {@link CacheRemoveAll}\n   */\n  @Nonbinding String cacheName() default \"\";\n\n  /**\n   * The {@link CacheResolverFactory} used to find the {@link CacheResolver} to\n   * use at runtime.\n   * <p>\n   * The default resolver pair will resolve the cache by name from the default\n   * {@link CacheManager}\n   * <p>\n   * Applicable for {@link CacheResult}, {@link CachePut}, {@link CacheRemove},\n   * and {@link CacheRemoveAll}\n   */\n  @Nonbinding Class<? extends CacheResolverFactory> cacheResolverFactory()\n      default CacheResolverFactory.class;\n\n  /**\n   * The {@link CacheKeyGenerator} to use to generate the\n   * {@link GeneratedCacheKey} for interacting with the specified Cache.\n   * <p>\n   * Defaults to a key generator that uses {@link Arrays#deepHashCode(Object[])}\n   * and {@link Arrays#deepEquals(Object[], Object[])} with the array returned by\n   * {@link CacheKeyInvocationContext#getKeyParameters()}\n   * </p>\n   * Applicable for {@link CacheResult}, {@link CachePut}, and {@link CacheRemove}\n   *\n   * @see CacheKey\n   */\n  @Nonbinding Class<? extends CacheKeyGenerator> cacheKeyGenerator()\n      default CacheKeyGenerator.class;\n}\n```\n\n#### `@CacheResult`\n\n这是方法级别的注解，用于标记使用从方法参数生成的键来缓存其返回值的方法，并在以后的调用中使用相同参数从缓存中返回这些键。\n\n定义如下：\n\n```java\npackage javax.cache.annotation;\n\nimport javax.cache.Cache;\nimport javax.cache.CacheManager;\nimport javax.enterprise.util.Nonbinding;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n\n/**\n * When a method annotated with {@link CacheResult} is invoked a\n * {@link GeneratedCacheKey} will be generated and {@link Cache#get(Object)} is\n * called before the annotated method actually executes. If a value is found in the\n * cache it is returned and the annotated method is never actually executed. If no\n * value is found the annotated method is invoked and the returned value is stored\n * in the cache with the generated key.\n * <p>\n * Exceptions are not cached by default. Caching of exceptions can be enabled by\n * specifying an {@link #exceptionCacheName()}. If an exception cache is specified\n * it is checked before invoking the annotated method and if a cached exception is\n * found it is re-thrown.\n * <p>\n * The {@link #cachedExceptions()} and {@link #nonCachedExceptions()} properties\n * can be used to control the exceptions are cached and those that are not.\n * <p>\n * To always invoke the annotated method and still cache the result set\n * {@link #skipGet()} to true. This will disable the pre-invocation\n * {@link Cache#get(Object)} call. If {@link #exceptionCacheName()} is\n * specified the pre-invocation exception check is also disabled. This feature is\n * useful for methods that create or update objects to be cached.\n * <p>\n * Example of caching the Domain object with a key generated from the\n * <code>String</code> and <code>int</code> parameters.\n * <p>\n * With no {@link #cacheName()} specified a cache name of\n * \"my.app.DomainDao.getDomain(java.lang.String,int)\" will be generated.\n * </p>\n * <pre><code>\n * package my.app;\n *\n * public class DomainDao {\n *   &#64;CacheResult\n *   public Domain getDomain(String domainId, int index) {\n *     ...\n *   }\n * }\n * </code></pre>\n * <p>\n * Example using the {@link GeneratedCacheKey} annotation so that only the domainId\n * parameter is used in key generation:\n * <pre><code>\n * package my.app;\n *\n * public class DomainDao {\n *   &#64;CacheResult\n *   public Domain getDomain(@CacheKey String domainId, Monitor mon) {\n *     ...\n *   }\n * }\n * </code></pre>\n * <p>\n * If exception caching is enabled via specification of\n * {@link #exceptionCacheName()} the following rules are used to determine if a\n * thrown exception is cached:\n * <ol>\n * <li>If {@link #cachedExceptions()} and {@link #nonCachedExceptions()} are both\n * empty then all exceptions are cached</li>\n * <li>If {@link #cachedExceptions()} is specified and\n * {@link #nonCachedExceptions()} is not specified then only exceptions\n * that pass an instanceof check against the cachedExceptions list are cached</li>\n * <li>If {@link #nonCachedExceptions()} is specified and\n * {@link #cachedExceptions()} is not specified then all exceptions\n * that do not pass an instanceof check against the nonCachedExceptions list are\n * cached</li>\n * <li>If {@link #cachedExceptions()} and {@link #nonCachedExceptions()} are both\n * specified then exceptions that pass an instanceof check against the\n * cachedExceptions list but do not pass an instanceof check against the\n * nonCachedExceptions list are cached</li>\n * </ol>\n *\n * @author Eric Dalquist\n * @author Rick Hightower\n * @see CacheKey\n * @since 1.0\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface CacheResult {\n\n  /**\n   * <p>\n   * The name of the cache.\n   * </p>\n   * If not specified defaults first to {@link CacheDefaults#cacheName()} and if\n   * that is not set it defaults to:\n   * package.name.ClassName.methodName(package.ParameterType,package.ParameterType)\n   */\n  @Nonbinding String cacheName() default \"\";\n\n  /**\n   * If set to true the pre-invocation {@link Cache#get(Object)} is\n   * skipped and the annotated method is always executed with the returned value\n   * being cached as normal. This is useful for create or update methods that\n   * should always be executed and have their returned value placed in the cache.\n   * <p>\n   * If true and an {@link #exceptionCacheName()} is specified the pre-invocation\n   * check for a thrown exception is also skipped. If an exception is thrown during\n   * invocation it will be cached following the standard exception caching rules.\n   * <p>\n   * Defaults to false.\n   *\n   * @see CachePut\n   */\n  @Nonbinding boolean skipGet() default false;\n\n  /**\n   * The {@link CacheResolverFactory} used to find the {@link CacheResolver} to\n   * use at runtime.\n   * <p>\n   * The default resolver pair will resolve the cache by name from the default\n   * {@link CacheManager}\n   */\n  @Nonbinding Class<? extends CacheResolverFactory> cacheResolverFactory()\n      default CacheResolverFactory.class;\n\n  /**\n   * The {@link CacheKeyGenerator} to use to generate the {@link GeneratedCacheKey}\n   * for interacting with the specified Cache.\n   * <p>\n   * Defaults to a key generator that uses\n   * {@link java.util.Arrays#deepHashCode(Object[])} and\n   * {@link java.util.Arrays#deepEquals(Object[], Object[])} with the array\n   * returned by {@link CacheKeyInvocationContext#getKeyParameters()}\n   *\n   * @see CacheKey\n   */\n  @Nonbinding Class<? extends CacheKeyGenerator> cacheKeyGenerator()\n      default CacheKeyGenerator.class;\n\n  /**\n   * The name of the cache to cache exceptions.\n   * <p>\n   * If not specified no exception caching is done.\n   */\n  @Nonbinding String exceptionCacheName() default \"\";\n\n  /**\n   * Defines zero (0) or more exception {@link Class classes}, that must be a\n   * subclass of {@link Throwable}, indicating the exception types that\n   * <b>must</b> be cached. Only consulted if {@link #exceptionCacheName()} is\n   * specified.\n   */\n  @Nonbinding Class<? extends Throwable>[] cachedExceptions() default {};\n\n  /**\n   * Defines zero (0) or more exception {@link Class Classes}, that must be a\n   * subclass of {@link Throwable}, indicating the exception types that\n   * <b>must not</b> be cached. Only consulted if {@link #exceptionCacheName()}\n   * is specified.\n   */\n  @Nonbinding Class<? extends Throwable>[] nonCachedExceptions() default {};\n}\n```\n\n`@CacheKey` 注解可以用来选择参数列表的一个子集来生成缓存 key。\n\n可选的：\n\n1. 可选的使用另外的缓存来缓存和重抛异常，包括仅缓存指定异常的功能。\n2. `skipGet`, 跳过调用 `Cache.get` 获取已缓存值的过程，在被注解的方法必须要执行且缓存返回值的场景中有用。\n\n静态方法上的 `@CacheResult` 将会直接被忽略。\n\n#### `@CachePut`\n\n这是一个方法级别注释，用于标记方法，必须使用 `@CacheValue` 注释一个参数，将其标记为要缓存的参数。 如果未指定 `@CacheValue` 注解，在应用程序初始化时或方法调用时会抛出 `CacheAnnotationConfigurationException`。\n\n定义如下：\n\n```java\npackage javax.cache.annotation;\n\nimport javax.cache.Cache;\nimport javax.cache.CacheManager;\nimport javax.enterprise.util.Nonbinding;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\nimport java.util.Arrays;\n\n\n/**\n * When a method annotated with {@link CachePut} is invoked a {@link\n * GeneratedCacheKey} will be generated and {@link Cache#put(Object,\n * Object)} will be invoked on the specified cache storing the value marked with\n * {@link CacheValue}.\n * <p>\n * The default behavior is to call {@link Cache#put(Object, Object)}\n * after the annotated method is invoked, this behavior can be changed by setting\n * {@link #afterInvocation()} to false in which case\n * {@link Cache#put(Object, Object)} will be called before the annotated method is\n * invoked.\n * <p>\n * Example of caching the Domain object with a key generated from the String and\n * int parameters. The {@link CacheValue} annotation is used to designate which\n * parameter should be stored in the \"domainDao\" cache.\n * <pre><code>\n * package my.app;\n *\n * public class DomainDao {\n *   &#64;CachePut(cacheName=\"domainCache\")\n *   public void updateDomain(String domainId, int index, &#64;CacheValue Domain\n * domain) {\n *     ...\n *   }\n * }\n * </code></pre>\n * <p>\n * Exception Handling, only used if {@link #afterInvocation()} is true.\n * <ol>\n * <li>If {@link #cacheFor()} and {@link #noCacheFor()} are both empty then all\n * exceptions prevent the put</li>\n * <li>If {@link #cacheFor()} is specified and {@link #noCacheFor()} is not\n * specified then only exceptions that pass an instanceof check against the\n * cacheFor list result in a put</li>\n * <li>If {@link #noCacheFor()} is specified and {@link #cacheFor()} is not\n * specified then all exceptions that do not pass an instanceof check against the\n * noCacheFor result in a put</li>\n * <li>If {@link #cacheFor()} and {@link #noCacheFor()} are both specified then\n * exceptions that pass an instanceof check against the cacheFor list but do not\n * pass an instanceof check against the noCacheFor list result in a put</li>\n * </ol>\n *\n * @author Eric Dalquist\n * @author Rick Hightower\n * @see CacheValue\n * @see CacheKey\n * @since 1.0\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface CachePut {\n\n  /**\n   * The name of the cache.\n   * <p>\n   * If not specified defaults first to {@link CacheDefaults#cacheName()} and if\n   * that is not set it defaults to:\n   * package.name.ClassName.methodName(package.ParameterType,package.ParameterType)\n   */\n  @Nonbinding String cacheName() default \"\";\n\n  /**\n   * When {@link Cache#put(Object, Object)} should be called. If true it is called\n   * after the annotated method invocation completes successfully. If false it is\n   * called before the annotated method is invoked.\n   * <p>\n   * Defaults to true.\n   * <p>\n   * If true and the annotated method throws an exception the rules governing\n   * {@link #cacheFor()} and {@link #noCacheFor()} will be followed.\n   */\n  @Nonbinding boolean afterInvocation() default true;\n\n  /**\n   * The {@link CacheResolverFactory} used to find the {@link CacheResolver} to\n   * use at runtime.\n   * <p>\n   * The default resolver pair will resolve the cache by name from the default\n   * {@link CacheManager}\n   */\n  @Nonbinding Class<? extends CacheResolverFactory> cacheResolverFactory()\n      default CacheResolverFactory.class;\n\n  /**\n   * The {@link CacheKeyGenerator} to use to generate the {@link\n   * GeneratedCacheKey} for interacting with the specified Cache.\n   * <p>\n   * Defaults to a key generator that uses {@link Arrays#deepHashCode(Object[])}\n   * and {@link Arrays#deepEquals(Object[], Object[])} with the array\n   * returned by {@link CacheKeyInvocationContext#getKeyParameters()}\n   *\n   * @see CacheKey\n   */\n  @Nonbinding Class<? extends CacheKeyGenerator> cacheKeyGenerator()\n      default CacheKeyGenerator.class;\n\n  /**\n   * Defines zero (0) or more exception {@link Class classes}, that must be a\n   * subclass of {@link Throwable}, indicating the exception types that <b>must</b>\n   * cause the parameter to be cached. Only used if {@link #afterInvocation()} is\n   * true.\n   */\n  @Nonbinding Class<? extends Throwable>[] cacheFor() default {};\n\n  /**\n   * Defines zero (0) or more exception {@link Class Classes}, which must be a\n   * subclass of {@link Throwable}, indicating which exception types <b>must\n   * not</b> cause the parameter to be cached. Only used if\n   * {@link #afterInvocation()} is true.\n   */\n  @Nonbinding Class<? extends Throwable>[] noCacheFor() default {};\n}\n```\n\n`@CacheKey` 注解可以用来选择参数列表的一个子集来生成缓存 key。`@CacheValue` 注解的参数不会参与 key 的生成。\n\nOptions\n\n1. 可以指定 `Cache.put` 操作发生在方法调用前或方法调用后\n2. 如果缓存在方法调用完做，方法执行时抛出了异常，则 `Cache.put` 调用将取消\n\n静态方法的 `@CachePut` 将直接忽略。\n\n#### `@CacheRemove`\n\n这是一个方法级注解，用于标记从指定 `Cache` 中删除条目的方法。\n\n定义如下：\n\n```java\npackage javax.cache.annotation;\n\nimport javax.cache.Cache;\nimport javax.cache.CacheManager;\nimport javax.enterprise.util.Nonbinding;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n\n/**\n * When a method annotated with {@link CacheRemove} is invoked a {@link\n * GeneratedCacheKey} will be generated and {@link Cache#remove(Object)} will be\n * invoked on the specified cache.\n * <p>\n * The default behavior is to call {@link Cache#remove(Object)} after\n * the annotated method is invoked, this behavior can be changed by setting\n * {@link #afterInvocation()} to false in which case\n * {@link Cache#remove(Object)} will be called before the annotated\n * method is invoked.\n * <p>\n * Example of removing a specific Domain object from the \"domainCache\". A {@link\n * GeneratedCacheKey} will be generated from the String and int parameters and\n * used to call {@link Cache#remove(Object)} after the deleteDomain\n * method completes successfully.\n * <pre><code>\n * package my.app;\n *\n * public class DomainDao {\n *   &#64;CacheRemove(cacheName=\"domainCache\")\n *   public void deleteDomain(String domainId, int index) {\n *     ...\n *   }\n * }\n * </code></pre>\n * <p>\n * Exception Handling, only used if {@link #afterInvocation()} is true.\n * <ol>\n * <li>If {@link #evictFor()} and {@link #noEvictFor()} are both empty then all\n * exceptions prevent the remove</li>\n * <li>If {@link #evictFor()} is specified and {@link #noEvictFor()} is not\n * specified then only exceptions that pass an instanceof check against the\n * evictFor list result in a remove</li>\n * <li>If {@link #noEvictFor()} is specified and {@link #evictFor()} is not\n * specified then all exceptions that do not pass an instanceof check against the\n * noEvictFor result in a remove</li>\n * <li>If {@link #evictFor()} and {@link #noEvictFor()} are both specified then\n * exceptions that pass an instanceof check against the evictFor list but do not\n * pass an instanceof check against the noEvictFor list result in a remove</li>\n * </ol>\n *\n * @author Eric Dalquist\n * @author Rick Hightower\n * @author Greg Luck\n * @see CacheKey\n * @since 1.0\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface CacheRemove {\n\n  /**\n   * The name of the cache.\n   * <p>\n   * If not specified defaults first to {@link CacheDefaults#cacheName()},\n   * and if that is not set then to:\n   * package.name.ClassName.methodName(package.ParameterType,package.ParameterType)\n   */\n  @Nonbinding String cacheName() default \"\";\n\n  /**\n   * When {@link Cache#remove(Object)}  should be called. If true it is called\n   * after the annotated method invocation completes successfully. If false it is\n   * called before the annotated method is invoked.\n   * <p>\n   * Defaults to true.\n   * <p>\n   * If true and the annotated method throws an exception the remove will not be\n   * executed.\n   */\n  @Nonbinding boolean afterInvocation() default true;\n\n  /**\n   * The {@link CacheResolverFactory} used to find the {@link CacheResolver} to\n   * use at runtime.\n   * <p>\n   * The default resolver pair will resolve the cache by name from the default\n   * {@link CacheManager}\n   */\n  @Nonbinding Class<? extends CacheResolverFactory> cacheResolverFactory()\n      default CacheResolverFactory.class;\n\n  /**\n   * The {@link CacheKeyGenerator} to use to generate the {@link\n   * GeneratedCacheKey} for interacting with the specified Cache.\n   * <p>\n   * Defaults to a key generator that uses\n   * {@link java.util.Arrays#deepHashCode(Object[])}\n   * and {@link java.util.Arrays#deepEquals(Object[], Object[])} with the array\n   * returned by {@link CacheKeyInvocationContext#getKeyParameters()}\n   *\n   * @see CacheKey\n   */\n  @Nonbinding Class<? extends CacheKeyGenerator> cacheKeyGenerator()\n      default CacheKeyGenerator.class;\n\n  /**\n   * Defines zero (0) or more exception {@link Class classes}, that must be a\n   * subclass of {@link Throwable}, indicating the exception types that must cause\n   * a cache eviction. Only used if {@link #afterInvocation()} is true.\n   */\n  @Nonbinding Class<? extends Throwable>[] evictFor() default {};\n\n  /**\n   * Defines zero (0) or more exception {@link Class Classes}, that must be a\n   * subclass of {@link Throwable}, indicating the exception types that must\n   * <b>not</b> cause a cache eviction. Only used if {@link #afterInvocation()} is\n   * true.\n   */\n  @Nonbinding Class<? extends Throwable>[] noEvictFor() default {};\n}\n```\n\n`@CacheKey` 注解可以用来选择参数列表的一个子集来生成缓存 key。\n\nOptions\n\n1. 可以指定 `Cache.remove` 操作发生在方法调用前或方法调用后\n2. 如果缓存操作在方法调用完做，方法执行时抛出了异常，则 `Cache.remove` 调用可以取消\n\n静态方法的 `@CacheRemove` 将直接忽略。\n\n#### `@CacheRemoveAll`\n\n这是一个方法级的注解，用于标记执行完成后删除所有条目的方法。\n\n定义如下：\n\n```java\npackage javax.cache.annotation;\n\nimport javax.cache.Cache;\nimport javax.cache.CacheManager;\nimport javax.enterprise.util.Nonbinding;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n\n/**\n * When a method annotated with {@link CacheRemoveAll} is invoked all elements in\n * the specified cache will be removed via the\n * {@link Cache#removeAll()} method\n * <p>\n * The default behavior is to call {@link Cache#removeAll()} after the\n * annotated method is invoked, this behavior can be changed by setting {@link\n * #afterInvocation()} to false in which case {@link Cache#removeAll()}\n * will be called before the annotated method is invoked.\n * <p>\n * Example of removing all Domain objects from the \"domainCache\". {@link\n * Cache#removeAll()} will be called after deleteAllDomains() returns\n * successfully.\n * <pre><code>\n * package my.app;\n *\n * public class DomainDao {\n *   &#64;CacheRemoveAll(cacheName=\"domainCache\")\n *   public void deleteAllDomains() {\n *     ...\n *   }\n * }\n * </code></pre>\n * <p>\n * Exception Handling, only used if {@link #afterInvocation()} is true.\n * <ol>\n * <li>If {@link #evictFor()} and {@link #noEvictFor()} are both empty then all\n * exceptions prevent the removeAll</li>\n * <li>If {@link #evictFor()} is specified and {@link #noEvictFor()} is not\n * specified then only exceptions that pass an instanceof check against the\n * evictFor list result in a removeAll</li>\n * <li>If {@link #noEvictFor()} is specified and {@link #evictFor()} is not\n * specified then all exceptions that do not pass an instanceof check against the\n * noEvictFor result in a removeAll</li>\n * <li>If {@link #evictFor()} and {@link #noEvictFor()} are both specified then\n * exceptions that pass an instanceof check against the evictFor list but do not\n * pass an instanceof check against the noEvictFor list result in a removeAll</li>\n * </ol>\n *\n * @author Eric Dalquist\n * @author Rick Hightower\n * @since 1.0\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface CacheRemoveAll {\n\n  /**\n   * /**\n   * The name of the cache.\n   * <p>\n   * If not specified defaults first to {@link CacheDefaults#cacheName()} and if\n   * that is not set it defaults to:\n   * package.name.ClassName.methodName(package.ParameterType,package.ParameterType)\n   */\n  @Nonbinding String cacheName() default \"\";\n\n  /**\n   * When {@link Cache#removeAll()} should be called. If true it is called after\n   * the annotated method invocation completes successfully. If false it is called\n   * before the annotated method is invoked.\n   * <p>\n   * Defaults to true.\n   * <p>\n   * If true and the annotated method throws an exception the removeAll will not be\n   * executed.\n   */\n  @Nonbinding boolean afterInvocation() default true;\n\n  /**\n   * The {@link CacheResolverFactory} used to find the {@link CacheResolver} to\n   * use at runtime.\n   * <p>\n   * The default resolver pair will resolve the cache by name from the default\n   * {@link CacheManager}\n   */\n  @Nonbinding Class<? extends CacheResolverFactory> cacheResolverFactory()\n      default CacheResolverFactory.class;\n\n  /**\n   * Defines zero (0) or more exception {@link Class classes}, that must be a\n   * subclass of {@link Throwable}, indicating the exception types that must\n   * cause a cache eviction. Only used if {@link #afterInvocation()} is true.\n   */\n  @Nonbinding Class<? extends Throwable>[] evictFor() default {};\n\n  /**\n   * Defines zero (0) or more exception {@link Class Classes}, that must be a\n   * subclass of {@link Throwable}, indicating the exception types that must\n   * <b>not</b> cause a cache eviction. Only used if {@link #afterInvocation()} is\n   * true.\n   */\n  @Nonbinding Class<? extends Throwable>[] noEvictFor() default {};\n}\n```\n\nOptions\n\n1. 可以指定 `Cache.removeAll` 操作发生在方法调用前或方法调用后\n2. 如果缓存操作在方法调用完做，方法执行时抛出了异常，则 `Cache.removeAll` 调用可以取消\n\n静态方法的 `@CacheRemove` 将直接忽略。\n\n#### `@CacheKey`\n\n这是一个参数级的注解来标记指定参数需要用于 key 的生成。在运行时，带有 `@CacheKey` 的参数可以用 `CacheKeyInvocationContext.getKeyParameters()` 来获取\n\n一般与下列注解一起使用。\n\n```java\n@CacheResult\n@CachePut\n@CacheRemove\n```\n\n#### `@CacheValue`\n\n这是一个参数级别的注解，用户标记使用 `@CachePut` 注解的方法要缓存的参数。被注解的参数不会在 `CacheKeyInvocationContext.getKeyParameters()` 中。只与 `@CachePut` 一起使用。\n\n#### 一个例子\n\n```java\n/**\n * An implementation of BlogManager that uses a variety of annotations\n * @author Rick Hightower\n */\n@CacheDefaults(cacheName = \"blgMngr\")\npublic class ClassLevelCacheConfigBlogManagerImpl implements BlogManager {\n\n  private static Map<String, Blog> map = new HashMap<String, Blog>();\n\n  @CacheResult\n  public Blog getEntryCached(String title) {\n    return map.get(title);\n  }\n\n  public Blog getEntryRaw(String title) {\n    return map.get(title);\n  }\n\n  /**\n   * @see manager.BlogManager#clearEntryFromCache(java.lang.String)\n   */\n  @CacheRemove\n  public void clearEntryFromCache(String title) {\n  }\n\n  public void clearEntry(String title) {\n    map.put(title, null);\n  }\n\n  @CacheRemoveAll\n  public void clearCache() {\n  }\n\n  public void createEntry(Blog blog) {\n    map.put(blog.getTitle(), blog);\n  }\n\n  @CacheResult\n  public Blog getEntryCached(String randomArg, @CacheKey String title,\n                             String randomArg2) {\n    return map.get(title);\n  }\n}\n```\n\n### 缓存解析\n\n所有方法级别的注释都允许指定 `CacheResolverFactory` 和缓存名称，用于确定在运行时要与之交互的缓存。\n\n定义如下：\n\n```java\npackage javax.cache.annotation;\n\nimport javax.cache.Cache;\nimport java.lang.annotation.Annotation;\n\n/**\n * Determines the {@link CacheResolver} to use for an annotated method. The\n * {@link CacheResolver} will be retrieved once per annotated method.\n * <p>\n * Implementations MUST be thread-safe.\n *\n * @author Eric Dalquist\n * @since 1.0\n */\npublic interface CacheResolverFactory {\n\n  /**\n   * Get the {@link CacheResolver} used at runtime for resolution of the\n   * {@link Cache} for the {@link CacheResult}, {@link CachePut},\n   * {@link CacheRemove}, or {@link CacheRemoveAll} annotation.\n   *\n   * @param cacheMethodDetails The details of the annotated method to get the\n   *                           {@link CacheResolver} for. @return The {@link\n   *                           CacheResolver} instance to be\n   *                           used by the interceptor.\n   */\n  CacheResolver getCacheResolver(CacheMethodDetails<? extends Annotation>\n                                     cacheMethodDetails);\n\n  /**\n   * Get the {@link CacheResolver} used at runtime for resolution of the {@link\n   * Cache} for the {@link CacheResult} annotation to cache exceptions.\n   * <p>\n   * Will only be called if {@link CacheResult#exceptionCacheName()} is not empty.\n   *\n   * @param cacheMethodDetails The details of the annotated method to get the\n   *                           {@link CacheResolver} for.\n   * @return The {@link CacheResolver} instance to be used by the interceptor.\n   */\n  CacheResolver getExceptionCacheResolver(CacheMethodDetails<CacheResult>\n                                              cacheMethodDetails);\n}\n```\n\n#### 缓存名\n\n如果方法级注解和类级的注解都没有定义缓存名的话，将使用如下方式生成默认的缓存名：\n\n`package.name.ClassName.methodName(package.ParameterType,package.ParameterType)`\n\n`@CacheResult` 注解有 `exceptionCacheName` 属性，如果未指定此属性，则没有默认的异常缓存名，并且不使用异常缓存。\n\n#### 缓存解析器工厂\n\n必须为每个带注释的方法必须精确地调用一次指定的 `CacheResolverFactory` 来确定每次方法执行都要使用的 `CacheResolver`。 当执行带注释的方法时，先前获取的 `CacheResolver` 加上 `CacheInvocationContext` 确定要使用的缓存。\n\n如果 `javax.cache.annotation.CacheResolverFactory` 在方法注解和 `@CacheDefaults` 上都指定了，那么会使用默认的 `CacheResolverFactory`\n\n默认的 `CacheResolverFactory` 按顺序做以下的操作：\n\n- 获取 `CacheManager`。\n\n```java\nCachingProvider provider = Caching.getCachingProvider();\nCacheManager cacheManager =  provider.getCacheManager(provider.getDefaultURI(), provider.getDefaultClassLoader());\n```\n\n- 调用 `CacheManager.getCache(String cacheName)` 获取缓存\n- 如果 `Cache` 没有的话，将使用下面的方式创建。\n\n```java\nCache cache = cacheManager.createCache(cacheName, new MutableConfiguration());\n```\n\n- 使用获取到的 `Cache` 创建一个 `CacheResolver`。\n\n如果 `CacheResolverFactory` 执行时抛了一个异常，异常需要向上抛到触发 `CacheResolverFactory` 执行的位置\n\n#### `CacheResolver`\n\n`CacheResolver` 由 `CacheResolverFactory` 返回，并且在每个被注解的方法被调用时返回对应的 `Cache`。\n\n定义如下：\n\n```java\npackage javax.cache.annotation;\n\nimport javax.cache.Cache;\nimport java.lang.annotation.Annotation;\n\n/**\n * Determines the {@link Cache} to use for an intercepted method invocation.\n * <p>\n * Implementations MUST be thread-safe.\n *\n * @author Eric Dalquist\n * @see CacheResolverFactory\n * @since 1.0\n */\npublic interface CacheResolver {\n\n  /**\n   * Resolve the {@link Cache} to use for the {@link CacheInvocationContext}.\n   *\n   * @param <K> the type of key\n   * @param <V> the type of value\n   * @param cacheInvocationContext The context data for the intercepted method\n   *                               invocation\n   * @return The {@link Cache} instance to be used by the interceptor\n   */\n  <K, V> Cache<K, V> resolveCache(CacheInvocationContext<? extends Annotation>\n                                      cacheInvocationContext);\n}\n```\n\n如果 `CacheResolver` 抛了异常，那么异常需要需要向上传播到 触发 `CacheResolverFactory` 执行的位置。\n\n### key 生成\n\n`@CacheResult`，`@CachePut` 和 `@CacheRemove` 注解均需要生成缓存键，并且这些注解均允许指定 `CacheKeyGenerator` 的实现。\n\n指定的 `CacheKeyGenerator` 将为每个带注释的方法调用被调用一次。 `CacheKeyInvocationContext` 提供有关带注释的方法和当前调用的信息。由开发人员指定要在键中使用的方法参数包含在 `getKeyParameters()` 方法返回的 `CacheInvocationParameter` 数组中。定制的`CacheKeyGenerator` 可以使用任何可用的信息来生成 `GeneratedCacheKey`。\n\n如果未在注解和 `@CacheDefaults` 上指定 `javax.cache.annotation.CacheKeyGenerator`，则必须使用默认的 `CacheKeyGenerator`。\n\n默认 `CacheKeyGenerator` 生成方法：\n\n- 从 `CacheKeyInvocationContext.getKeyParameters()` 中拿到 `CacheInvocationParameter`，然后调用 `getValue()` 创建 `Object []`。\n- 创建一个 `CacheKey` 实例，该实例包装 `Object []` 并使用 `Arrays.deepHashCode` 计算其 `hashCode` 和 `Arrays.deepEquals` 以与其他键进行比较。\n\n如果 `CacheKeyGenerator` 产生异常，则必须将该异常传播到触发 `CacheKeyGenerator` 执行的应用程序代码。\n\n### 注解支持类\n\n#### `CacheMethodDetails`\n\n提供被缓存注解标记的方法的静态新。`CacheResolverFactory` 用这个来确定运行时使用的 `CacheResolver`。\n\n接口定义如下：\n\n```java\npackage javax.cache.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Set;\n\n/**\n * Static information about a method annotated with one of:\n * {@link CacheResult}, {@link CachePut}, {@link CacheRemove}, or {@link\n * CacheRemoveAll}\n * <p>\n * Used with {@link CacheResolverFactory#getCacheResolver(CacheMethodDetails)} to\n * determine the {@link CacheResolver} to use with the method.\n *\n * @param <A> The type of annotation this context information is for. One of\n *            {@link CacheResult}, {@link CachePut}, {@link CacheRemove}, or\n *            {@link CacheRemoveAll}.\n * @author Eric Dalquist\n * @see CacheResolverFactory\n */\npublic interface CacheMethodDetails<A extends Annotation> {\n  /**\n   * The annotated method\n   *\n   * @return The annotated method\n   */\n  Method getMethod();\n\n  /**\n   * An immutable Set of all Annotations on this method\n   *\n   * @return An immutable Set of all Annotations on this method\n   */\n  Set<Annotation> getAnnotations();\n\n  /**\n   * The caching related annotation on the method.\n   * One of: {@link CacheResult}, {@link CachePut}, {@link CacheRemove}, or\n   * {@link CacheRemoveAll}\n   *\n   * @return The caching related annotation on the method.\n   */\n  A getCacheAnnotation();\n\n  /**\n   * The cache name resolved by the implementation.\n   * <p>\n   * The cache name is determined by first looking at the cacheName attribute of\n   * the method level annotation. If that attribute is not set then the class\n   * level {@link CacheDefaults} annotation is checked. If that annotation does\n   * not exist or does not have its cacheName attribute set then the following\n   * cache name generation rules are followed:\n   * <p>\n   * \"fully qualified class name\".\"method name\"(\"fully qualified parameter class\n   * names\")\n   * <p>\n   * For example:\n   * <pre><code>\n   * package my.app;\n   *\n   * public class DomainDao {\n   *   &#64;CacheResult\n   *   public Domain getDomain(String domainId, int index) {\n   *     ...\n   *   }\n   * }\n   * </code></pre>\n   * <p>\n   * Results in the cache name: \"my.app.DomainDao.getDomain(java.lang.String,int)\"\n   *\n   * @return The fully resolved cache name\n   */\n  String getCacheName();\n}\n```\n\n#### `CacheInvocationContext`\n\n包含了被缓存注解标记的方法执行时的运行时信息。`CacheResolver` 用这个来确定需要使用哪个 `Cache`。拓展自 `CacheMethodDetails`，所以静态信息对运行时可用。\n\n接口定义如下：\n\n```java\npackage javax.cache.annotation;\n\nimport java.lang.annotation.Annotation;\n\n/**\n * Runtime information about an intercepted method invocation for a method\n * annotated with {@link CacheResult}, {@link CachePut}, {@link CacheRemove},\n * or {@link CacheRemoveAll}\n * <p>\n * Used with {@link CacheResolver#resolveCache(CacheInvocationContext)} to\n * determine the {@link javax.cache.Cache} to use at runtime for the method\n * invocation.\n *\n * @param <A> The type of annotation this context information is for. One of\n *            {@link CacheResult}, {@link CachePut}, {@link CacheRemove}, or {@link\n *            CacheRemoveAll}.\n * @author Eric Dalquist\n * @see CacheResolver\n */\npublic interface CacheInvocationContext<A extends Annotation>\n    extends CacheMethodDetails<A> {\n\n  /**\n   * @return The object the intercepted method was invoked on.\n   */\n  Object getTarget();\n\n  /**\n   * Returns a clone of the array of all method parameters.\n   *\n   * @return An array of all parameters for the annotated method\n   */\n  CacheInvocationParameter[] getAllParameters();\n\n  /**\n   * Return an object of the specified type to allow access to the\n   * provider-specific API. If the provider\'s\n   * implementation does not support the specified class, the {@link\n   * IllegalArgumentException} is thrown.\n   *\n   * @param <T> The type of the expected underlying {@link javax.cache.Cache} implementation.\n   * @param cls the class of the object to be returned. This is normally either the\n   *            underlying implementation class or an interface that it implements.\n   * @return an instance of the specified class\n   * @throws IllegalArgumentException if the provider doesn\'t support the specified\n   *            class.\n   */\n  <T> T unwrap(java.lang.Class<T> cls);\n}\n```\n\n#### `CacheKeyInvocationContext`\n\n用于生成 key 时所需的运行时信息。`CacheKeyGenerator` 用这个来生成缓存key，接口拓展自 `CacheInvocationContext`\n\n接口定义如下：\n\n```java\npackage javax.cache.annotation;\n\nimport java.lang.annotation.Annotation;\n\n/**\n * Runtime information about an intercepted method invocation for a method\n * annotated with {@link CacheResult}, {@link CachePut}, or\n * {@link CacheRemove}.\n * <p>\n * Used with {@link CacheKeyGenerator#generateCacheKey(CacheKeyInvocationContext)}\n * to generate a {@link GeneratedCacheKey} for the invocation.\n *\n * @param <A> The type of annotation this context information is for. One of\n *            {@link CacheResult}, {@link CachePut}, or {@link CacheRemove}.\n * @author Eric Dalquist\n * @see CacheKeyGenerator\n */\npublic interface CacheKeyInvocationContext<A extends Annotation>\n    extends CacheInvocationContext<A> {\n\n  /**\n   * Returns a clone of the array of all method parameters to be used by the\n   * {@link\n   * CacheKeyGenerator} in creating a {@link GeneratedCacheKey}. The returned array\n   * may be the same as or a subset of the array returned by\n   * {@link #getAllParameters()}\n   * <p>\n   * Parameters in this array are selected by the following rules:\n   * <ul>\n   * <li>If no parameters are annotated with {@link CacheKey} or {@link\n   * CacheValue}\n   * then all parameters are included</li>\n   * <li>If a {@link CacheValue} annotation exists and no {@link CacheKey} then\n   * all\n   * parameters except the one annotated with {@link CacheValue} are included</li>\n   * <li>If one or more {@link CacheKey} annotations exist only those parameters\n   * with the {@link CacheKey} annotation are included</li>\n   * </ul>\n   *\n   * @return An array of all parameters to be used in cache key generation\n   */\n  CacheInvocationParameter[] getKeyParameters();\n\n  /**\n   * When a method is annotated with {@link CachePut} this is the parameter\n   * annotated with {@link CacheValue}\n   *\n   * @return The parameter to cache, will never be null for methods annotated with\n   *         {@link CachePut}, will be null for methods not annotated with {@link\n   *         CachePut}\n   */\n  CacheInvocationParameter getValueParameter();\n}\n```\n\n#### `CacheInvocationParameter`\n\n方法执行时，其中一个参数的运行时信息。包括参数注解，位置，类型和值，由 `CacheInvocationContext` 和 `CacheKeyInvocationContext` 来提供。\n\n接口定义如下：\n\n```java\npackage javax.cache.annotation;\n\nimport java.lang.annotation.Annotation;\nimport java.util.Set;\n\n/**\n * A parameter to an intercepted method invocation. Contains the parameter value\n * as well static type and annotation information about the parameter.\n *\n * @author Eric Dalquist\n */\npublic interface CacheInvocationParameter {\n\n  /**\n   * The parameter type as declared on the method.\n   */\n  Class<?> getRawType();\n\n  /**\n   * @return The parameter value\n   */\n  Object getValue();\n\n  /**\n   * @return An immutable Set of all Annotations on this method parameter, never\n   * null.\n   */\n  Set<Annotation> getAnnotations();\n\n  /**\n   * The index of the parameter in the original parameter array as returned by\n   * {@link CacheInvocationContext#getAllParameters()}\n   *\n   * @return The index of the parameter in the original parameter array.\n   */\n  int getParameterPosition();\n}\n```\n\n#### `GeneratedCacheKey`\n\n由 `CacheKeyGenerator` 接口创建，这个用于表示与 `Cache` 交互的 key，所有的 `GeneratedCacheKey` 都不可变且可序列化。\n\n定义如下：\n\n```java\npackage javax.cache.annotation;\n\nimport java.io.Serializable;\n\n/**\n * A {@link Serializable}, immutable, thread-safe object that is used as a key,\n * automatically generated by a {@link CacheKeyGenerator}.\n * <p>\n * The implementation MUST follow the Java contract for {@link Object#hashCode()}\n * and {@link Object#equals(Object)} to ensure correct behavior.\n * <p>\n * It is recommended that implementations also override {@link Object#toString()}\n * and provide a human-readable string representation of the key.\n *\n * @author Eric Dalquist\n * @see CacheKeyGenerator\n * @since 1.0\n */\npublic interface GeneratedCacheKey extends Serializable {\n\n  /**\n   * The immutable hash code of the cache key.\n   *\n   * @return The hash code of the object\n   * @see Object#hashCode()\n   */\n  @Override\n  int hashCode();\n\n  /**\n   * Compare this {@link GeneratedCacheKey} with another. If the two objects\n   * are equal their {@link #hashCode()} values MUST be equal as well.\n   *\n   * @param object The other object to compare to.\n   * @return true if the objects are equal\n   * @see Object#equals(Object)\n   */\n  @Override\n  boolean equals(Object object);\n}\n```\n\n### 注解交互\n\n#### 注解继承与排序\n\n本规范遵循Java通用规范[2]的第2.1节中关于注释继承的规定。 关于本规范之外的注释，拦截器的执行顺序未定义，而是留给注解支持方实现。\n\n#### 多注解\n\n在一个方法上只能指定一个方法级别的缓存注解，而在一个参数上只能指定一个参数的级别缓存注解。 如果在一个方法上指定了多个注解，则建议注解处理器抛出特定于实现的异常或记录警告。\n\n## 管理\n\n`javax.cache.management` 包里包含了用于缓存管理和统计的 `MXBean` 接口。\n\n### 启用和禁用\n\n缓存管理和统计默认是关闭的，为了使用它们需要使用 `MutableConfiguration` 的\n\n```java\nsetManagementEnabled(boolean enabled) // 管理是否启用\nsetStatisticsEnabled(boolean enabled) // 统计是否启用\n```\n\n为了在运行时启用禁用，`CacheManager` 提供了一下两个方法:\n\n```java\n/**\n * Controls whether management is enabled. If enabled the\n * {@link javax.cache.management.CacheMXBean} for each cache is registered in\n * the platform MBean server. THe platform MBeanServer is obtained using\n * {@link java.lang.management.ManagementFactory#getPlatformMBeanServer()}\n * <p/>\n * Management information includes the name and configuration information for\n * the cache.\n * <p/>\n * Each cache\'s management object must be registered with an ObjectName that\n * is unique and has the following type and attributes:\n * <p/>\n * Type:\n * <code>javax.cache:type=Cache</code>\n * <p/>\n * Required Attributes:\n * <ul>\n * <li>CacheManager the name of the CacheManager\n * <li>Cache the name of the Cache\n * </ul>\n *\n * @param cacheName the name of the cache to register\n * @param enabled   true to enable management, false to disable.\n */\nvoid enableManagement(String cacheName, boolean enabled);\n```\n\n```java\n/**\n * Enables or disables statistics gathering for a managed {@link Cache} at\n * runtime.\n * <p/>\n * Each cache\'s statistics object must be registered with an ObjectName that\n * is unique and has the following type and attributes:\n * <p/>\n * Type:\n * <code>javax.cache:type=CacheStatistics</code>\n * <p/>\n * Required Attributes:\n * <ul>\n * <li>CacheManager the name of the CacheManager\n * <li>Cache the name of the Cache\n * </ul>\n *\n * @param cacheName the name of the cache to register\n * @param enabled   true to enable statistics, false to disable.\n * @throws IllegalStateException if the cache is {@link #isClosed()}\n * @throws NullPointerException  if cacheName is null\n */\nvoid enableStatistics(String cacheName, boolean enabled);\n```\n\n### MXBean 定义\n\n`CacheMXBean` 提供了缓存配置的详细信息，接口定义如下:\n\n```java\npackage javax.cache.management;\n\nimport javax.cache.Cache;\nimport javax.cache.integration.CacheLoader;\nimport javax.cache.integration.CacheWriter;\nimport javax.management.MXBean;\n\n/**\n * A management bean for cache. It provides configuration information. It does not\n * allow mutation of configuration or mutation of the cache.\n * <p>\n * Each cache\'s management object must be registered with an ObjectName that is\n * unique and has the following type and attributes:\n * <p>\n * Type:\n * <code>javax.cache:type=CacheConfiguration</code>\n * <p>\n * Required Attributes:\n * <ul>\n * <li>CacheManager the URI of the CacheManager\n * <li>Cache the name of the Cache\n * </ul>\n *\n * @author Greg Luck\n * @author Yannis Cosmadopoulos\n * @since 1.0\n */\n@MXBean\npublic interface CacheMXBean {\n\n  /**\n   * Determines the required type of keys for this {@link Cache}, if any.\n   *\n   * @return the fully qualified class name of the key type,\n   * or \"java.lang.Object\" if the type is undefined.\n   */\n  String getKeyType();\n\n  /**\n   * Determines the required type of values for this {@link Cache}, if any.\n   * @return the fully qualified class name of the value type,\n   * or \"java.lang.Object\" if the type is undefined.\n   */\n  String getValueType();\n\n  /**\n   * Determines if a {@link Cache} should operate in read-through mode.\n   * <p>\n   * When in read-through mode, cache misses that occur due to cache entries\n   * not existing as a result of performing a \"get\" call via one of\n   * {@link Cache#get},\n   * {@link Cache#getAll},\n   * {@link Cache#getAndRemove} and/or\n   * {@link Cache#getAndReplace} will appropriately\n   * cause the configured {@link CacheLoader} to be\n   * invoked.\n   * <p>\n   * The default value is <code>false</code>.\n   *\n   * @return <code>true</code> when a {@link Cache} is in\n   *         \"read-through\" mode.\n   * @see CacheLoader\n   */\n  boolean isReadThrough();\n\n  /**\n   * Determines if a {@link Cache} should operate in \"write-through\"\n   * mode.\n   * <p>\n   * When in \"write-through\" mode, cache updates that occur as a result of\n   * performing \"put\" operations called via one of\n   * {@link Cache#put},\n   * {@link Cache#getAndRemove},\n   * {@link Cache#removeAll},\n   * {@link Cache#getAndPut}\n   * {@link Cache#getAndRemove},\n   * {@link Cache#getAndReplace},\n   * {@link Cache#invoke}\n   * {@link Cache#invokeAll}\n   * <p>\n   * will appropriately cause the configured {@link CacheWriter} to be invoked.\n   * <p>\n   * The default value is <code>false</code>.\n   *\n   * @return <code>true</code> when a {@link Cache} is in \"write-through\" mode.\n   * @see CacheWriter\n   */\n  boolean isWriteThrough();\n\n  /**\n   * Whether storeByValue (true) or storeByReference (false).\n   * When true, both keys and values are stored by value.\n   * <p>\n   * When false, both keys and values are stored by reference.\n   * Caches stored by reference are capable of mutation by any threads holding\n   * the reference. The effects are:\n   * <ul>\n   * <li>if the key is mutated, then the key may not be retrievable or\n   * removable</li>\n   * <li>if the value is mutated, then all threads in the JVM can potentially\n   * observe those mutations, subject to the normal Java Memory Model rules.</li>\n   * </ul>\n   * Storage by reference only applies to the local heap. If an entry is moved off\n   * heap it will need to be transformed into a representation. Any mutations that\n   * occur after transformation may not be reflected in the cache.\n   * <p>\n   * When a cache is storeByValue, any mutation to the key or value does not affect\n   * the key of value stored in the cache.\n   * <p>\n   * The default value is <code>true</code>.\n   *\n   * @return true if the cache is store by value\n   */\n  boolean isStoreByValue();\n\n  /**\n   * Checks whether statistics collection is enabled in this cache.\n   * <p>\n   * The default value is <code>false</code>.\n   *\n   * @return true if statistics collection is enabled\n   */\n  boolean isStatisticsEnabled();\n\n  /**\n   * Checks whether management is enabled on this cache.\n   * <p>\n   * The default value is <code>false</code>.\n   *\n   * @return true if management is enabled\n   */\n  boolean isManagementEnabled();\n\n}\n```\n\n`CacheStatisticsMXBean` 提供了缓存的统计信息，定义如下：\n\n```java\npackage javax.cache.management;\n\nimport javax.management.MXBean;\n\n/**\n * Cache statistics.\n * <p>\n * Statistics are accumulated from the time a cache is created. They can be reset\n * to zero using {@link #clear}.\n * <p>\n * There are no defined consistency semantics for statistics. Refer to the\n * implementation for precise semantics.\n * <p>\n * Each cache\'s statistics object must be registered with an ObjectName that is\n * unique and has the following type and attributes:\n * <p>\n * Type:\n * <code>javax.cache:type=CacheStatistics</code>\n * <p>\n * Required Attributes:\n * <ul>\n * <li>CacheManager the URI of the CacheManager\n * <li>Cache the name of the Cache\n * </ul>\n *\n * @author Greg Luck\n * @since 1.0\n */\n@MXBean\npublic interface CacheStatisticsMXBean {\n\n  /**\n   * Clears the statistics counters to 0 for the associated Cache.\n   */\n  void clear();\n\n  /**\n   * The number of get requests that were satisfied by the cache.\n   * <p>\n   * {@link javax.cache.Cache#containsKey(Object)} is not a get request for\n   * statistics purposes.\n   * <p>\n   * In a caches with multiple tiered storage, a hit may be implemented as a hit\n   * to the cache or to the first tier.\n   * <p>\n   * For an {@link javax.cache.processor.EntryProcessor}, a hit occurs when the\n   * key exists and an entry processor can be invoked against it, even if no\n   * methods of {@link javax.cache.Cache.Entry} or\n   * {@link javax.cache.processor.MutableEntry} are called.\n   *\n   * @return the number of hits\n   */\n  long getCacheHits();\n\n  /**\n   * This is a measure of cache efficiency.\n   * <p>\n   * It is calculated as:\n   * {@link #getCacheHits} divided by {@link #getCacheGets ()} * 100.\n   *\n   * @return the percentage of successful hits, as a decimal e.g 75.\n   */\n  float getCacheHitPercentage();\n\n  /**\n   * A miss is a get request that is not satisfied.\n   * <p>\n   * In a simple cache a miss occurs when the cache does not satisfy the request.\n   * <p>\n   * {@link javax.cache.Cache#containsKey(Object)} is not a get request for\n   * statistics purposes.\n   * <p>\n   * For an {@link javax.cache.processor.EntryProcessor}, a miss occurs when the\n   * key does not exist and therefore an entry processor cannot be invoked\n   * against it.\n   * <p>\n   * In a caches with multiple tiered storage, a miss may be implemented as a miss\n   * to the cache or to the first tier.\n   * <p>\n   * In a read-through cache a miss is an absence of the key in the cache that\n   * will trigger a call to a CacheLoader. So it is still a miss even though the\n   * cache will load and return the value.\n   * <p>\n   * Refer to the implementation for precise semantics.\n   *\n   * @return the number of misses\n   */\n  long getCacheMisses();\n\n  /**\n   * Returns the percentage of cache accesses that did not find a requested entry\n   * in the cache.\n   * <p>\n   * This is calculated as {@link #getCacheMisses()} divided by\n   * {@link #getCacheGets()} * 100.\n   *\n   * @return the percentage of accesses that failed to find anything\n   */\n  float getCacheMissPercentage();\n\n  /**\n   * The total number of requests to the cache. This will be equal to the sum of\n   * the hits and misses.\n   * <p>\n   * A \"get\" is an operation that returns the current or previous value. It does\n   * not include checking for the existence of a key.\n   * <p>\n   * In a caches with multiple tiered storage, a gets may be implemented as a get\n   * to the cache or to the first tier.\n   *\n   * @return the number of gets\n   */\n  long getCacheGets();\n\n  /**\n   * The total number of puts to the cache.\n   * <p>\n   * A put is counted even if it is immediately evicted.\n   * <p>\n   * Replaces, where a put occurs which overrides an existing mapping is counted\n   * as a put.\n   *\n   * @return the number of puts\n   */\n  long getCachePuts();\n\n  /**\n   * The total number of removals from the cache. This does not include evictions,\n   * where the cache itself initiates the removal to make space.\n   *\n   * @return the number of removals\n   */\n  long getCacheRemovals();\n\n  /**\n   * The total number of evictions from the cache. An eviction is a removal\n   * initiated by the cache itself to free up space. An eviction is not treated as\n   * a removal and does not appear in the removal counts.\n   *\n   * @return the number of evictions\n   */\n  long getCacheEvictions();\n\n  /**\n   * The mean time to execute gets.\n   * <p>\n   * In a read-through cache the time taken to load an entry on miss is not\n   * included in get time.\n   *\n   * @return the time in µs\n   */\n  float getAverageGetTime();\n\n  /**\n   * The mean time to execute puts.\n   *\n   * @return the time in µs\n   */\n  float getAveragePutTime();\n\n  /**\n   * The mean time to execute removes.\n   *\n   * @return the time in µs\n   */\n\n  float getAverageRemoveTime();\n\n}\n```\n\n### 访问管理信息\n\n没有提供用于管理或统计的访问器方法。 启用后，将缓存实现将实现的 `MBeanServer` 注册 `MXBean`。\n\n然后可以按照JMX定义的常规方法从对应的 `MBeanServer` 获得 Bean。\n\n简单的进程内实现可能只使用通过 `ManagementFactory.getPlatformMBeanServer()`访问的 `MBeanServer` 平台。 缓存实现必须记录如何解析用于存储缓存管理信息的`MBeanServer`。\n\nJMX 属性名称的遵循 JavaBeans [15]属性命名的约定。 因此，`CacheStatisticsMXBean` 上的访问器 `getCacheHitPercentage()` 对应于JMX属性 `CacheHitPercentage`。\n\n#### 例子\n\n这个例子展示了如何读取名称为 `simpleCache` 的 `Cache` 的 `CacheHitPercentage`。\n\n```java\nCachingProvider cachingProvider = Caching.getCachingProvider();\nCacheManager cacheManager = cachingProvider.getCacheManager();\n\nMutableConfiguration<String, Integer> config =\n    new MutableConfiguration<String, Integer>();\nconfig.setTypes(String.class, Integer.class)\n    .setExpiryPolicyFactory(AccessedExpiryPolicy.factoryOf(ONE_HOUR))\n    .setStatisticsEnabled(true);\n\ncacheManager.createCache(\"simpleCache\", config);\nCache<String, Integer> cache = cacheManager.getCache(\"simpleCache\",\n    String.class, Integer.class);\n\nSet<ObjectName> registeredObjectNames = null;\nMBeanServer mBeanServer = ManagementFactory.getPlatformMBeanServer();\n\nObjectName objectName = new ObjectName(\"javax.cache:type=CacheStatistics\"\n    + \",CacheManager=\" + (cache.getCacheManager().getURI().toString())\n    + \",Cache=\" + cache.getName());\nSystem.out.println(mBeanServer.getAttribute(objectName,\n    \"CacheHitPercentage\"));\n```\n\n### 影响统计的缓存操作\n\n下表概述了影响统计的缓存操作。在表中，如果存在，则将命中某些事件；如果不存在，则将发生未命中。该表在每一列中都将具有“是”。 如果将高速缓存设置为 `Read-Through` 模式，在需要调用 `CacheLoader` 加载数据时，也算做缓存未命中。\n\n|方法|修改|删除|命中|未命中|\n|---|---|---|---|---|\n|`boolean containsKey(K key)`| NO|NO|NO|NO|\n|`V get(K key)`| NO |NO|YES|YES|\n|`Map<K,V> getAll(Collection<? extends K> keys)`|NO||NO|YES|YES|\n|`V getAndPut(K key, V value)`|YES|NO|YES|YES|\n|`V getAndRemove(K key)`|NO|YES|YES|YES|\n|`V getAndReplace(K key, V value)`|YES|NO|YES|YES|\n|`<T> T invoke(K key, EntryProcessor<K, V, T> entryProcessor, Object... arguments)entryProcessor);`|当 `setValue()` 被调用时YES|当 `remove()` 被调用时。|YES|YES|\n|`<T> Map<K, EntryProcessorResult<T>> invokeAll(Set<? extends K> keys,EntryProcessor<K, V, T> entryProcessor, Object... arguments);`|当 `setValue()` 被调用时|当 `remove()` 被调用时。|YES|YES|\n|`Iterator<Cache.Entry<K, V>> iterator()`|NO|当 `remove()` 被调用时。|YES|NO|\n|`void loadAll(Set<? extends K> keys, boolean replaceExistingValues, CompletionListener listener)`|NO|NO|NO|NO|\n|`void put(K key, V value)`|YES|NO|NO|NO|\n|`void putAll(Map<? extends K,? extends V> map)`|YES|NO|NO|NO|\n|`boolean putIfAbsent(K key, V value)`||YES|NO|YES|YES|\n|`boolean remove(K key)`|NO|返回true时YES|NO|NO|\n|`boolean remove(K key, V oldValue)`|NO|返回true时YES|NO|NO|\n|`void removeAll()`|NO|每个被移除条目一次|NO|NO|\n|`void removeAll(Set<? extends K> keys)`|NO|每个被移除条目一次|NO|NO|\n|`boolean replace(K key, V value)`|YES|NO|YES|YES|\n|`boolean replace(K key, V oldValue, V newValue)`|YES|NO|YES|YES|\n\n## 可移植性建议\n\n下面对于提升应用的可移植性的建议。\n\n1. 自定义的 Key 类需要实现 `Object.hashcode()` 和 `Object.equals()` 方法，自定义的 Value 类需要正确覆写 `Object.equals()`\n2. 为了支持默认的 按值存储 的语义，自定义的 key 和 Value 类应该能够被序列化\n3. 缓存不使用正斜杠（/）或冒号（:)作为其名称的一部分。另外，建议缓存名称以java开头。或javax。不应使用。\n4. 当请求CacheManager时，应用程序使用默认的URI和属性。\n5. 应用程序避免使用规范的可选功能，或者使用CachingProvider.isSupported方法来利用可选功能（如果存在）。例如，按引用存储过程中的实现可能比按值存储具有更高的性能，因为键和值可以直接引用。\n6. 应用程序将专有配置保留在专有声明性配置文件中，而不是使用专有程序化缓存构造。\n7. 不使用CacheManager，Cache，Cache.Entry和CacheInvocationContext中的unwrap方法。它们分别用于访问Cache和Cache.Entry 的专用实现。使用专有的API会降低可移植性。\n8. 应用程序不对缓存架构进行任何假设。例如，假设监听器将在本地执行，并创建对本地应用程序类实例的依赖关系，则可能无法跨实现移植。\n9. 对于CAS操作，按引用存储将使用 equals（）方法进行比较，但按值存储不一定。 确保在自定义值类型上的equals（）实现考虑到所有非瞬态字段，以便对序列化形式的比较将得出与使用 equals（）方法进行比较的结果相同的结果。\n10. 应用程序避免在 EntryProcessor，CacheEntryListener，CacheLoader，CacheWriter或ExpiryPolicy的实现中对Cache和CacheManager方法进行引用和调用。重入算法可能导致不可预测的应用程序行为，包括运行时异常，死锁和/或无限制的资源消耗。\n\n\n## 参考\n\n1. [JSR107 Specification 1.1.1 Maintenance Release - Google Doc](https://docs.google.com/document/d/1ijduF_tmHvBaUS7VBBU2ZN8_eEBiFaXXg9OI0_ZxCrA/edit?usp=sharing)\n1. [jsr107/jsr107spec - GitHub](https://github.com/jsr107/jsr107spec)\n1. [jsr107 - jcp.org](https://jcp.org/aboutJava/communityprocess/final/jsr107/index.html)\n','Java',6,'2023-05-24 03:30:21'),(1016,'awaitility 使用手册','原文链接：[https://github.com/awaitility/awaitility/wiki/Usage](https://github.com/awaitility/awaitility/wiki/Usage)\n\n- [awaitility 使用手册](#awaitility-%e4%bd%bf%e7%94%a8%e6%89%8b%e5%86%8c)\n  - [Static imports](#static-imports)\n  - [Usage examples](#usage-examples)\n  - [Simple](#simple)\n  - [Reusing Conditions](#reusing-conditions)\n  - [Fields](#fields)\n  - [Atomic, Adders and Accumulators](#atomic-adders-and-accumulators)\n  - [Advanced](#advanced)\n  - [Lambdas](#lambdas)\n  - [Using AssertJ or Fest Assert](#using-assertj-or-fest-assert)\n  - [Ignoring Exceptions](#ignoring-exceptions)\n  - [Checked exceptions in Runnable lambda expressions](#checked-exceptions-in-runnable-lambda-expressions)\n  - [At Least](#at-least)\n    - [Ignoring uncaught exceptions](#ignoring-uncaught-exceptions)\n    - [Assert that a value is maintained](#assert-that-a-value-is-maintained)\n  - [Thread Handling](#thread-handling)\n  - [Exception handling](#exception-handling)\n  - [Deadlock detection](#deadlock-detection)\n  - [Defaults](#defaults)\n  - [Polling](#polling)\n  - [Fixed Poll Interval](#fixed-poll-interval)\n  - [Fibonacci Poll Interval](#fibonacci-poll-interval)\n  - [Iterative Poll Interval](#iterative-poll-interval)\n  - [Custom Poll Interval](#custom-poll-interval)\n  - [Condition Evaluation Listener](#condition-evaluation-listener)\n  - [Duration](#duration)\n  - [Important](#important)\n  - [Links and code examples](#links-and-code-examples)\n\n## Static imports\n\n为了有效地使用Awaitility，建议从Awaitility框架中静态导入以下方法：\n\n- `org.awaitility.Awaitility.*`\n\n导入以下方法也可能有用：\n\n- `java.time.Duration.*`\n- `java.util.concurrent.TimeUnit.*`\n- `org.hamcrest.Matchers.*`\n- `org.junit.Assert.*`\n\n## Usage examples\n\n## Simple\n\n假设我们向异步系统发送 “add user” 消息，如下所示：\n\n```java\npublish(new AddUserMessage(\"Awaitility Rocks\"));\n```\n\n在您的测试用例中，Awaitility 可以帮助您轻松地验证数据库是否已更新。最简单的形式可能是这样的：\n\n```java\nawait().until(newUserIsAdded());\n```\n\n`newUserIsAdded` 是在测试用例中自己实现的方法。它指定必须满足的条件，以便 Awaitility 停止等待。\n\n```java\nprivate Callable<Boolean> newUserIsAdded() {\n    // The condition that must be fulfilled\n    return () -> userRepository.size() == 1;\n}\n```\n\n当然，您也可以内联 `newUserIsAdded` 方法，只需编写：\n\n```java\nawait().until(() -> userRepository.size() == 1);\n```\n\n默认情况下，Awaitility 将等待10秒，如果在此期间用户资源库的大小不等于1，它将抛出一个 [`ConditionTimeoutException`](http://static.javadoc.io/org.awaitibility/awaitibility/4.0.2/org/awaitibility/core/ConditionTimeoutException.html)，测试失败。如果需要不同的超时，可以如下定义：\n\n```java\nawait().atMost(5, SECONDS).until(newUserWasAdded());\n```\n\n## Reusing Conditions\n\nAwaitility 还支持将条件拆分为结果生成和匹配两部分部分，以便更好地重用。上面的例子也可以写成：\n\n```java\nawait().until( userRepositorySize(), equalTo(1) );\n```\n\n`userRepositorySize` 方法现在返回 `Callable<Integer>`。\n\n```java\nprivate Callable<Integer> userRepositorySize() {\n    // The suppling part of the condition\n      return () -> userRepository.size();\n}\n```\n\n`equalTo` 是一个标准的 [Hamcrest](http://code.google.com/p/hamcrest/) 匹配器，指定 Awaitility 的匹配部分。\n\n现在我们可以在不同的测试中重用 `userRepositorySize`。假设我们有一个同时增加三个用户的测试：\n\n```java\npublish(new AddUserMessage(\"User 1\"), new AddUserMessage(\"User 2\"), new AddUserMessage(\"User 3\"));\n```\n\n我们现在重用 `userRepositorySize`，只需更新 Hamcrest 匹配器：\n\n```java\nawait().until( userRepositorySize(), equalTo(3) );\n```\n\n在这种简单的情况下，您当然也可以使用Java方法引用：\n\n```java\nawait().until(userRepository::size, equalTo(3) );\n```\n\n## Fields\n\n您还可以通过引用字段来构建供应部分。例如：\n\n```java\nawait().until( fieldIn(object).ofType(int.class), equalTo(2) );\n```\n\nor:\n\n```java\nawait().until( fieldIn(object).ofType(int.class).andWithName(\"fieldName\"), equalTo(2) );\n```\n\nor:\n\n```java\nawait().until( fieldIn(object).ofType(int.class).andAnnotatedWith(MyAnnotation.class), equalTo(2) );\n```\n\n## Atomic, Adders and Accumulators\n\n如果您正在使用[Atomic](http://download.oracle.com/javase/1,5.0/docs/api/java/util/concurrent/atomic/package-summary.html)数据结构，Awaitility 提供了一种简单的方法来等待它们匹配特定值：\n\n```java\nAtomicInteger atomic = new AtomicInteger(0);\n// Do some async stuff that eventually updates the atomic integer\nawait().untilAtomic(atomic, equalTo(1));\n```\n\n等待一个 AtomicBoolean 更简单：\n\n```java\nAtomicBoolean atomic = new AtomicBoolean(false);\n// Do some async stuff that eventually updates the atomic boolean\nawait().untilTrue(atomic);\n```\n\n如果您正在使用 Adders，例如 [LongAdder](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAdder.html)，则Awaitility 可让您简单地等待使其达到一定的值：\n\n```java\nawait().untilAdder(myLongAdder, equalTo(5L))\n```\n\n同样，如果使用累加器，例如 [LongAccumulator](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/LongAccumulator.html)，则可以执行以下操作：\n\n```java\nawait().untilAccumulator(myLongAccumulator, equalTo(5L))\n```\n\n## Advanced\n\n使用100毫秒的轮询间隔，初始延迟为20毫秒，直到客户状态等于 “REGISTERED”。本示例还通过指定别名（“customer registration”）来使用命名的 await。如果您在同一测试中有多个 await，那么很容易找出哪个等待语句失败。\n\n```java\nwith().pollInterval(ONE_HUNDERED_MILLISECONDS).and().with().pollDelay(20, MILLISECONDS).await(\"customer registration\").until(\n            customerStatus(), equalTo(REGISTERED));\n```\n\n您还可以指定这样的别名：\n\n```java\nawait().with().alias(\"my alias\"). ..\n```\n\n要使用非固定的轮询间隔，请参考 [轮询间隔](＃polling)文档。\n\n## Lambdas\n\n您可以在条件中使用 lambda 表达式：\n\n```java\nawait().atMost(5, SECONDS).until(() -> userRepository.size() == 1);\n```\n\n或方法引用：\n\n```java\nawait().atMost(5, SECONDS).until(userRepository::isNotEmpty);\n```\n\n或方法引用和 Hamcrest 匹配器的组合：\n\n```java\nawait().atMost(5, SECONDS).until(userRepository::size, is(1));\n```\n\n您还可以使用谓词：\n\n```java\nawait().atMost(5, SECONDS).until(userRepository::size, size -> size == 1);\n```\n\n有关示例，请参阅 [Jayway小组博客](http://www.jayway.com/2014/04/23/java-8-and-assertj-support-in-awaitility-1-6-0/\")。\n\n## Using AssertJ or Fest Assert\n\n您可以使用 [AssertJ](http://joel-costigliola.github.io/assertj/)或 [Fest Assert](https://code.google.com/p/fest/) 代替 Hamcrest（实际上可以使用任何在出错时引发异常的第三方库）。\n\n```java\nawait().atMost(5, SECONDS).untilAsserted(() -> assertThat(fakeRepository.getValue()).isEqualTo(1));\n```\n\n## Ignoring Exceptions\n\n在条件评估期间忽略某些类型的异常有时很有用。例如，如果您在等待到达最终状态之前正在等待将异常作为中间状态抛出的事件。以Spring的 [SocketUtils](http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/util/SocketUtils.html) 类为例，该类使您可以在给定范围查找 TCP 端口。如果在给定范围内没有端口可用，它将抛出异常。假设我们知道给定范围内的某些端口不可用，但我们要等待它们可用。这是一个示例，我们可以选择忽略“SocketUtils”引发的任何异常。例如：\n\n```java\ngiven().ignoreExceptions().await().until(() -> SocketUtils.findAvailableTcpPort(x,y));\n```\n\n这指示 Awaitility 在条件评估期间忽略所有捕获的异常。异常将被视为评估失败。与提供的异常类型匹配的异常，测试不会失败（除非超时）。您还可以忽略特定的异常：\n\n```java\ngiven().ignoreException(IllegalStateException.class).await().until(() -> SocketUtils.findAvailableTcpPort(x,y));\n```\n\n或使用 Hamcrest 匹配器：\n\n```java\ngiven().ignoreExceptionsMatching(instanceOf(RuntimeException.class)).await().until(() -> SocketUtils.findAvailableTcpPort(x,y));\n```\n\n或使用谓词（Java 8）：\n\n```java\ngiven().ignoreExceptionsMatching(e -> e.getMessage().startsWith(\"Could not find an available\")).await().until(something());\n```\n\n您也可以忽略 `Throwable` 实例。\n\n## Checked exceptions in Runnable lambda expressions\n\nJava中的 `Runnable` 接口不允许您抛出已检查的异常。因此，如果您有这样的方法：\n\n```java\npublic void waitUntilCompleted() throws Exception { ... }\n```\n\n可能会引发异常，如果 `untilAsserted` 将 `Runnable` 作为其参数值，则您必须捕获该异常：\n\n```java\nawait().untilAsserted(() -> {\n   try {\n      waitUntilCompleted();\n   } catch(Exception e) {\n     // Handle exception\n   }\n});\n```\n\n幸运的是，Awaitility 通过引入传递给 `untilAsserted` 的 [ThrowingRunnable](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/core/ThrowingRunnable.html) 接口来解决此问题。而不是 `Runnable`。因此，您需要编写的代码如下所示：\n\n```java\nawait().untilAsserted(() -> waitUntilCompleted());\n```\n\n## At Least\n\n您可以指定 awaitility **最少** 等待一定时间。例如：\n\n```java\nawait().atLeast(1, SECONDS).and().atMost(2, SECONDS).until(value(), equalTo(1));\n```\n\n如果在由 atLeast 指定的持续时间之前满足条件，则会引发异常，条件不应早于指定的时间完成。\n\n### Ignoring uncaught exceptions\n\n如果要将代码从使用 `Thread.sleep` 迁移到 Awaitility，请注意，在某些情况下，由于其他线程抛出异常，因此 Awaitility 测试用例可能会失败。这是因为默认情况下，Awaitility 捕获所有未捕获的异常。因此，如果您以前使用过 `Thread.sleep`，那么很有可能您没有捕获其他线程的异常。如果您对此行为感到满意，并且不希望 Awaitility 捕获这些异常，则可以使用 `dontCatchUncaughtExceptions` 禁用此功能：\n\n```java\n@Test\npublic void dontCatchUncaughtExample() {\n    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();\n    executor.setMaxPoolSize(1);\n    executor.afterPropertiesSet();\n\n    executor.execute(new ErrorTestTask());\n    ListenableFuture<?> future = executor.submitListenable(new ErrorTestTask());\n\n    Awaitility.await()\n              .dontCatchUncaughtExceptions()\n              .atMost(1, TimeUnit.SECONDS)\n              .pollInterval(10, TimeUnit.MILLISECONDS)\n              .until(future::isDone);\n}\n\nprivate static class ErrorTestTask implements Runnable {\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(100);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n        throw new RuntimeException(Thread.currentThread().getName() + \" -> Error\");\n    }\n}\n```\n\n### Assert that a value is maintained\n\n从4.0.2版开始，可以断言某个值在特定时间段内得到维护。例如，如果您需要确保存储库中的值在 1500毫秒中的 800毫秒内保持特定值：\n\n```java\nawait().during(800, MILLISECONDS).atMost(1500, MILLISECONDS).until(() -> myRepository.findById(\"id\"), equalTo(\"something\"));\n```\n\nAwaitility 将最多等待1500毫秒，而这样做的话，`myRepository.findById(id)` 必须等于 `something` 至少 800毫秒。\n\n## Thread Handling\n\nAwaitility 允许进行细粒度的线程配置。这是通过提供 Awaility 轮询条件时将使用的线程提供者或 `ExecutorService` 来完成的。请注意，这是一项高级功能，应谨慎使用。例如：\n\n```java\ngiven().pollThread(Thread::new).await().atMost(1000, MILLISECONDS).until(..);\n```\n\n另一种方法是指定 `ExecutorService`：\n\n```java\nExecutorSerivce es = ...\ngiven().pollExecutorService(es).await().atMost(1000, MILLISECONDS).until(..);\n```\n\n例如，如果您需要等待轮询 [ThreadLocal](https://docs.oracle.com/javase/7/docs/api/java/lang/ThreadLocal.html) 变量的条件，这将很有用。\n\n在某些情况下，重要的是能够指示 Awaitility 使用与启动 Awaitility 的测试用例相同的线程。因此，Awaitility 3.0.0 引入了 [pollInSameThread](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/core/ConditionFactory.html#pollInSameThread--) 方法：\n\n```java\nwith().pollInSameThread().await().atMost(1000, MILLISECONDS).until(...);\n```\n\n这是一项高级功能，在将 `pollInSameThread` 与永远等待（或长时间）的条件结合使用时应格外小心，因为当 Awaitility 使用与测试相同的线程时，它不会中断该线程。\n\n## Exception handling\n\n默认情况下，Awaitility 捕获所有线程中未捕获的 `Throwable`，并将其传播到等待线程。这意味着您的测试用例将指示失败，即使不是引发未捕获异常的测试线程也是如此。\n\n您可以选择忽略某些异常或可抛出对象，请参见 [here](＃ignoring-exceptions)。\n\n如果不需要在所有线程中都捕获异常，则可以使用 [dontCatchUncaughtExceptions](#ignoring-uncaught-exceptions)。\n\n## Deadlock detection\n\nAwaitility自动检测死锁，并将 [ConditionTimeoutException](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/core/ConditionTimeoutException.html) 的原因与 [DeadlockException](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/core/DeadlockException.html)。 `DeadlockException` 包含有关导致死锁的线程的信息。\n\n## Defaults\n\n如果未指定任何超时，则 Awaitility 将等待10秒钟，然后引发 [ConditionTimeoutException](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/core/ConditionTimeoutException.html)（如果条件尚未满足）。默认轮询间隔和轮询延迟为100毫秒。您还可以自己使用以下命令指定默认值：\n\n```java\n  Awaitility.setDefaultTimeout(..)\n  Awaitility.setDefaultPollInterval(..)\n  Awaitility.setDefaultPollDelay(..)\n```\n\n您还可以使用 `Awaitility.reset` 将其重置为默认值。\n\n## Polling\n\n请注意，由于 Awaitility 使用轮询来验证条件是否匹配，因此不建议将其用于精确的性能测试。在这些情况下，最好使用 AOP 框架，例如 AspectJ。\n\n另请注意，[Duration.ZERO](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/Duration.html#ZERO) 用作所有非固定轮询间隔的起始值间隔。对于固定的轮询间隔，出于向后兼容的原因，轮询延迟等于 `FixedPollInterval` 的持续时间。\n\n有关其他详细信息，请参见 [this blog](http://code.haleby.se/2015/11/27/non-fixed-poll-intervals-in-awaitility/)。\n\n## Fixed Poll Interval\n\n这是 Awaitilty 的默认轮询间隔机制。以正常方式使用DSL时，例如：\n\n```java\nwith().pollDelay(100, MILLISECONDS).and().pollInterval(200, MILLISECONDS).await().until(<condition>);\n```\n\nAwaitility 将使用 [FixedPollInterval](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/pollinterval/FixedPollInterval.html)。这意味着 Awaitility 将在 poll delay（轮询开始之前的初始延迟，在上面的示例中为100ms）之后首次检查是否满足指定条件。除非明确指定，否则 Awaitility 将使用与轮询间隔相同的轮询延迟（请注意，这仅适用于固定轮询间隔，如上例所示）。这意味着它将首先在给定的轮询延迟后定期检查条件，然后再以给定的轮询间隔进行检查；那就是在 pollDelay 之后检查条件，然后pollDelay + pollInterval，然后pollDelay +（2 *pollInterval），依此类推。如果更改轮询间隔，则轮询延迟也将更改为与指定的轮询间隔相匹配，除非您已明确指定了轮询延迟。\n\n## Fibonacci Poll Interval\n\n[FibonacciPollInterval](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/pollinterval/FibonacciPollInterval.html) 会根据斐波那契序列生成一个非线性轮询间隔。用法示例：\n\n```java\nwith().pollInterval(fibonacci()).await().until(..);\n```\n\n其中的 `fibonacci()`是从 `org.awaitility.pollinterval.FibonacciPollInterval` 静态导入的。这将生成一个 \"1、2、3、5、8、13，...\" 毫秒的轮询间隔。您可以配置要使用的时间单位，例如秒而不是毫秒：\n\n```java\nwith().pollInterval(fibonacci(TimeUnit.SECONDS)).await().until(..);\n```\n\n或使用 english-like 的配置方式\n\n```java\nwith().pollInterval(fibonacci().with().timeUnit(SECONDS).and().offset(5)).await().until(..);\n```\n\n偏移量表示斐波那契序列从该偏移量开始（默认情况下，偏移量为0）。偏移量也可以是负数（-1）以0开头（`fib（0）`= 0）。\n\n## Iterative Poll Interval\n\n由函数和开始持续时间生成的轮询间隔。该函数可以在持续时间内自由地执行任何操作。\n\n例如：\n\n```java\nawait().with().pollInterval(iterative(duration -> duration.multiply(2)), Duration.FIVE_HUNDRED_MILLISECONDS).until(..);\n```\n\n或使用 english-like 的配置方式\n\n```java\nawait().with().pollInterval(iterative(duration -> duration.multiply(2)).with().startDuration(FIVE_HUNDRED_MILLISECONDS)).until(..);\n```\n\n这将生成一个轮询间隔序列，看起来像这样（ms）：`500，1000，2000，4000，8000，16000，...`\n\n请注意，如果指定轮询初始延迟，则此延迟将在此轮询间隔生成第一个轮询间隔之前。有关更多信息，请参见[javadoc](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/pollinterval/IterativePollInterval.html)。\n\n## Custom Poll Interval\n\n通过实现 [PollInterval](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/pollinterval/PollInterval.html) 接口，可以滚动自己的轮询间隔。这是一个功能接口，因此在Java 8中，您可以像这样进行操作：\n\n```java\nawait().with().pollInterval((__, previous) -> previous.multiply(2).plus(1)).until(..);\n```\n\n在此示例中，我们创建一个`PollInterval`，该函数被实现为（bi-）函数，该函数采用先前的轮询间隔持续时间并将其乘以2并加1。`__` 只是表示我们不在乎 [PollInterval](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/pollinterval/PollInterval.html) 提供的轮询计数。当创建的轮询间隔不是（仅）对前一个持续时间感兴趣，而是根据其被调用的次数生成其持续时间时，需要轮询计数。例如，[FibonacciPollInterval](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/pollinterval/FibonacciPollInterval.html) 仅使用轮询计数：\n\n```java\nawait().with().pollInterval((pollCount, __) -> new Duration(fib(pollCount), MILLISECONDS)).until(..);\n```\n\n在大多数情况下，没有必要从头开始实施轮询间隔。改为向 [IterativePollInterval](＃iterative-poll-interval) 提供函数。\n\n## Condition Evaluation Listener\n\nAwaitility 1.6.1引入了 [Condition Evaluation Listener](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/core/ConditionEvaluationListener.html) 的概念。每当 Awaitility 评估条件时，都可以使用它来获取信息。例如，您可以使用它来在条件满足之前获取条件的中间值。它也可以用于打印日志。例如：\n\n```java\nwith().\n         conditionEvaluationListener(condition -> System.out.printf(\"%s (elapsed time %dms, remaining time %dms)\\n\", condition.getDescription(), condition.getElapsedTimeInMS(), condition.getRemainingTimeInMS())).\n         await().atMost(Duration.TEN_SECONDS).until(new CountDown(5), is(equalTo(0)));\n```\n\n将以下内容打印到控制台：\n\n```java\n    org.awaitility.AwaitilityJava8Test$CountDown expected (<0> or a value less than <0>) but was <5> (elapsed time 101ms, remaining time 1899ms)\n    org.awaitility.AwaitilityJava8Test$CountDown expected (<0> or a value less than <0>) but was <4> (elapsed time 204ms, remaining time 1796ms)\n    org.awaitility.AwaitilityJava8Test$CountDown expected (<0> or a value less than <0>) but was <3> (elapsed time 306ms, remaining time 1694ms)\n    org.awaitility.AwaitilityJava8Test$CountDown expected (<0> or a value less than <0>) but was <2> (elapsed time 407ms, remaining time 1593ms)\n    org.awaitility.AwaitilityJava8Test$CountDown expected (<0> or a value less than <0>) but was <1> (elapsed time 508ms, remaining time 1492ms)\n    org.awaitility.AwaitilityJava8Test$CountDown reached its end value of (<0> or a value less than <0>) (elapsed time 610ms, remaining time 1390ms)\n```\n\n有一个内置的用于记录日志的 ConditionEvaluationListener，名为 [ConditionEvaluationLogger](http://static.javadoc.io/org.awaitility/awaitility/4.0.2/org/awaitility/core/ConditionEvaluationLogger.html) 可以像这样使用：\n\n```java\nwith().conditionEvaluationListener(new ConditionEvaluationLogger()).await(). ...\n```\n\nAwaitility 4.0.2在 `ConditionEvaluationListener` 接口中引入了三个新的 hook（默认方法）：\n\n| Method        | Description   |\n| ------------------ |-------------|\n| `beforeEvaluation`   | 在条件评估之前调用 |\n| `exceptionIgnored`   | 处理条件评估时引发的被忽略异常 |\n| `onTimeout`          | 当条件超时时调用     |\n\n## Duration\n\nAwaitility提供了一个 [Duration](http://static.javadoc.io/org.awaitility/awaitility/1.6.5/org/awaitility/Duration.html) 类，其中包含一些预定义的持续时间值，例如 `ONE_HUNDRED_MILLISECONDS`，`FIVE_SECONDS` 和 `ONE_MINUTE`。您还可以在 `Duration` 实例上执行一些基本的数学运算。例如：\n\n```java\nnew Duration(5, SECONDS).plus(17, MILLISECONDS);\n```\n\n它将返回新的持续时间5017毫秒。请注意，持续时间是不可变的，因此调用 `plus` 将返回一个新实例。当使用非固定的 [轮询间隔](＃polling) 时这个比较有用。\n\n## Important\n\nAwaitility 并不能确保线程安全或线程同步！这是你的责任！确保您的代码已正确同步，或者使用线程安全的数据结构，例如volatile字段或类，例如 `AtomicInteger` 和 `ConcurrentHashMap`。\n\n## Links and code examples\n\n1. [Awaitility test case](https://github.com/awaitility/awaitility/blob/master/awaitility/src/test/java/org/awaitility/AwaitilityTest.java)\n1. [Awaitility test case Java 8](https://github.com/awaitility/awaitility/blob/master/awaitility-java8-test/src/test/java/org/awaitility/AwaitilityJava8Test.java)\n1. [Field supplier test case](https://github.com/awaitility/awaitility/blob/master/awaitility/src/test/java/org/awaitility/UsingFieldSupplierTest.java)\n1. [Atomic test case](https://github.com/awaitility/awaitility/blob/master/awaitility/src/test/java/org/awaitility/UsingAtomicTest.java)\n1. [Presentation](http://awaitility.googlecode.com/files/awaitility-khelg-2011.pdf) from [Jayway](http://www.jayway.com)\'s KHelg 2011\n','awaitility',7,'2023-05-16 14:22:03'),(1017,'深入理解 Java 虚拟机 学习笔记','## 第二章 Java 内存区域与内存溢出异常\n\n### 内存区域\n\n![java-memory-area](../res/java-memory-area.png)\n\n![](../res/对象内存模型.png)\n-- from 姜志明\n#### 对象创建\n\n1. 加载类\n    - 若已经在内存中则跳过。\n    - **类加载完以后就可以确定对象所需的空间大小** // TODO why?\n1. 分配内存\n    - 根据 GC 回收算法的不同，分配方式略有区别。\n        - 标记整理算法，使用空闲列表\n        - 带压缩的算法，使用指针碰撞（已分配和未分配内存间由指针分隔）\n1. 内存清零\n1. 对象初始化\n\n#### 对象的内存布局\n\n![对象内存布局](../res/对象内存布局.png)\n\n- MarkWord 占用一个 **字** 的大小，其中分为两部分：\n    1. 对象自身运行时元数据。例如，哈希码、GC 分代年龄、锁状态标志等等\n    1. 类型指针。指向其类的元数据。\n    1. 若对象是数组则还需要保存数组的长度。\n- 域的存储顺序：\n    1. 基本类型优先，长度长的优先。\n    1. 父类域优先。子类较短域可插入父类域空隙。\n    1. 受虚拟机分配策略参数和域定义顺序的影响。\n\n#### 对象访问\n\n两种方式：\n\n1. 直接引用\n1. 引用句柄（句柄池）\n\n### 内存溢出异常\n\n#### 常用 JVM 参数 （Java HotSpot VM）\n\n|参数|含义|实例|\n|:---|:---|:---|\n|-verbose:class|显示每一个被加载的类的信息||\n|-verbose:gc|显示每一个 GC 事件的信息||\n|-Xmnsize|年轻代最大容量|-Xmn256m|\n|-Xmssize|堆的初始大小。1024 的整数倍并且要大于 1MB|-Xms6m|\n|-Xmxsize|堆的最大容量。1024 的整数倍并且要大于 2MB|-Xmx80m|\n|-Xsssize|线程栈容量。平台不同默认值不同，详情参考文档。Linux/x64 (64-bit): 1024 KB|-Xss1m|\n|-XX:MaxDirectMemorySize=size|直接内存的最大容量，默认与堆容量相同|-XX:MaxDirectMemorySize=1m|\n|-XX:+HeapDumpOnOutOfMemory|当抛出 OOM 时，使用 HPROF 将堆的快照保存到当前目录||\n|-XX:HeapDumpPath=path|设置快照输出路径|-XX:HeapDumpPath=/var/log/java/java_heapdump.hprof|\n|-XX:+PrintGCDetails|开启在 GC 时打印详细信息||\n|-XX:SurvivorRatio=ratio|新生代中 eden 与 survivor 的大小比例，默认为 8|-XX:SurvivorRatio=4|\n\n参考： [Java HotSpot VM 参数](http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)\n\n#### 常见异常及可能原因\n\n- 堆区\n    - `OutOfMemoryException`。使用工具对快照进行分析，看是否发生了内存泄露（内存中有不再使用的但无法回收的对象或资源）。若是，则通过分析引用链找到根源，解决问题；若不是检查虚拟机堆参数，看是否能够调大。再检查代码中是否有生命周期很长的大对象。\n- 虚拟机栈和本地方法栈\n    - `OutOfMemoryException`。栈容量 * 线程数量 = 固定值。当线程数量过多时会引发，可以适当减小栈容量。\n    - `StackOverflowException`。按异常查根源。\n- 方法区和运行时常量池\n- 直接内存溢出\n    - 不正确的使用 NIO。 \n    \n#### String 与字符串常量\n\n```java\npublic class StringTest {\n	public static void main(String[] args) {\n		String m = \"hello\";\n		String n = \"hello\";\n		String u = new String(m);\n		String v = new String(\"hello\");\n		\n		System.out.println(\"m == n: \" + (m == n));\n		System.out.println(\"m == u: \" + (m == u));\n		System.out.println(\"m == v: \" + (m == v));\n		System.out.println(\"u == v: \" + (u == v));\n	}\n}\n\noutput:\nm == n: true\nm == u: false\nm == v: false\nu == v: false\n```\n\n![内存模型](../res/string-const.png)\n\n参考： [初探Java字符串](http://mccxj.github.io/blog/20130615_java-string-constant-pool.html)\n\n## 第三章 垃圾收集器与内存分配策略\n\n### 判断对象是否存活\n\n1. 引用计数器算法。给对象添加一个引用计数器，增加/删除引用时对计数器进行修订。但是该方法因为无法解决循环引用（例如两个对象互相引用）的问题，所以一般不使用该方法\n1. 可达性分析算法。从 `GC root` 开始递归查询并标记，结束后未被标记的（不可达的）即为可回收的对象。`GC root` 共有四种：\n    - 栈中引用的对象\n    - 方法区常量引用的对象\n    - 方法区静态域引用的对象\n    - 本地方法中 JNI 引用的对象（不太懂）\n1. 回收方法区\n    - 新生代的回收效率可达到 70% - 95%，而永久代则低的多（性价比太低）\n    - 在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGi 这类频繁自定义 ClassLoader 的场景都需要虚拟机有卸载类的能力。 \n\n### 垃圾收集算法\n\n1. 标记-清除算法\n    - 扫描一遍，标记出需要回收的对象，再扫描将其清除\n    - 标记/清除两阶段时间效率都不高，且回收后空间较零碎。\n1. 复制算法\n    - 将内存分为两块，当一块中内存不足时，将其中所有存活对象复制到另一块中，回收当前一整块。\n    - 目前商用虚拟机大都使用这一算法回收新生代。将内存划分为一个较大的 Eden 区和两块较小的 Survivor. Eden：Survivor = 8：1\n1. 标记整理算法\n    - 标记出须清理的对象，然后其余对象移动到一端\n1. 分代收集算法\n    - 新生代使用复制算法\n    - 永久代使用其他两种算法\n\n### HotSpot 算法实现\n\n1. 当程序执行到安全点（safepoint）时进行 GC，通过在安全点（safepoint）生成的 OopMaps 快速遍历 GC root 进行回收。\n    - 安全点（safepoint）：指令序列复用的位置。例如方法调用、循环结构、异常跳转等位置。\n    - OopMaps：一种特殊的数据结构，用于枚举 GC root\n1. 但是如果线程处于不执行的状态时，如 sleep 或 blocked 无法执行到安全点，即需要提前标记为安全区域(safe region)。GC 时不考虑处于安全区域的线程，若安全区域代码执行结束但 GC 未结束时该线程等待 GC 结束信号。\n    - 安全区域（safe region）：引用不发生改变的代码片段\n\n### 垃圾收集器\n\n![gc collectors](../res/gc-collectors.jpg)\n\n- 并发(concurrent) vs 并行(parallel)\n    1. 并行是同时进行（多 CPU）\n    1. 并发可交替\n- Minor GC vs Major GC vs Full GC\n    - Minor GC：只回收新生代\n    - Major GC：只回收永久代\n    - Full GC： 回收整个堆。相当于 Minor GC + Major GC\n1. serial。单线程，简单高效。复制算法\n1. PerNew。serial 的多线程版本，并行。\n1. parallel Scavenge。 与 PerNew 类似，复制算法、多线程、并行。但侧重吞吐量，拥有自适应调节的能力。适合用在后台不需要太多用户交互的地方。\n    - 吞吐量 = 用户代码执行时间 / （用户代码执行时间 + 垃圾回收时间）\n    - 自适应调节：虚拟机根据但前系统的运行情况，自动调节虚拟机各参数以确保最大吞吐量。\n1. serial old。serial 的永久代版本。采用标记整理算法。\n1. parallel old。parallel Scavenge 的老年代版本，采用标记整理算法。与 parallel scavenge 搭配可以用在注重吞吐量及 CPU 资源敏感的地方。\n1. CMS（concurrent mark sweep）。并发低停顿，使用标记清理算法。非常优秀的一款收集器，但还是有几个缺点：\n    1. 对 CPU 资源敏感，当其小于数量小于 4 个是可能会对用户程序有较大影响。默认启动回收线程数 = （CPU 数 + 3）/ 4\n    1. 无法处理浮动垃圾。浮动垃圾：在垃圾回收期间生成的垃圾\n    1. 回收后会留有大量的空间碎片。\n1. G1 //TODO\n\n### 内存分配与回收策略\n\nTLAB（Thread local allocate buffer）线程私有分配缓冲区，每个线程一个\n\n1. 对象优先在 Eden 区分配。内存不足时触发 Minor GC。\n1. 大对象直接进入老年代。例如数组或超过参数指定大小的对象。\n1. 长期存活的对象进入老年代。GC 超过一定次数仍存活的对象。默认为 15 次，可通过虚拟机参数 `-XX:MaxTenuringThreshold` 来设置。\n1. 动态对象年龄判定。当一个年龄的所有对象大小总和超过 Servivor 空间一半时，大于等于该年龄的所有对象都进入老年代\n1. 空间分配担保。当发生 Minor GC 时，若存活的对象过多，servivor 空间无法全部容纳时，会将剩余的对象直接放入永久代；若永久代空间不足以容纳时会引发一次 Full GC\n\n## 第六章 类文件结构\n\n1. 类文件的结构拥有固定的格式，包含两部分的数据：\n    1. 类的元数据。\n    1. 方法代码的字节流\n1. `code` 属性表包含的属性\n    1. `max_stack` 存储操作数栈的最大深度值。运行时用来确定分配栈帧中所需的操作数栈深度。\n    1. `max_locals` 局部变量所需的最大空间大小\n1. 符号引用\n    1. 类与接口的全限定名\n    1. 域的名称与描述符\n    1. 方法名与描述符\n1. 该部分内容可以通过查表获得，不再赘述。\n\n## 第七章 虚拟机类加载机制\n\n### 类加载的过程\n\n![](../res/class-life.jpg)\n\n1. 加载\n    1. 通过全类名获取该类的二进制字节流\n    1. 解析字节流，将字节流所表达的静态存储结构转化为方法区的运行时数据结构 **（这是什么东西？）**\n    1. 为该类创建一个 `Class` 对象，用来访问该类的类数据\n1. 连接\n    1. 验证\n        - 为了确保加载的字节流时符合规范的，不会危害到虚拟机自身的安全。主要包括\n        1. 文件格式验证\n        1. 元数据验证\n        1. 字节码验证\n        1. 符号引用验证\n    1. 准备\n        - 为类变量分配内存并进行初步初始化（`0/null`）  // 不应该是在类加载阶段完成的么？\n    1. 解析\n        - 将符号引用替换为直接引用\n1. 初始化\n    - `static fields and block init`\n1. 使用\n1. 卸载\n\n### 类加载器\n\n1. 一个加载器确定一个类的命名空间。同一个类由不同加载器加载后是不同的类。\n1. ![](../res/classloader.png)\n    - 双亲委派：当需要加载一个类时先使用父类加载器（其实这个地方不是很准确，父子关系是通过复合来实现的），若失败了，再使用当前的加载器。如果自己写一个 `Object` 类，编译可通过但是由于双亲委派，它永远都不会被加载。\n\n## 第十章 早期（编译器）优化\n\n// TODO: 因本章含有相当多的编译原理相关概念，所以第十、十一章学习延后（预计第 8-9 周）\n\n### 前端编译过程（`*.java --> *.class`）\n\n1. 解析与填充符号表\n    1. 词法分析。将源代码转换为标记（`Token`） 的集合\n        - Token: 是编译过程中的最小元素。例如关键字、变量名、运算符等等\n    1. 语法分析。通过 `Token` 序列将构造抽象语法树(Abstract syntax tree)\n        \n\n## 参考\n\n1. 郑州大学姜志明老师课件\n1. [初探Java字符串](http://mccxj.github.io/blog/20130615_java-string-constant-pool.html) (非常好的一篇文章)\n1. [Java HotSpot VM 参数](http://docs.oracle.com/javase/8/docs/technotes/tools/unix/java.html)\n1. [Java HotSpot Virtual Machine Garbage Collection Tuning Guide](http://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/index.html)\n1. [JVM 垃圾回收器工作原理及使用实例介绍 -- IBM](https://www.ibm.com/developerworks/cn/java/j-lo-JVMGarbageCollection/)\n1. [Minor GC vs Major GC vs Full GC](https://plumbr.eu/blog/garbage-collection/minor-gc-vs-major-gc-vs-full-gc)\n1. [Abstract syntax tree](https://en.wikipedia.org/wiki/Abstract_syntax_tree)\n1. [4.4 Symbol Tables](http://introcs.cs.princeton.edu/java/44st/)','JVM',8,'2023-05-18 17:55:42'),(1018,'Ext4 文件系统简要总结','最近在看操作系统的文件系统这块，感觉只有理论还是不行，所以就选了一种文件系统作一下拓展。\n\n选择 Ext4 的原因是： 他是 Linux 的主流文件系统 `ext*` 家族中最新的版本\n\n主要内容：\n\n1. Ext4 的特性\n1. Ext4 磁盘布局\n- Tips： 本文内容主要是 [Ext4 文档](https://ext4.wiki.kernel.org/index.php/Main_Page) 的概括翻译加上自己的解释说明，所以英文水平还行的话建议直接看英文文档。\n\n本文假设读者对文件系统有基本的了解，否则请先查阅相关资料（《现代操作系统》《操作系统概念(影印版)》）\n\n\n## 主要特性\n\n### 兼容性(Compatibility)\n\nExt4 兼容 Ext3，升级只需运行一些命令即可，不需要变动磁盘格式，升级中不会影响已有的数据。\n\n### 更大的文件系统和文件大小(Bigger File System and File Sizes )\n\n|File System| Max FS Size | Max File Size|block addressing bits|\n|:---:|:---:|:---:|:---:|\n|Ext3|16TB|2TB|32|\n|Ext4|1EB|16TB|48|\n\nTips:\n- 1 EB = 1024 *  1024 TB\n- block size： 4 bytes\n\n### 拓展子目录数量(Sub directory scalability )\n\n在一个目录中，\n\n- Ext3 支持 32000 个子目录\n- Ext4 支持 64000 个子目录\n\n### 拓展块大小(Extents)\n\nExt3 为每个文件维护一个 block 表，用于保存这个文件在磁盘上的块号，因为一个 block 只有 4kb 的大小，所以对于一个大文件来说的话，需要维护的 block 表占用的空间就比较可观了，删除和截断等操作的效率也就比较低。\n\nExt4 使用 extents 代替 block。\nextents 由多个连续的 block 组成。能够有效的减少需要维护的 block 表的长度，进而提高在文件上操作的效率\n\n### 多块分配(Multiblock allocation)\n\n当需要将新数据写入磁盘上时，需要块分配器决定将数据写入哪一个空闲块中。\n\n但是 Ext3 写入的时候，每次只分配一个 block(4kb), 也就是说如果要写入 100 Mb 的数据时会调用块分配器 25600 词，效率很低，分配器也无法作优化。\n\nExt4 使用多块分配器，根据需要，一次调用分配多个块(一个 extents)\n\n### 延迟分配(Delayed allocation)\n\n传统的文件系统尽可能早的分配磁盘 blocks，当进程调用 `write()` 时，文件系统立即为其分配 block，即使数据并没有立即写入磁盘(在缓存中临时存放)。这种方式的缺点是当进程持续向文件写入数据，文件增长时需要分配另外的 block 来存放新增的数据，块分配器无法对分配方式作优化。\n\n而延迟分配策略解决了这个问题，当进程调用 `write()` 时它并不立即分配 blocks，直到数据从缓存写入磁盘时进行分配。写入磁盘时，数据基本就不再增长了，此时使用多块分配器为该文件分配多个 extents\n\n### 快速文件系统检测(Fast fsck)\n\n文件系统检测是一项非常慢的操作，特别是检查文件系统中所有的 inode 节点。\n\nExt4 跳过未使用的 inode 节点来加快检测速度，根据已使用的 inode 节点的数量不同，性能会提升 2 到 20 倍。\n\n### 日志校验(Journal checksumming)\n\n使用校验和来判断一个日志块是否已失效。\n\nExt3 使用两阶段(执行 + commit/rollback)提交来保证正确性。\n\nExt4 使用一阶段提交 + 日志校验来保证正确性，性能提升大约 20%。\n\n### 禁用日志模式(\"No Journaling\" mode )\n\n日志确保了磁盘上内容变动时文件系统的完整性，但是却带来了少量的额外开销(日志记录)。\n\n通过禁用日志特性可以获得少量的性能提升\n\n### 在线磁盘整理(Online defragmentation )\n\n这个特性正在开发中，会包含到之后的版本中。\n\n通过使用延迟分配、extents 和 多块分配能够有效减少磁盘碎片，但是文件内容变动(可以需要另外的 block 来存放数据，这个 block 可能会离原来的地方比较远，从而引发一次额外的寻道)也会带来很多碎片，磁盘碎片整理可以将文件尽可能的重分配到连续的 block 中，从而减少磁盘碎片，提高访问效率。\n\n### Inode 相关特性(Inode-related features)\n\n1. 更大的 inodes：Ext3 支持配置 inode 大小，默认为 128 bytes，Ext4 默认为 256 bytes。增加了一些额外的域(比如纳秒级的 timestamps 或 inode 版本)，剩余的空间用来保存拓展属性。这种方式可以使访问这些属性的速度更快，从而提高应用程序的性能。\n1. 当创建目录时，直接为其创建几个保留的 inode 节点，当在这个目录中创建新文件时，就可以直接使用这些保留的 inode 节点，从而提高文件创建和删除的效率。\n1. Ext3 的时间属性是秒级的，Ext4 的时间属性是纳秒级的。\n\n### 磁盘预分配(Persistent preallocation )\n\n这个特性允许应用程序预先分配磁盘空间，应用通知文件系统预先分配空间，文件系统预先分配需要的块和数据结构，直到应用程序向该空间写数据前，该空间中是没有数据的。\n\n### 屏障默认开启(Barriers on by default)\n\n这个选项改善了文件系统的完整性，但损失了一些性能。\n\n文件系统在写入数据之前必须先将事务信息记录到日志，然后根据顺序写入，但是这种方式效率比较低。现代的驱动有很大的内部缓存并且为了得到更好的性能会进行操作重排序，所以在写入数据之前，文件系统必须先显式的指示磁盘加载所有的日志。\n\n内核的 阻塞 I/O 子系统使用屏障来实现，即在加载日志时进行阻塞，其他数据 I/O 操作就无法再进行了。\n\n\n## Ext4 磁盘布局\n\n### 概述(Overview)\n\n![](../res/fs-layout.jpg)\n\n- MBR 为主引导记录用来引导计算机。在计算机启动时，BIOS 读入并执行 MBR，MBR 作的第一件事就是确定活动分区(这对应于双系统的计算机开机时选择启动项，单系统的直接就能确定了所以就不需要选择)，读入活动分区的引导块(Boot block)，引导块再加载该分区中的操作系统。\n- 分区表(Partition table)用来记录每个分区的起始和结束地址，表中的一个分区为活动分区。\n- 每个分区可以装载不同的文件系统, 下面介绍都以 Ext4 为例。\n    - Ex4 文件系统将磁盘分为一系列块组(block groups)。为了减少磁盘碎片带来的性能问题，减少寻道时间，块分配器总是尝试将每个文件的所有块分配到同一个块组中。块组的大小由超级块中的属性来定义，通常是 `8 * block_size_in_bytes` 对于块大小为 4Kb 的磁盘来说，每一个组可以包含 32768 个 block，总共 128Mb。块组的数目为磁盘空间除以块组大小\n    - 每个块组的磁盘布局都基本相同，下面就块组 0 做简单介绍\n        - 1024 bytes 的 Group 0 Padding（boot block）只有 块组0 有，用于装载该分区的操作系统。\n        - 超级块(super block)包含文件系统的所有关键参数。\n        - Group Descriptors。用于记录块组内部相关的信息。\n        - Reserved GDT Blocks。用于文件系统未来的拓展\n        - Data Block Bitmap。用于记录块组内部数据块的使用情况。\n        - inode Bitmap。用于记录 inode table 中的 inode 的使用情况。\n        - inode table\n        - Data Block\n\n在 Ext4 中除日志以外的数据都是以小端法存储的。\n\n#### 块(Blocks)\n\n一个块由偶数个扇区(sector)组成，一个块组又由多个块组成。块大小在 build file system 时被指定，通常是 4Kb。如果块大小大于内存页的大小，装载文件系统时可能会遇到问题。\n\n#### 布局(layout)\n\n![](../res/fs-ext4-layout.png)\n\n为了允许安装启动扇区和其他用途，块组 0 的开头 1024 bytes 未被使用。超级块从 第 1024 bytes 开始，通常在第 0 块，但如果块大小是 1Kb，则从第 1 块开始。\n\nExt4 驱动主要使用在第 0 块组的超级块和组描述符(Group Descriptors)来工作。为了防止磁盘开头部分崩溃而无法访问文件系统，会将超级块和组描述符的副本保存在多个块组中，没有保存副本的块组以数据块位图 (Data Block Bitmap) 开头。\n\ninode table 的位置保存在 `grp.bg_inode_table_*` 中，这是足够容纳 `sb.s_inodes_per_group * sb.s_inode_size` bytes 的连续块。\n\n#### 弹性块组(Flexible Block Groups)\n\n从 Ext4 开始，有了一个叫弹性块组(flex_bg)的新特性。在一个弹性块组中几个普通块组连在一起组成一个逻辑块组，几个普通块组的元数据(inode 节点表和位图等等)都存放在一起，然后弹性块组中剩余的空间都用来存放数据。这种方法可以加快加载速度并且可以使大文件连续存放。组成弹性块组的普通块组的数量为 `2 ^ sb.s_log_groups_per_flex`\n\n#### 元块组(Meta Block Groups)\n\n当没有 `META_BG` 选项时，为了安全考虑，所有的块组描述符都有一份副本存放在第一个块组中，块组默认大小是 128MB(2^27 bytes)，块组描述符是 64 bytes, 所以 ext4 最多能有 2^27 / 64 = 2^21 个块组，这限制了文件系统的大小为 2^21 * 128MB = 256TB。\n\n为了解决这个问题，引入了元块组(`META_BG`)的特性。一个 block 4kb ，可以容纳 64 个块组的描述符，ext4 文件系统以 64 个块组为单位组成一个个元块组，元块组的 64 个块组描述符都放在该元块组的第一个块组中，块组描述符的备份可以放在第二个块组和最后一个块组中。这样就将块组描述符从第一个块组移动到了整个文件系统。文件系统支持的大小从 256TB 增加到了 512PB(2^32 Block groups)。\n\n#### 块组初始化延迟(Lazy Block Group Initialization)\n\nExt4 提供了 3 个块组描述符标识来启用该特性。\n\n`INODE_UNINIT` 和 `BLOCK_UNINIT` 标识\n\n// TODO\n\n#### 特殊的节点(Special inodes)\n\n![](../res/fs-si.png)\n\n#### 块和节点分配策略(Block and Inode Allocation Policy)\n\n#### 校验和(Checksums)\n\n#### (Bigalloc)\n\n#### (inline Data)\n\n### 超级块(The Super Block)\n\n超级块记录了文件系统的关键参数。\n\n`sparse_super` 特性标志被设置后，冗余的超级块和组描述符的副本只保留在组号为 0 或组号为 3，5，7 的倍数的块组中，否则冗余副本会保存在所有的块组中。\n\n超级块占用 1Kb 空间。\n\n详细的参数描述请查阅官方文档，不再赘述。\n\n### 块组描述符(Block Group Descriptors)\n\n![](../res/fs-bgd.png)\n\n在一个块组中，拥有固定位置的数据结构只有超级块和块组描述符。\n\n`flex_bg` 和 `meta_bg` 并不是互斥关系。\n\next4 64-bits 特性未开启时占用 32 bytes，开启时占用 64 bytes。\n\n\n### 块和节点位图(Block and inode Bitmaps)\n\n位图用来记录数据块和 inode 节点的使用情况。\n\n位图中 1 bit 表示一个数据块或 inode 表中的一个节点的使用情况\n\n### 节点表(Inode Table)\n\n在常规的 UNIX 文件系统中， 节点存储文件所有的元数据（时间戳、块映射、拓展属性等等），目录使用另外的数据结构存储。为了找到一个文件的信息，首先要找到文件所在的目录，然后加载该文件的 inode 节点。\n\n为了性能方面的考虑，ext4 存储一部分文件属性到目录实体。\n\n节点表是 inode 节点的线性数组。节点表被分配足够的空间来存放至少 `sb.s_inode_size * sb.s_inodes_per_group` bytes 的节点信息。一个节点所在的块组号可以用 `(inode_number - 1) / sb.s_inodes_per_group` 来计算，在节点表中的偏移量为 `(inode_number - 1) % sb.s_inodes_per_group`\n\n节点属性较多，请查阅文档。\n\n#### 节点大小（Inode Size）\n\n节点大小由超级块中的 `s_inode_size` 决定，默认为 256 bytes。\n\n#### 查找节点（Finding an Inode）\n\nblock group = `(inode_number - 1) / sb.s_inodes_per_group`\n\ninode table index = `(inode_number - 1) % sb.s_inodes_per_group`\n\nbyte address in the inode table = (inode table index) * `sb->s_inode_size`\n\n#### 节点时间戳（Inode Timestamps）\n\ninode 节点中记录了四个时间戳，分别是 inode 修改时间(inode change time - ctime)，访问时间(access time - atime)，数据修改时间(data modification time - mtime)，删除时间(deletion time - dtime)。这四个域都是 32 位有符号数，代表了从 Unix 纪元(1970-01-01 00:00:00 GMT)所经过的秒数。会在 2038 年溢出。\n\n如果 inode 节点大于 128 bytes 并且多出的部分足够的话，会将 ctime、atime、mtime 拓宽到 64 位。在拓展的 32 位中，低 2 bit 会与原有的 32 位组合，用来表示秒数，高 30 bits用来提供纳秒级的精度。溢出时间从 2038 年延迟到了 2446 年\n\n### `inode.i_block` 内容（The Contents of inode.i_block）\n\n![](../res/fs-inode.png)\n\n在 inode 节点中 i_block[EXT4_N_BLOCKS=15] 域 一共 60 bytes,通常情况下用来记录文件块的索引信息。\n\n#### 符号连接（Symbolic Links）\n\n// TODO\n\n#### 直接/间接块寻址（Direct/Indirect Block Addressing）\n\n见上图\n\n#### Extent Tree\n\n// TODO\n\n#### 内联数据（Inline Data）\n\n// TODO\n\n### 目录实体（Directory Entries）\n\n在 ext4 文件系统中，目录中保存这文件名到 inode 号的映射。我们可以通过硬连接使不同的文件引用相同的 inode 号。读取一个文件的数据块前，会将其对应的目录的信息先加载到内存。目录和普通文件他们都是用 inode 节点来表示，但不同的是普通文件的 `i_block` 所指向的该文件对应的数据块，目录节点的 `i_block` 所指向的是保存该目录中条目信息的块。\n\n#### 线性目录（Linear (Classic) Directories）\n\n默认情况下，每一个目录将所包含的条目保存到几乎线性的数组中。因为目录条目不能跨越文件系统块，所以在每一块的最后可能都会有剩余的字节，所以它并不是一个严格的数组。准确的来说，一个目录是一系列的数据块，每一个数据块包含了一个保存目录条目的线性数组。\n\n![](../res/fs-lde.png)\n\n每个目录条目包含一个 32-bits 的 inode 节点号，一个 16-bits 的目录条目长度，一个 16-bits 的文件名长度，一个 `EXT4_NAME_LEN` 长度文件名 `char` 数组。\n\n![](../res/fs-lde1.png)\n\n因为文件名不能超过 255 bytes， 所以新的目录条目将 16-bits 的文件名长度缩减为 8-bits， 剩余的 8-bits 用来保存目录条目对应文件的文件类型。\n\n若超级块中的 `filetype` 标志为 0，使用第一个结构，若为 1，使用第二个结构。\n\n线性的结构会带来查找的效率问题，通常查找文件的操作会频繁执行，每次都用线性时间作这件事效率会比较低\n\n#### hash tree 目录\n\n\n## 参考\n\n1. [File system](https://en.wikipedia.org/wiki/File_system#Linux)\n1. [Ext4 Howto](https://ext4.wiki.kernel.org/index.php/Ext4_Howto)\n1. [Ext4 Disk Layout](https://ext4.wiki.kernel.org/index.php/Ext4_Disk_Layout#Overview)\n1. [Inode Structure in EXT4 filesystem](https://selvamvasu.wordpress.com/2014/08/01/inode-vs-ext4/)\n1. [理解inode](http://www.ruanyifeng.com/blog/2011/12/inode.html)\n1. [Linux/Unix 系统编程手册]()\n','操作系统',3,'2023-05-23 10:33:22'),(1661094256449736705,'科学上网之代理服务器配置','# 大致配置流程\n\n**使用 DigitalOcean 费用大概 $5 每月，想要划算一点的话可以邀请同学跟你一块（一个服务器可以多用户使用）**\n\n1. 在 [Digitalocean](https://www.digitalocean.com/) 注册账号，并创建 droplets\n    - 发行版建议使用 Ubuntu\n    - 服务器规格不同价格也不同，最低 $5/mo 。基本够用了。\n    - 数据中心建议选 **Singapore(新加坡)** （经过测试速度最快）\n    - 建议添加一个 SSH key（之后远程登录服务器不需要密码）\n\n1. 服务器端安装\n    1. 登录到服务器\n        - linux 使用 `ssh` 以 `root` 身份登录到服务器。\n            - `[rainstorm@debian ~]$ ssh root@128.199.79.22`. 因为配置了 SSH key 所以不需要密码。\n        - Windows 下可以使用 `Putty`\n        - 服务器 IP 可以在 droplets 的页面上看到\n    1. [服务器端安装](https://github.com/shadowsocks/shadowsocks/wiki/Shadowsocks-%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E)\n        - [通过配置文件配置](https://github.com/shadowsocks/shadowsocks/wiki/Configuration-via-Config-File)\n        - [配置多用户](https://github.com/shadowsocks/shadowsocks/wiki/Configure-Multiple-Users)\n1. 客户端安装\n    1. linux 上使用与服务器端相同的命令\n    1. [windows 版](https://github.com/shadowsocks/shadowsocks-windows/releases)\n        - 这个我没有用过，试着玩一玩吧。\n\n1. 安装浏览器插件 `autoproxy`\n    1. 添加一个 `proxy server`\n        - `shadowsocks 127.0.0.1 1080 socks5`\n    1. 添加 `proxy rule`\n        - `google.com`\n        - `ajax.googleapis.com`\n\n\n- 以上是关键步骤，忽略了很多细节，可以自己先摸索一下。\n','VPN',1009,'2023-05-24 03:38:27'),(1661095928550969345,'测试测试','巴拉巴拉巴拉','测试',1660690671299731457,'2023-05-24 03:45:06');
/*!40000 ALTER TABLE `article` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `article_reply`
--

DROP TABLE IF EXISTS `article_reply`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `article_reply` (
  `id` bigint NOT NULL COMMENT '回复ID',
  `goal_article_id` bigint DEFAULT NULL COMMENT '回复的目标文章ID，如果回复的是其他回复请保持NULL',
  `text` mediumtext NOT NULL COMMENT '回复的内容正文',
  `publisher_id` bigint NOT NULL COMMENT '回复者ID',
  `publish_time` datetime NOT NULL COMMENT '发布时间',
  PRIMARY KEY (`id`),
  KEY `article_reply_article_id_fk` (`goal_article_id`),
  KEY `article_reply_user_info_id_fk` (`publisher_id`),
  CONSTRAINT `article_reply_article_id_fk` FOREIGN KEY (`goal_article_id`) REFERENCES `article` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `article_reply_user_info_id_fk` FOREIGN KEY (`publisher_id`) REFERENCES `user_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='文章回复';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `article_reply`
--

LOCK TABLES `article_reply` WRITE;
/*!40000 ALTER TABLE `article_reply` DISABLE KEYS */;
INSERT INTO `article_reply` VALUES (1661093708950458370,1015,'感谢分享~',1009,'2023-05-24 03:36:16'),(1661093820640579585,1008,'真羡慕啊',1009,'2023-05-24 03:36:43'),(1661095972041707521,1661095928550969345,'哟',1660690671299731458,'2023-05-24 03:45:16');
/*!40000 ALTER TABLE `article_reply` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `global_data`
--

DROP TABLE IF EXISTS `global_data`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `global_data` (
  `name` varchar(256) NOT NULL COMMENT '值名称',
  `content` varchar(1024) NOT NULL COMMENT '值的内容',
  PRIMARY KEY (`name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='各种数值，相当于全局变量';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `global_data`
--

LOCK TABLES `global_data` WRITE;
/*!40000 ALTER TABLE `global_data` DISABLE KEYS */;
INSERT INTO `global_data` VALUES ('adminPassword','114514'),('backendHost','http://localhost:8080'),('host','http://localhost:5173');
/*!40000 ALTER TABLE `global_data` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `question_answer`
--

DROP TABLE IF EXISTS `question_answer`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `question_answer` (
  `id` bigint NOT NULL COMMENT '回答的ID',
  `question_id` bigint NOT NULL COMMENT '问题的ID',
  `text` mediumtext NOT NULL COMMENT '回答的正文',
  `order_number` int NOT NULL COMMENT '在一个问题中的序号，楼层号',
  `publisher_id` bigint NOT NULL COMMENT '发布回答用户的ID',
  `publish_time` datetime NOT NULL COMMENT '发布时间',
  PRIMARY KEY (`id`),
  KEY `question_answer_question_info_id_fk` (`question_id`),
  KEY `question_answer_user_info_id_fk` (`publisher_id`),
  CONSTRAINT `question_answer_question_info_id_fk` FOREIGN KEY (`question_id`) REFERENCES `question_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `question_answer_user_info_id_fk` FOREIGN KEY (`publisher_id`) REFERENCES `user_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='对问题的回答，包括一楼的问题详细内容';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `question_answer`
--

LOCK TABLES `question_answer` WRITE;
/*!40000 ALTER TABLE `question_answer` DISABLE KEYS */;
INSERT INTO `question_answer` VALUES (1660698651055386625,1660698650988277761,'chatgbp都回答不了我的问题了。求大佬解答\n\nvs2022编译的x86程序 在win2003平台 运行提示不是有效的 Win32 应用程序\n\n![](https://segmentfault.com/img/bVc70Y1)',0,1660690671299731457,'2023-05-23 01:26:27'),(1660698651055386626,1660698650988277761,'你这什么远古系统？',1,1,'2023-05-23 01:27:10'),(1660698976202027009,1660698650988277761,'自己回答一下，问题已经解决了，就是系统太老了😰',2,1660690671299731457,'2023-05-23 01:27:45'),(1660701887371964417,1660698650988277761,'你说得对我的**老伙计**',3,1660701545255223298,'2023-05-23 01:39:19'),(1660706097249435650,1660706097173938177,'随着生成式人工智能（Generative Artificial Intelligence）的流行，有部分思否社区用户开始使用ChatGPT辅助答题。我们非常重视这一现象，也随即发布了关于 ChatGPT 答题的对应措施。\n\n为了探索社区未来发展的更多可能性，非常想了解大家对这一现象的看法，由此进行「对社区用户使用 ChatGPT 的意见调查」问卷收集工作。\n\n每一份问卷反馈我们都会充分阅读分析，尽可能呈现出一份严谨、全面的调研报告。期待与大家共同讨论和思考 AI 浪潮之下的技术社区形态，让我一起作为先行者，探索未来更多可能吧！\n\n',0,1660690671299731458,'2023-05-23 01:56:03'),(1660706097249435651,1660706097173938178,'正文！',0,1660690671299731458,'2023-04-23 11:56:03'),(1660706097249435652,1660706097173938179,'我也是正文！',0,1660690671299731458,'2023-04-23 09:56:03'),(1660706097249435653,1660706097173938177,'人工智能是世界的主宰！',2,6,'2023-05-23 01:57:04'),(1660706097249435654,1660706097173938177,'人工智能是世界的主宰！',3,7,'2023-05-23 02:56:04'),(1660706097249435655,1660706097173938177,'好活，但是我觉得在这种社区还是只有**人类**回答为好。',4,8,'2023-05-24 12:02:05'),(1660706097249435656,1660706097173938177,'人工智能是世界的主宰！',5,4,'2023-05-25 04:00:03'),(1660706097249435657,1660706097173938177,'任天堂是世界的主宰！',6,1002,'2023-05-25 04:06:03'),(1660706097249435658,1660706097173938177,'上面的回答真的有好好回复问卷吗？',7,1003,'2023-05-25 04:10:03'),(1660706097249435659,1660706097173938177,'那么你呢？你们这些人一个个都都要被封号哦！',8,1004,'2023-05-25 05:00:03'),(1660706097249435660,1660706097173938177,'人工智能是世界的主宰！',1,5,'2023-05-23 01:56:04'),(1660706097249435661,1660706097173938180,'某个页面放置一段时间（几分钟），然后控制台（console',0,1007,'2023-05-21 02:06:09'),(1660706097249435662,1660706097173938180,'都卡的半天动不了了，再打performance快照、memory快照，估计浏览器页面都崩了。。\n这种建议看是那种卡：\n\n* 如果你鼠标放到页面按钮上，光标样式还是箭头，而没有变手指形状，说明css线程都给阻塞了，这种说明是cpu型卡顿。\n* 如果css线程没阻塞，只是反应很慢，说明是内存型卡顿，估计是内存泄露了\n看描述，应该是内存型卡顿。。内存泄露的话，你先打开性能监控器，看看谁哪块资源占用飙升。\n\n![](https://segmentfault.com/img/bVc7TiN)\n\n* dom节点\n  这个最好判断，控制台直接可以看是哪块元素创建多了，找到对应代码就行\n*  js事件监听器\n  事件绑定之后没正常解绑，重点排查addEventListener和removeEventListener,再就用getEventListeners API查下window和document对象上的事件绑定\n*  js堆大小\n  这个麻烦点，说明是变量没正确释放内存，都卡成这样了，打memory快照浏览器大概率崩，建议给页面相关的全局变量打下console\n  这个也有可能是setTimeout或者setInterval没释放，vue对象都是绑定在dom节点上的，假设根节点是id=\"app\", 你可以用$(\'#app\').__vue__.$destory()销毁整个vue实例，这时候页面没那么卡了，赶紧打performance快照，如果表示js的黄色线断是一段一段的，说明就是定时器的问题，沿着call tree向上找就行',1,1008,'2023-05-21 02:06:09'),(1660706097249435663,1660706097173938180,'用一下专门的抓包软件，确定下是不是后端接口的问题，之前我那同事在某个条件下出现死循环，和你这场景很类似，大概率出现前端页面卡死，只能关了页面再打开；确定后端无问题了，也可以看看前端是不是有可能存在死循环',2,1009,'2023-05-21 03:06:09'),(1660706097249435664,1660706097173938180,'通过控制台 Performance 分析一下',3,1005,'2023-05-21 04:06:09'),(1660706097249435665,1660706097173938180,'好吧，还是第一个回复最有意义',4,1005,'2023-05-21 05:06:09'),(1660706097249435666,1660706097173938180,'不懂呢，感觉是代码写错了',5,1004,'2023-05-21 06:09:09'),(1660706097249435667,1660706097173938181,'我想问的其实不是解决 params 参数会丢失的问题，而是想问为什么它就会丢失？而 query 就不会丢失呢？',0,1001,'2023-05-21 07:15:34'),(1660706097249435668,1660706097173938182,'es2023新增的toReversed（）方法可以用于vue项目吗？怎样判断es新增的方法能否使用？在安装babel插件的前提下，看官网谷歌浏览器好像只支持110版本以上',0,1002,'2023-05-24 12:15:34'),(1660706097249435669,1660706097173938183,'# 描述\n要求是，各个元素之间相距24px，换行后，下一行的元素和第一行的开头元素对齐，并且和上一行元素也是24px的间距。\n\n# 我的解决方案（有问题）\n给兄弟元素设置margin-left和top,结果换行后的元素不是从头开始的，第二个元素如果没换行也会有margintop。\n\n于是我就给每个元素设置了margin-right，兄弟元设置margin-bottom，结果第二个元直接换行的话，就触发不了margin-bottom，还是挨在了一起。\n\n如果给每个元素都设置margin-bottom，只有一个元素时，高度看着不正常。\n\n好无语。\n\n难道flex只能用于不换行吗？\n\n# 解决\n```css\n.container {\n  display: flex;\n  flex-wrap: wrap;\n  align-items: flex-start;\n  gap: 16px 16px;\n}\n```',0,1003,'2023-05-22 08:15:34'),(1660712374524493826,1660712374482550786,'```javascript\nlet data = [\n    { text: \"根目录\", id: 9521 },\n    { text: \"子目录一\", id: 880 },\n    { text: \"子目录二\", id: 196320 },\n]\n```\n传入：{ text: \"子目录一\", id: 880 }\n期望输出：\n```javascript\n[\n    { text: \"根目录\", id: 9521 },\n    { text: \"子目录一\", id: 880 },\n]\n```\n传入：{ text: \"根目录\", id: 9521 }\n期望输出：\n```javascript\n[\n    { text: \"根目录\", id: 9521 }\n]\n```',0,2,'2023-05-23 07:20:59'),(1660712802175729666,1660712802142175234,'父组件相关代码\n```html\n<el-dialog  v-if=\"dialogVisible\" :title=\"dialogTitle\" :width=\"`${dialogWidth}px`\"  :visible.sync=\"dialogVisible\" :close-on-click-modal=\"false\">\n            <component :is=\"dialogKey\" :ref=\"dialogKey\" :currentForm=\"dialogForm\"></component>\n            <div slot=\"footer\">\n                <el-button @click=\"handleDialogClose\">取 消</el-button>\n                <el-button type=\"primary\" @click=\"handleSubmit\">确 定</el-button>\n            </div>\n        </el-dialog>\njs\n\ndialogForm: {\n                splitTime: dayjs().format(\'YYYY-MM-DD HH:mm:ss\')\n            }\n```\n子组件\n```html\n<el-form :model=\"currentForm\" ref=\"currentForm\" :rules=\"rules\"  label-width=\"120px\">\n    <el-form-item label=\"预约分裂时间\" prop=\"splitTime\">\n        <el-date-picker\n      v-model=\"currentForm.splitTime\"\n      type=\"datetime\"\n      value-format=\'yyyy-MM-dd HH:mm:ss\'\n      format=\"yyyy-MM-dd HH:mm:ss\"\n      placeholder=\"请选择预约分裂时间\">\n    </el-date-picker>\n    </el-form-item>\n  </el-form>\n```\n复现步骤：\n\n* 第一次打开弹框： 时间选择器显示的是当前时间\n* 更改时间选择器的时间之后关闭弹框\n* 第二次打开弹框，显示时间是之前弹框里面时间选择的时间，而不是当前时间？',0,4,'2023-05-23 12:22:41'),(1661080583081603073,1660706097173938181,'你确定一下你路由配置中配置好了```props:true```？',1,1003,'2023-05-24 02:44:07'),(1661080972300431361,1661080972250099714,'```javascript\nconst a = {}\na.b = 1;\n// 这一行执行没有问题\n\n// 判断一下a是否为空\na && a.c = 1\n// 则会报错 SyntaxError: invalid assignment left-hand side\n// 大家可以试一下，为什么 && 导致了左侧赋值无效？\n\na?.c = 1 // 也会报错 SyntaxError: invalid assignment left-hand side\n// 这个怎么解释？\n```',0,1008,'2023-05-24 02:45:40'),(1661081485741961218,1661080972250099714,'搜一下 js运算符优先级 && 比 = 优先级高 ，实际为 (a && a.c) = 1',1,1660701545255223298,'2023-05-24 02:47:42'),(1661082451568537602,1661082451501428738,'As we know, C++23 support Standard Library Modules. Until May 2023, MSVC support it but we need add Standard Library Modules manually as Microsoft blog mentioned.\n\nBut how to use import std in CMake project? The MS blog doesn\'t mentioned it. And these files can\'t work.(The std.ifc file is obtained from microsoft blog tutorial:cl /std:c++latest /EHsc /nologo /W4 /MTd /c \"%VCToolsInstallDir%\\modules\\std.ixx\"(use in msvc x64 native console))\n\n**CMakeList.txt**\n```cmake\nCMAKE_MINIMUM_REQUIRED(VERSION 3.26)\n\nset(CMAKE_EXPERIMENTAL_CXX_MODULE_CMAKE_API \"2182bf5c-ef0d-489a-91da-49dbc3090d2a\")\nset(CMAKE_EXPERIMENTAL_CXX_MODULE_DYNDEP ON)\n\nset_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT ${CMAKE_PROJECT_NAME})\n\n\nset(CMAKE_CXX_STANDARD 23)\n\nproject(1-1)\n\nadd_executable(${CMAKE_PROJECT_NAME})\ntarget_sources(${CMAKE_PROJECT_NAME}\n    PUBLIC\n    FILE_SET all_my_modules TYPE CXX_MODULES FILES\n    main.cpp\n    std.ifc\n)\n```\n\n**main.cpp**\n```cpp\nimport std;\nusing namespace std;\n\nint main(){\n    cout<<\"Hello\\n\";\n}\n```\nAnd MSVC shows:\n```\n[build] main.cpp(1,11): error C2230: Could not find module \"std\" \n[build] main.cpp(5,5): error C2065: \"cout\" : Undeclared identifier \n```\nI can use copy %VCToolsInstallDir\\modules\\std.ixx to project folder and change std.ifc to std.ixx, but is there a more elegant way to achieve it to avoid building std module every time? I think it\'s because .ifc is not a source file,how to deal with it in CMake?',0,1660701545255223298,'2023-05-24 02:51:33'),(1661082940460806146,1661082451501428738,'With Visual Studio version 17.6.0 this became very straightforward. Simply set CMAKE_CXX_STANDARD to use C++23:\n```cmake\nset(CMAKE_CXX_STANDARD 23)\n\nadd_executable(demo)\ntarget_sources(demo\n  PRIVATE\n    demo.cpp\n)\n```\nThis will set the VS configuration property C/C++->Language->C++ Language Standard to /std:c++latest. Visual Studio 17.6 now also provides a property C/C++->Language->Build ISO C++23 Standard Library Modules which by default is set to Yes and will automatically build the standard library modules on /std:c++latest as part of your project build. So no special handling is required anymore.\n\nCMake is currently considering to provide an option for controlling this property.\n\nFor older versions of Visual Studio, you will have to compile the std named module yourself before importing it.\n\nSince CMake does not support importing pre-compiled modules at the moment, the easiest way to get things running is therefore to simply include the primary module interface for the standard library in your project.\n\nBe sure to first read this answer to understand the current prerequisites and limitations of the C++20 modules in CMake.\n\nCMakeLists.txt\n```cmake\nadd_executable(demo)\n\nfile(COPY\n  # you don\'t want to hardcode the path here in a real-world project,\n  # but you get the idea\n  \"C:/Program Files/Microsoft Visual Studio/2022/Community/VC/Tools/MSVC/14.36.32532/modules/std.ixx\"\n  DESTINATION\n  ${PROJECT_BINARY_DIR}/stdxx\n)\n\ntarget_sources(demo\n  PRIVATE\n  FILE_SET CXX_MODULES FILES\n  ${PROJECT_BINARY_DIR}/stdxx/std.ixx\n  PRIVATE\n  demo.cpp\n)\ndemo.cpp\n\nimport std;\n\nint main()\n{\n    std::cout << \"Hello World\\n\";\n}\n```\nCMake rightfully prevents you from including module sources outside of your source tree in the build. So we will copy the module interface file to our binary tree for building.\n\nAs usual, having the same primary module interface appear more than once in a program is not allowed. Structure your build accordingly so that you don\'t accidentally end up with std.ixx being compiled twice.',1,1660690671299731460,'2023-05-24 02:53:29'),(1661083246661775361,1661080972250099714,'&&的优先级大于赋值=\n所以a && a.c = 1先计算了a && a.c得到undefined\n然后在将1赋值给undefined这一步时报错\n\n',2,6,'2023-05-24 02:54:42'),(1661083273161388034,1661080972250099714,'补充\na?.c = 1是一样的问题\n当a上存在c属性时?.返回a.c的值\n当a上不存在c属性时?.返回undefined\n他们不是变量、对象属性或数组元素，不能进行赋值操作',3,6,'2023-05-24 02:54:48'),(1661084052425322497,1661084052391768066,'# 起因\n正在做视频上传功能，其中视频压制这方面使用了ffmpeg.wasm，就在前端做掉了。还需要截取视频的缩略图thumbnails。\n\n项目使用的播放器是DPlayer，DPlayer的文档在thumbnails这边是这样写的并提供了DPlayer-thumbnails。\n\n![](https://segmentfault.com/img/bVc714a)\n\n通过这个工具可以得到如下的雪碧图。\n\n![](https://segmentfault.com/img/bVc714c)\n\n阅读了下DPlayer-thumbnails的代码，也是通过ffmpeg。然后又测试了一下，它是无论是什么长度的视频都取100张的缩略图，然后制成雪碧图。\n（一开始我以为是每秒截一张，这个方案很好，在进度条上显示缩略图时就计算百分比就好了。）\n\n既然这样，是否可以一样使用ffmpeg.wasm在前端进行同样的操作。得出100张缩略图，可以供用户选择视频封面，并且制成雪碧图上传它。\n\n# 经过\n先用ffmpeg测试一下\n```\n//既然是在视频总长中截取100张图片，那么就是视频总时长/100\n//我的这个测试视频是160秒，至于读取不同视频的时长那后面再说吧。\nffmpeg -i ../../test.mp4 -vf fps=1/(160/100) ../../thumbnail/thumbnail%d.png\n```\n能得出以下内容\n\n![](https://segmentfault.com/img/bVc715m)\n\n好啊，很好啊。但是要怎么把他们取出来呢。\n\nffmpeg.wasm的文档是这样的\n```\n//Browser\n<body>\n  <video id=\"player\" controls></video>\n  <input type=\"file\" id=\"uploader\">\n  <script src=\"ffmpeg.min.js\"></script>\n  <script>\n    const { createFFmpeg, fetchFile } = FFmpeg;\n    const ffmpeg = createFFmpeg({ log: true });\n    const transcode = async ({ target: { files } }) => {\n      const { name } = files[0];\n      await ffmpeg.load();\n      ffmpeg.FS(\'writeFile\', name, await fetchFile(files[0]));\n      await ffmpeg.run(\'-i\', name,  \'output.mp4\');\n      const data = ffmpeg.FS(\'readFile\', \'output.mp4\');\n      const video = document.getElementById(\'player\');\n      video.src = URL.createObjectURL(new Blob([data.buffer], { type: \'video/mp4\' }));\n    }\n    document\n      .getElementById(\'uploader\').addEventListener(\'change\', transcode);\n  </script>\n</body>\n\n//Node.JS\nconst fs = require(\'fs\');\nconst { createFFmpeg, fetchFile } = require(\'@ffmpeg/ffmpeg\');\n\nconst ffmpeg = createFFmpeg({ log: true });\n\n(async () => {\n  await ffmpeg.load();\n  ffmpeg.FS(\'writeFile\', \'test.avi\', await fetchFile(\'./test.avi\'));\n  await ffmpeg.run(\'-i\', \'test.avi\', \'test.mp4\');\n  await fs.promises.writeFile(\'./test.mp4\', ffmpeg.FS(\'readFile\', \'test.mp4\'));\n  process.exit(0);\n})();\n```\n单个文件是可以取出来的（比如只压制一个视频），但像这里生成了很多图片，是多个文件该怎么取出来呢？\n\n# 问题\n截取缩略图这块我是这样写的\n\nvar in_name = \"upload.mp4\";\nvar out_name = \"thumbnail%d.png\";\n\n(async () => {\n    await ffmpeg.load();\n    ffmpeg.FS(\'writeFile\', in_name, await fetchFile(original_video_file));\n    await ffmpeg.run(\'-i\', in_name, \'-vf\' , \'fps=1/(160/100)\' , out_name);\n    var new_file = ffmpeg.FS(\'readFile\', out_name);\n    var thumbnail = new Blob([new_file.buffer], { type: \'image/png\' });\n    console.log(thumbnail);\n})();\n报了以下错误\n\n![](https://segmentfault.com/img/bVc715N)\n\n想了想原因，应该就是这个写法不能读取多个文件的原因，报错也在ffmpeg.FS这里看看下文档吧。可惜没有给出这样的写法。\n\n![](https://segmentfault.com/img/bVc715V)\n\n然后又去稍稍的了解了下emscripten（毕竟文档里有这个链接），可惜头都看的大了都没找着。\nhttps://emscripten.org/docs/api_reference/Filesystem-API.html\n\n各位大神是否有办法呢！如果网络上有这方面的讲解或者这个问题的其他解法，请麻烦告诉我也可以节省时间重复回答。辛苦了！',0,6,'2023-05-24 02:57:54'),(1661084356994707457,1661084356952764418,'```\n<div class=\"content\" :class=\"{ active:isCollapse }\">\n      <MyHeader @changeMenu=\"changeMenu\" :isCollapse=\"!isCollapse\"></MyHeader>\ndata () {\n    return {\n      isCollapse: false\n    }\n  },\n  methods: {\n    changeMenu () {\n      this.isCollapse = !this.isCollapse\n    }\n  }\n .content {\n    padding-left: 200px;\n    .active {\n    padding-left: 65px;\n  }\n  }\n```\n控制台：\n```\n<style>\n#app .content {\n    padding-left: 200px;\n}\n```\n触发了也没改变内边距\n\n解决了，写外边。不过为什么里面不生效\n```css\n .content {\n    padding-left: 200px;\n  }\n.active {\n    padding-left: 65px;\n  }\n```',0,6,'2023-05-24 02:59:07'),(1661084628508782594,1661084356952764418,'不要用后代选择器的写法。\n\n要写成同级。\n\n.content .active 当 .active 是 .content 后代元素时生效。\n\n.content.active 当 .content 与 .active 在同一个元素上时生效。\n\n同级的 scss写法：\n```\n.content {\n  padding-left: 200px;\n\n  &.active {\n    padding-left: 65px;\n  }\n}\n```\n转化为 css：\n```\n.content { padding-left: 200px; }\n.content.active { padding-left: 65px; }\n```\n这是后代选择器的写法：\n```\n.content {\n  padding-left: 200px;\n\n  .active {\n    padding-left: 65px;\n  }\n}\n```\n转换成 css，两者之间是后代选择器的关系。\n```\n.content { padding-left: 200px; }\n.content .active { padding-left: 65px; }\n```',1,5,'2023-05-24 03:00:12'),(1661084769231876098,1661084769194127362,'在docker-compose中，可以通过下面方式限定容器使用的资源，比如：\n```\n    deploy:\n      resources:\n         limits:\n            cpus: \"2.00\"\n            memory: 5G\n```\n现在的问题是，在网上搜索到的资料，关于 limits.cpus 参数的含义，众说纷纭，有说是cpu核心数，有说是cpu使用百分比。\n\n那么对于 8核心的云服务器，如果想要限制容器最多使用到 所有cpu资源的 80%，那么应该怎么写呢？\n写成：cpus: \"0.80\" 还是 cpus: \"6.40\" ?',0,5,'2023-05-24 03:00:45'),(1661085119066189826,1661085119024246785,'python 代码：地址：\n```python\nimport logging\nimport io\nfrom hashlib import sha1\nfrom struct import pack, unpack\n\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes\n\nlogger = logging.getLogger(__name__)\nlogger.addHandler(logging.NullHandler())\n.............................\n..........\n@staticmethod\ndef makekey_from_password(password, algId, algIdHash, providerType, keySize, saltSize, salt):\n    r\"\"\"\n    Generate intermediate key from given password.\n\n        >>> password = \'Password1234_\'\n        >>> algId = 0x660e\n        >>> algIdHash = 0x8004\n        >>> providerType = 0x18\n        >>> keySize = 128\n        >>> saltSize = 16\n        >>> salt = b\'\\xe8\\x82fI\\x0c[\\xd1\\xee\\xbd+C\\x94\\xe3\\xf80\\xef\'\n        >>> expected = b\'@\\xb1:q\\xf9\\x0b\\x96n7T\\x08\\xf2\\xd1\\x81\\xa1\\xaa\'\n        >>> ECMA376Standard.makekey_from_password(password, algId, algIdHash, providerType, keySize, saltSize, salt) == expected\n        True\n    \"\"\"\n    logger.debug([password, hex(algId), hex(algIdHash), hex(providerType), keySize, saltSize, salt])\n    xor_bytes = lambda a, b: bytearray([p ^ q for p, q in zip(bytearray(a), bytearray(b))])  # bytearray() for Python 2 compat.\n\n    # https://msdn.microsoft.com/en-us/library/dd925430(v=office.12).aspx\n    ITER_COUNT = 50000\n\n    password = password.encode(\"UTF-16LE\")\n    h = sha1(salt + password).digest()\n    for i in range(ITER_COUNT):\n        ibytes = pack(\"<I\", i)\n        h = sha1(ibytes + h).digest()\n    block = 0\n    blockbytes = pack(\"<I\", block)\n    hfinal = sha1(h + blockbytes).digest()\n    cbRequiredKeyLength = keySize // 8\n    cbHash = sha1().digest_size\n    buf1 = b\"\\x36\" * 64\n    buf1 = xor_bytes(hfinal, buf1[:cbHash]) + buf1[cbHash:]\n    x1 = sha1(buf1).digest()\n    buf2 = b\"\\x5c\" * 64\n    buf2 = xor_bytes(hfinal, buf2[:cbHash]) + buf2[cbHash:]\n    x2 = sha1(buf2).digest()  # In spec but unused\n    x3 = x1 + x2\n    keyDerived = x3[:cbRequiredKeyLength]\n    logger.debug(keyDerived)\n    return keyDerived\n```\nnode.js 代码：\n```javascript\nconst crypto = require(\'crypto\');\n\nfunction makekey_from_password (password, algId, algIdHash, providerType, keySize, saltSize, salt) {\n  const ITER_COUNT = 50000;\n  const cbRequiredKeyLength = keySize / 8;\n\n  const passwordBuf = Buffer.from(password, \'utf16le\');\n  //   let saltedPasswordHash = crypto.createHash(\'sha1\').update(salt).update(passwordBuf).digest();\n  let saltedPasswordHash = crypto.createHash(\'sha1\').update(Buffer.concat([salt, passwordBuf])).digest();\n\n  for (let i = 0; i < ITER_COUNT; i++) {\n    const ibytes = Buffer.alloc(4);\n    ibytes.writeUInt32LE(i, 0);\n    saltedPasswordHash = crypto.createHash(\'sha1\').update(Buffer.concat([ibytes, saltedPasswordHash])).digest();\n    // saltedPasswordHash = crypto.createHash(\'sha1\').update(ibytes).update(saltedPasswordHash).digest();\n  }\n\n  const block = Buffer.alloc(4);\n  // const hfinal = crypto.createHash(\'sha1\').update(saltedPasswordHash).update(block).digest();\n  const hfinal = crypto.createHash(\'sha1\').update(Buffer.concat([saltedPasswordHash, block])).digest();\n\n  const cbHash = 20;\n\n  let buf1 = Buffer.alloc(64, 0x36);\n  buf1 = Buffer.concat([xor_bytes(hfinal, buf1.slice(0, cbHash)), buf1.slice(cbHash)]);\n  const x1 = crypto.createHash(\'sha1\').update(buf1).digest();\n\n  let buf2 = Buffer.alloc(64, 0x5C);\n  buf2 = Buffer.concat([xor_bytes(hfinal, buf2.slice(0, cbHash)), buf2.slice(cbHash)]);\n  const x2 = crypto.createHash(\'sha1\').update(buf2).digest();\n  const x3 = Buffer.concat([x1, x2]);\n  const keyDerived = x3.slice(0, cbRequiredKeyLength);\n\n  return keyDerived;\n}\n\nfunction xor_bytes (a, b) {\n  const result = [];\n  for (let i = 0; i < a.length; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return Buffer.from(result);\n}\n\n// 测试\nconst password = \'Password1234_\';\nconst algId = 0x660e;\nconst algIdHash = 0x8004;\nconst providerType = 0x18;\nconst keySize = 128;\nconst saltSize = 16;\nconst salt = Buffer.from(\'e88266490c5bd1eebd2b43c94e3f3830ef\', \'hex\');\nconst expected = Buffer.from(\'40b13a71f90b966e375408f2d181a1aa\', \'hex\');\nconst key = makekey_from_password(password, algId, algIdHash, providerType, keySize, saltSize, salt);\nconsole.log(\'key\', key, key.toString(\'hex\'));\nconsole.log(makekey_from_password(password, algId, algIdHash, providerType, keySize, saltSize, salt).equals(expected));\n```\npython 输入输出：\n```\n>>> salt = b\'\\xe8\\x82fI\\x0c[\\xd1\\xee\\xbd+C\\x94\\xe3\\xf80\\xef\'\n>>> expected = b\'@\\xb1:q\\xf9\\x0b\\x96n7T\\x08\\xf2\\xd1\\x81\\xa1\\xaa\'\n（40b13a71f90b966e375408f2d181a1aa）\n```\nnode.js 输入输出：\n```\nBuffer.from(\'e88266490c5bd1eebd2b43c94e3f3830ef\', \'hex\');\n```\n实际输出是：6c1cc43d0fbe4e7d987f7ac68968111d\n请大佬指教为什么我参考 python 代码写的 node.js 代码最后输出的内容是不一样的？',0,5,'2023-05-23 03:02:09'),(1661085527918555138,1661085119024246785,'代码我没看，不过你这个测试用例两边儿也不一致啊？\n\n你 python 里：\n```\nsalt = b\'\\xe8\\x82fI\\x0c[\\xd1\\xee\\xbd+C\\x94\\xe3\\xf80\\xef\'\n```\n对应十六进制是：\n\ne88266490c5bd1eebd2b4394e3f830ef\n跟你 JS 里的也不一样啊？\n\ne88266490c5bd1eebd2b4394e3f830ef    -- python\ne88266490c5bd1eebd2b43c94e3f3830ef  -- node.js',1,1003,'2023-05-24 03:03:46'),(1661085620574924801,1661084769194127362,'是数量，不是百分比。\n\n看官方文档：\n\nREF: https://docs.docker.com/compose/compose-file/deploy/#resources\ncpus configures a limit or reservation for how much of the available CPU resources (as number of cores) a container can use.\n注意加粗的部分，“以内核数量为单位”。\n\nP.S.1 说是百分比的倒也不算错，只是可能你理解错意思了。比如我有 4 个核、然后 cpus 设成 2.0，那么不是说限制成了最多只有 2 个核在工作、另 2 个核不工作，而是说这 4 个核都可能工作、但加一起的利用率是 200%。所以你看它的值是个小数，要不然核心数怎么也不可能出现“半个”这种说法，只能是“50% 利用率”。\n\nP.S.2 你要真的是想设置“最多只有几个核工作”，那也有。2.2 之后有了 cpu_count 这个参数，它的值是一个整数。',1,1003,'2023-05-24 03:04:08'),(1661086188131364866,1661086188097810433,'比如我要需要在低于Chrome浏览器内核的某个版本时，才使用这个类选择器; 有没有可能直接在css文件上标记什么版本有效',0,1004,'2023-05-24 03:06:23'),(1661086454310285313,1661086454268342274,'情况是这样，打算用this.$message提示信息，然后里面放上自己自定义的组件private-table，然后组件里用到了vuex，也就是this.$store里的数据，但是是undefined,请问出现这个问题的原因是啥，怎么解决？\n```javascript\n          const h = this.$createElement          \n          this.$message({\n            message: h(\'div\', {}, [\n              h(\'div\', {}, [\'导入失败，Excel中存在重复信息：\']),\n              h(\'private-table\', {\n                props: {\n                  table: {},\n                  columns: [],\n                  data: res.result,\n                  \'i-header-cell-style\': \'height:36px;padding:0px;background-color:#FAFAFA;color:#333333;\'\n                }\n              })\n            ]),\n            type: \'error\'\n          })\n```',0,1004,'2023-05-24 03:07:27'),(1661086843722051586,1661086454268342274,'vue2里，element-ui的message是通过Vue.extend动态创建的，是一个独立的vue实例，不共享router、store这些项目初始实例才有的属性\n\n如果都是用this.$message的形式调用的话，可以重写这个方法，在其通过Vue.extend创建message组件时，把项目初始实例传入parent选项中\n\n或者改造private-table，把用到的router、store都是用import的方式手动引入\n\n方案1重新初始化vue-router：\n```javascript\n// 引入项目中的vue-router实例\nimport router from \'@/router\'\n\nconst h = this.$createElement\nconst Component = {\n  name: \'Component\',\n  router,\n  mounted() {\n    this.$router.push(\'/home\')\n  },\n  render(h) {\n    return h(\'div\', [\'我是Component\'])\n  },\n}\nthis.$message({\n  message: h(Component)\n})\n```\n方案2手动控制VNode:\n```javascript\nimport Vue from \'vue\'\n\n// 这是项目初始vue实例\nwindow.__VUE__ = new Vue({\n  el: \'#app\',\n  router,\n  store,\n  render: h => h(App)\n})\n\nconst Component = Vue.extend({\n  name: \'Component\',\n  parent: window.__VUE__,\n  mounted() {\n    this.$router.push(\'/home\')\n  },\n  render(h) {\n    return h(\'div\', [\'我是Component\'])\n  },\n})\nconst instance = new Component()\ninstance.$mount()\nthis.$message({\n  message: instance._vnode\n})\n```\n方案3重写this.$message：\n不过看了下element-ui源码，他这个重写比较麻烦，就不写了',1,1009,'2023-05-24 03:09:00'),(1661087005840289793,1661087005806735362,'在开发这模式下，不勾选color这个属性，怎么设置？\n因为不勾选color后发现就是自己需要的样式，但是写在代码中又不知道设置哪个属性\n![](https://segmentfault.com/img/bVc7WiR)',0,1009,'2023-05-24 03:09:38'),(1661087206575484929,1661087206546124802,'想实现先请求接口然后再生成路由改如何做到？(下面代码试了几次都不行)\n```javascript\nimport { useState, useEffect } from \'react\'\nimport reactLogo from \'./assets/react.svg\'\nimport viteLogo from \'/vite.svg\'\nimport \'./App.css\'\nimport { Button } from \'antd-mobile\'\nimport axios from \'axios\'\nimport {\n    createBrowserRouter,\n    RouterProvider,\n} from \"react-router-dom\";\nimport {Router as RemixRouter} from \"@remix-run/router/dist/router\";\n\n function test_request() {\n    return axios.get(\'http://localhost:8888/api/\')\n        .then(function (response) {\n            return response.data.Response\n        })\n}\ninterface Route { path: string, element?: string }\n\nfunction App() {\n  const [route, setRoute] = useState<RemixRouter>()\n    // createBrowserRouter\n    const router = test_request().then((data) => {\n        // let c = data.map((v : Route) => {\n        //     return { path: v.path, element: <div>2222222222222</div> }\n        // })\n        // setRoute(createBrowserRouter(c))\n        return createBrowserRouter(data)\n    })\n\n    // useEffect(() => {\n    //     test_request().then((data) => {\n    //         let c = data.map((v : Route) => {\n    //             return { path: v.path, element: <div>2222222222222</div> }\n    //         })\n    //         // setRoute(createBrowserRouter(c))\n    //         return c\n    //     })\n    //\n    //\n    // },[])\n\n  return (\n    <div className=\"App\">\n      <div>\n          <img src={viteLogo} className=\"logo\" alt=\"Vite logo\" />\n      </div>\n        <RouterProvider router={router} />\n    </div>\n  )\n}\n\nexport default App\n```',0,1009,'2023-05-24 03:10:26'),(1661096080409931778,1660698650988277761,'嗨嗨嗨',4,1660690671299731458,'2023-05-24 03:45:42');
/*!40000 ALTER TABLE `question_answer` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `question_info`
--

DROP TABLE IF EXISTS `question_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `question_info` (
  `id` bigint NOT NULL COMMENT '问题的ID',
  `title` varchar(256) NOT NULL COMMENT '问题的标题、概述',
  `publisher_id` bigint NOT NULL COMMENT '发布者用户的ID',
  `publish_time` datetime NOT NULL COMMENT '发布的时间',
  `category` varchar(64) NOT NULL COMMENT '问题的分类',
  PRIMARY KEY (`id`),
  KEY `question_header_user_info_id_fk` (`publisher_id`),
  CONSTRAINT `question_header_user_info_id_fk` FOREIGN KEY (`publisher_id`) REFERENCES `user_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='问题的信息';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `question_info`
--

LOCK TABLES `question_info` WRITE;
/*!40000 ALTER TABLE `question_info` DISABLE KEYS */;
INSERT INTO `question_info` VALUES (1660698650988277761,'vs2022编译的x86程序 运行提示不是有效的 Win32 应用程序？',1660690671299731457,'2023-05-23 01:26:27','C++'),(1660706097173938177,'对社区用户使用 ChatGPT 的意见调查｜问卷收集🍦',1660690671299731458,'2023-04-23 10:56:03','社区'),(1660706097173938178,'测试问题2~',1660690671299731458,'2023-04-23 11:56:03','测试'),(1660706097173938179,'测试问题1~',1660690671299731458,'2023-04-23 09:56:03','测试'),(1660706097173938180,'vue项目中，页面过一段时间就会卡死，但不是每次都出现，怎么排查问题呢？',1007,'2023-05-21 02:06:09','Vue'),(1660706097173938181,'前端路由中为什么 params 参数刷新会丢失，而 query 就不会？',1001,'2023-05-21 07:15:34','Vue'),(1660706097173938182,'es2023新增的toReversed（）方法可以用于vue项目吗？',1002,'2023-05-24 12:15:34','Vue'),(1660706097173938183,'flex布局如何让换行后元素从头开始且和上一行有一定间距？',1003,'2023-05-22 08:15:34','CSS'),(1660712374482550786,'js 如果删除数组某个元素的右侧所有元素？',2,'2023-05-23 07:20:59','JavaScript'),(1660712802142175234,'为什么没有显示当前时间？',4,'2023-05-23 12:22:41','JavaScript'),(1661080972250099714,'感觉是一个引擎问题，这个JS报错怎么解释？',1008,'2023-05-24 02:45:40','JavaScript'),(1661082451501428738,'How to use CMake to build a C++23 standard library module(import std)?',1660701545255223298,'2023-05-24 02:51:33','C++'),(1661084052391768066,'ffmpeg.wasm 以图片组输出时，如何提取这些文件？',6,'2023-05-24 02:57:54','wasm'),(1661084356952764418,'给标签添加了动态样式，只要触发某个事件就会传入布尔值，实现样式改变？',6,'2023-05-24 02:59:07','前端'),(1661084769194127362,'docker-compose中cpu资源限制究竟是百分比还是核心数？',5,'2023-05-24 03:00:45','Docker'),(1661085119024246785,'为什么这两个算法最后输出的值不一样，一个node.js写的，一个python写的？',5,'2023-05-23 03:02:09','编程语言'),(1661086188097810433,'CSS选择器怎么通过判断当前浏览器内核版本号生效？',1004,'2023-05-24 03:06:23','CSS'),(1661086454268342274,'vue2项目this.$createElement创建的自定义组件里访问不了vuex，怎么解决？',1004,'2023-05-24 03:07:27','Vue'),(1661087005806735362,'F12下不勾选的css属性怎么设置？',1009,'2023-05-24 03:09:38','CSS'),(1661087206546124802,'reactrouter 有没有办法实现动态路由？',1009,'2023-05-24 03:10:26','Vue');
/*!40000 ALTER TABLE `question_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `report`
--

DROP TABLE IF EXISTS `report`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `report` (
  `id` bigint NOT NULL COMMENT '举报记录ID',
  `goal_user_id` bigint DEFAULT NULL COMMENT '被举报的用户的ID',
  `goal_article_id` bigint DEFAULT NULL COMMENT '被举报的文章ID',
  `goal_article_reply_id` bigint DEFAULT NULL COMMENT '被举报的文章回复ID',
  `goal_question_id` bigint DEFAULT NULL COMMENT '被举报的问题ID',
  `goal_question_answer_id` bigint DEFAULT NULL COMMENT '被举报的回答ID',
  `time` datetime NOT NULL COMMENT '举报时间',
  `comment` text NOT NULL COMMENT '举报附加信息',
  `is_processed` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否已经处理',
  `reporter_id` bigint NOT NULL COMMENT '举报者的用户ID',
  PRIMARY KEY (`id`),
  KEY `report_article_id_fk` (`goal_article_id`),
  KEY `report_article_reply_id_fk` (`goal_article_reply_id`),
  KEY `report_question_answer_id_fk` (`goal_question_answer_id`),
  KEY `report_question_info_id_fk` (`goal_question_id`),
  KEY `report_user_info_id_fk` (`reporter_id`),
  KEY `report_user_info_id_fk2` (`goal_user_id`),
  CONSTRAINT `report_article_id_fk` FOREIGN KEY (`goal_article_id`) REFERENCES `article` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `report_article_reply_id_fk` FOREIGN KEY (`goal_article_reply_id`) REFERENCES `article_reply` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `report_question_answer_id_fk` FOREIGN KEY (`goal_question_answer_id`) REFERENCES `question_answer` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `report_question_info_id_fk` FOREIGN KEY (`goal_question_id`) REFERENCES `question_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `report_user_info_id_fk` FOREIGN KEY (`reporter_id`) REFERENCES `user_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `report_user_info_id_fk2` FOREIGN KEY (`goal_user_id`) REFERENCES `user_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户举报';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `report`
--

LOCK TABLES `report` WRITE;
/*!40000 ALTER TABLE `report` DISABLE KEYS */;
/*!40000 ALTER TABLE `report` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_authentication`
--

DROP TABLE IF EXISTS `user_authentication`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user_authentication` (
  `id` bigint NOT NULL COMMENT '用户id',
  `email` varchar(64) NOT NULL COMMENT '用户注册时的邮箱',
  `password` varchar(64) NOT NULL COMMENT '用户登录密码',
  PRIMARY KEY (`id`),
  CONSTRAINT `user_authentication_user_info_id_fk` FOREIGN KEY (`id`) REFERENCES `user_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户登录关键信息';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_authentication`
--

LOCK TABLES `user_authentication` WRITE;
/*!40000 ALTER TABLE `user_authentication` DISABLE KEYS */;
INSERT INTO `user_authentication` VALUES (1,'test@fake.cn','1145141919pwd'),(2,'test2@fake.cn','1145141919pwd2'),(3,'test3@fake.cn','1145141919pwd3'),(4,'test4@fake.cn','4pwd1145141'),(5,'test5@fake.cn','adhfhwioas'),(6,'test6@fake.cn','aaaaaaaaaaa'),(7,'test7@fake.cn','helloiampwd'),(8,'test8@fake.cn','1145141919810893'),(1001,'test1001@fake.cn','12345678'),(1002,'test1002@fake.cn','12345678'),(1003,'test1003@fake.cn','12345678'),(1004,'test1004@fake.cn','12345678'),(1005,'test1005@fake.cn','12345678'),(1006,'test1006@fake.cn','12345678'),(1007,'test1007@fake.cn','12345678'),(1008,'test1008@fake.cn','12345678'),(1009,'test1009@fake.cn','12345678'),(1660690671299731457,'sodacooky@foxmail.com','1145141919'),(1660690671299731458,'hibin_org@qq.com','pwdpwdpwd'),(1660690671299731459,'523379653@qq.com','asdasdasd'),(1660690671299731460,'3022657759@qq.com','sodacookyismyhusband'),(1660701545255223298,'13250028980@163.com','114514aaa');
/*!40000 ALTER TABLE `user_authentication` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_info`
--

DROP TABLE IF EXISTS `user_info`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user_info` (
  `id` bigint NOT NULL COMMENT '用户的ID',
  `nickname` varchar(64) NOT NULL COMMENT '昵称，要求系统中唯一',
  `description` varchar(256) NOT NULL DEFAULT '无' COMMENT '简短的自我介绍',
  `avatar` varchar(256) NOT NULL DEFAULT 'default' COMMENT '头像的文件名称',
  `register_time` datetime NOT NULL COMMENT '注册时间',
  `is_banned` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否已经被封禁',
  PRIMARY KEY (`id`),
  UNIQUE KEY `user_info_pk2` (`nickname`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户基本信息表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_info`
--

LOCK TABLES `user_info` WRITE;
/*!40000 ALTER TABLE `user_info` DISABLE KEYS */;
INSERT INTO `user_info` VALUES (1,'测试用户','工具人','default','2023-05-23 00:33:06',0),(2,'TestUser','工具人2','test5','2023-05-23 00:33:07',0),(3,'111TestingUser111','Toolman3','test6','2023-05-23 00:33:08',1),(4,'Test用户','ToolMan4','test1','2023-05-23 00:33:05',0),(5,'测试User','工具Man5','test2','2023-05-23 00:33:04',0),(6,'Tes_FrankMk-2','i am a tool man for testing, really. i am created by sodacooky by handmade.','test3','2023-05-23 00:33:11',0),(7,'我是一个用户昵称非常长的测试用户','工具人','test4','2023-05-23 00:33:16',0),(8,'我就叫UserInfo','工具人','test7','2023-05-23 00:13:06',0),(1001,'陟上晴明','你必坚固，无所惧怕。\n\n某不知名🥬鸡切图仔，主要技术栈为 Vue 全家桶，React 我是很想用但是真没环境啊 🤣\n职业生涯早期大部分时间钻研在 CSS 上面，有相关的问题很乐于帮你解答，那种脑洞大开的感觉很有趣。\n得空会偶尔更新一下个人博客分享最近踩了坑的内容✌ Peace.','58ad2a19c97540ee81d624194fc7d1b9','2023-04-23 00:46:34',0),(1002,'云香水识','诚招前端：经验不限、技能全面、欢迎来搞。','802f0b0c8fe240c9827dddc156c277a2','2023-03-23 00:48:13',0),(1003,'hfhan','砥砺前行','0d442f2f3c3d49a6b3dd75d27e04de53\r','2023-02-23 00:49:50',0),(1004,'一般路过山女','纯路人','default','2023-05-12 01:15:53',0),(1005,'小明','成功抢注“小明”昵称，我是不是很炫酷！','default','2023-03-24 01:16:28',0),(1006,'小黑子','苏珊','test9','2023-03-15 11:17:03',1),(1007,'路人甲','不会前端的程序员不是好的后端程序员','test10','2023-04-29 20:20:33',0),(1008,'Cookiezi','I am noob, really.','default','2023-05-02 15:21:11',0),(1009,'Shigetora','Cookiezi is fake!','test11','2023-05-24 13:21:51',0),(1660690671299731457,'Sodacooky','只有我的自我介绍是有灵魂的、自己手动在网页里输入的！','9ba2e6f5-9585-422b-8142-ba337f41ea21','2023-05-23 00:54:45',0),(1660690671299731458,'NPE官方','你猜我是不是真官方','test8','2023-05-21 01:12:30',0),(1660690671299731459,'SDCKY','SubAccount~','default','2023-05-23 01:23:30',0),(1660690671299731460,'Xiple','无','default','2023-05-07 01:23:47',0),(1660701545255223298,'Sodacooky2','无','121a119f-195e-4b04-a359-cce0a95d9301','2023-05-23 01:37:57',0);
/*!40000 ALTER TABLE `user_info` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_notice`
--

DROP TABLE IF EXISTS `user_notice`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user_notice` (
  `id` bigint NOT NULL COMMENT '消息id',
  `goal_user_id` bigint NOT NULL COMMENT '接收消息的用户的ID',
  `type` varchar(64) DEFAULT NULL COMMENT '消息的类型',
  `title` varchar(64) NOT NULL COMMENT '消息标题',
  `text` mediumtext NOT NULL COMMENT '正文',
  `time` datetime NOT NULL COMMENT '通知时间',
  `is_read` tinyint(1) NOT NULL COMMENT '是否已读消息',
  `supplement` varchar(256) DEFAULT NULL COMMENT '附带的内容，可能是要跳转到的ID',
  PRIMARY KEY (`id`),
  KEY `user_notice_user_info_id_fk` (`goal_user_id`),
  CONSTRAINT `user_notice_user_info_id_fk` FOREIGN KEY (`goal_user_id`) REFERENCES `user_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户收到的通知';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_notice`
--

LOCK TABLES `user_notice` WRITE;
/*!40000 ALTER TABLE `user_notice` DISABLE KEYS */;
INSERT INTO `user_notice` VALUES (1660701620631060482,1660701545255223298,'system','欢迎来到NullPointerException~','社区将因你的到来而改变吗？拭目以待吧！','2023-05-23 01:38:15',0,NULL),(1661093709051121666,6,'article_reply','文章 JSR107中文版（非官方） 收到来自 Shigetora 的回复','感谢分享~','2023-05-24 03:36:17',0,'1015'),(1661093820695105537,1007,'article_reply','文章 阿里二面准备(Java 研发) 收到来自 Shigetora 的回复','真羡慕啊','2023-05-24 03:36:43',0,'1008'),(1661095972083650561,1660690671299731457,'article_reply','文章 测试测试 收到来自 NPE官方 的回复','哟','2023-05-24 03:45:16',0,'1661095928550969345');
/*!40000 ALTER TABLE `user_notice` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_question_subscription`
--

DROP TABLE IF EXISTS `user_question_subscription`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user_question_subscription` (
  `id` bigint NOT NULL COMMENT '订阅ID',
  `user_id` bigint NOT NULL COMMENT '订阅人ID',
  `question_id` bigint NOT NULL COMMENT '所订阅的问题ID',
  `time` datetime NOT NULL COMMENT '订阅时间',
  PRIMARY KEY (`id`),
  KEY `user_question_subscription_user_info_id_fk` (`user_id`),
  KEY `user_question_subscription_question_info_id_fk` (`question_id`),
  CONSTRAINT `user_question_subscription_question_info_id_fk` FOREIGN KEY (`question_id`) REFERENCES `question_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE,
  CONSTRAINT `user_question_subscription_user_info_id_fk` FOREIGN KEY (`user_id`) REFERENCES `user_info` (`id`) ON DELETE CASCADE ON UPDATE CASCADE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci COMMENT='用户关注的问题';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_question_subscription`
--

LOCK TABLES `user_question_subscription` WRITE;
/*!40000 ALTER TABLE `user_question_subscription` DISABLE KEYS */;
INSERT INTO `user_question_subscription` VALUES (1661086050738548737,1004,1660706097173938180,'2023-05-24 03:05:51'),(1661086475122421762,1004,1661086454268342274,'2023-05-24 03:07:32');
/*!40000 ALTER TABLE `user_question_subscription` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-05-24  3:50:07
